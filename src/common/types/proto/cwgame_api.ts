// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: cwgame_api.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { FieldMask } from "./google/protobuf/field_mask";
import { Struct } from "./google/protobuf/struct";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "cwgame_api";

export enum SortDirection {
  SORT_DIRECTION_UNSPECIFIED = 0,
  ASC = 1,
  DESC = 2,
  UNRECOGNIZED = -1,
}

export function sortDirectionFromJSON(object: any): SortDirection {
  switch (object) {
    case 0:
    case "SORT_DIRECTION_UNSPECIFIED":
      return SortDirection.SORT_DIRECTION_UNSPECIFIED;
    case 1:
    case "ASC":
      return SortDirection.ASC;
    case 2:
    case "DESC":
      return SortDirection.DESC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SortDirection.UNRECOGNIZED;
  }
}

export function sortDirectionToJSON(object: SortDirection): string {
  switch (object) {
    case SortDirection.SORT_DIRECTION_UNSPECIFIED:
      return "SORT_DIRECTION_UNSPECIFIED";
    case SortDirection.ASC:
      return "ASC";
    case SortDirection.DESC:
      return "DESC";
    case SortDirection.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum FilterOperator {
  FILTER_OPERATOR_UNSPECIFIED = 0,
  EQUALS = 1,
  NOT_EQUALS = 2,
  GREATER_THAN = 3,
  LESS_THAN = 4,
  GREATER_EQUAL = 5,
  LESS_EQUAL = 6,
  CONTAINS = 7,
  STARTS_WITH = 8,
  ENDS_WITH = 9,
  IN = 10,
  NOT_IN = 11,
  IS_NULL = 12,
  IS_NOT_NULL = 13,
  UNRECOGNIZED = -1,
}

export function filterOperatorFromJSON(object: any): FilterOperator {
  switch (object) {
    case 0:
    case "FILTER_OPERATOR_UNSPECIFIED":
      return FilterOperator.FILTER_OPERATOR_UNSPECIFIED;
    case 1:
    case "EQUALS":
      return FilterOperator.EQUALS;
    case 2:
    case "NOT_EQUALS":
      return FilterOperator.NOT_EQUALS;
    case 3:
    case "GREATER_THAN":
      return FilterOperator.GREATER_THAN;
    case 4:
    case "LESS_THAN":
      return FilterOperator.LESS_THAN;
    case 5:
    case "GREATER_EQUAL":
      return FilterOperator.GREATER_EQUAL;
    case 6:
    case "LESS_EQUAL":
      return FilterOperator.LESS_EQUAL;
    case 7:
    case "CONTAINS":
      return FilterOperator.CONTAINS;
    case 8:
    case "STARTS_WITH":
      return FilterOperator.STARTS_WITH;
    case 9:
    case "ENDS_WITH":
      return FilterOperator.ENDS_WITH;
    case 10:
    case "IN":
      return FilterOperator.IN;
    case 11:
    case "NOT_IN":
      return FilterOperator.NOT_IN;
    case 12:
    case "IS_NULL":
      return FilterOperator.IS_NULL;
    case 13:
    case "IS_NOT_NULL":
      return FilterOperator.IS_NOT_NULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FilterOperator.UNRECOGNIZED;
  }
}

export function filterOperatorToJSON(object: FilterOperator): string {
  switch (object) {
    case FilterOperator.FILTER_OPERATOR_UNSPECIFIED:
      return "FILTER_OPERATOR_UNSPECIFIED";
    case FilterOperator.EQUALS:
      return "EQUALS";
    case FilterOperator.NOT_EQUALS:
      return "NOT_EQUALS";
    case FilterOperator.GREATER_THAN:
      return "GREATER_THAN";
    case FilterOperator.LESS_THAN:
      return "LESS_THAN";
    case FilterOperator.GREATER_EQUAL:
      return "GREATER_EQUAL";
    case FilterOperator.LESS_EQUAL:
      return "LESS_EQUAL";
    case FilterOperator.CONTAINS:
      return "CONTAINS";
    case FilterOperator.STARTS_WITH:
      return "STARTS_WITH";
    case FilterOperator.ENDS_WITH:
      return "ENDS_WITH";
    case FilterOperator.IN:
      return "IN";
    case FilterOperator.NOT_IN:
      return "NOT_IN";
    case FilterOperator.IS_NULL:
      return "IS_NULL";
    case FilterOperator.IS_NOT_NULL:
      return "IS_NOT_NULL";
    case FilterOperator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AccountStatus {
  ACCOUNT_STATUS_UNSPECIFIED = 0,
  ACCOUNT_STATUS_VERIFYING = 1,
  ACCOUNT_STATUS_ACTIVE = 2,
  ACCOUNT_STATUS_DEACTIVATED = 3,
  UNRECOGNIZED = -1,
}

export function accountStatusFromJSON(object: any): AccountStatus {
  switch (object) {
    case 0:
    case "ACCOUNT_STATUS_UNSPECIFIED":
      return AccountStatus.ACCOUNT_STATUS_UNSPECIFIED;
    case 1:
    case "ACCOUNT_STATUS_VERIFYING":
      return AccountStatus.ACCOUNT_STATUS_VERIFYING;
    case 2:
    case "ACCOUNT_STATUS_ACTIVE":
      return AccountStatus.ACCOUNT_STATUS_ACTIVE;
    case 3:
    case "ACCOUNT_STATUS_DEACTIVATED":
      return AccountStatus.ACCOUNT_STATUS_DEACTIVATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccountStatus.UNRECOGNIZED;
  }
}

export function accountStatusToJSON(object: AccountStatus): string {
  switch (object) {
    case AccountStatus.ACCOUNT_STATUS_UNSPECIFIED:
      return "ACCOUNT_STATUS_UNSPECIFIED";
    case AccountStatus.ACCOUNT_STATUS_VERIFYING:
      return "ACCOUNT_STATUS_VERIFYING";
    case AccountStatus.ACCOUNT_STATUS_ACTIVE:
      return "ACCOUNT_STATUS_ACTIVE";
    case AccountStatus.ACCOUNT_STATUS_DEACTIVATED:
      return "ACCOUNT_STATUS_DEACTIVATED";
    case AccountStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ElementType {
  ELEMENT_TYPE_UNSPECIFIED = 0,
  METAL = 1,
  WOOD = 2,
  WATER = 3,
  FIRE = 4,
  THUNDER = 5,
  UNRECOGNIZED = -1,
}

export function elementTypeFromJSON(object: any): ElementType {
  switch (object) {
    case 0:
    case "ELEMENT_TYPE_UNSPECIFIED":
      return ElementType.ELEMENT_TYPE_UNSPECIFIED;
    case 1:
    case "METAL":
      return ElementType.METAL;
    case 2:
    case "WOOD":
      return ElementType.WOOD;
    case 3:
    case "WATER":
      return ElementType.WATER;
    case 4:
    case "FIRE":
      return ElementType.FIRE;
    case 5:
    case "THUNDER":
      return ElementType.THUNDER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ElementType.UNRECOGNIZED;
  }
}

export function elementTypeToJSON(object: ElementType): string {
  switch (object) {
    case ElementType.ELEMENT_TYPE_UNSPECIFIED:
      return "ELEMENT_TYPE_UNSPECIFIED";
    case ElementType.METAL:
      return "METAL";
    case ElementType.WOOD:
      return "WOOD";
    case ElementType.WATER:
      return "WATER";
    case ElementType.FIRE:
      return "FIRE";
    case ElementType.THUNDER:
      return "THUNDER";
    case ElementType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CharacterClass {
  CHARACTER_CLASS_UNSPECIFIED = 0,
  WARRIOR = 1,
  MAGE = 2,
  ARCHER = 3,
  ROGUE = 4,
  UNRECOGNIZED = -1,
}

export function characterClassFromJSON(object: any): CharacterClass {
  switch (object) {
    case 0:
    case "CHARACTER_CLASS_UNSPECIFIED":
      return CharacterClass.CHARACTER_CLASS_UNSPECIFIED;
    case 1:
    case "WARRIOR":
      return CharacterClass.WARRIOR;
    case 2:
    case "MAGE":
      return CharacterClass.MAGE;
    case 3:
    case "ARCHER":
      return CharacterClass.ARCHER;
    case 4:
    case "ROGUE":
      return CharacterClass.ROGUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CharacterClass.UNRECOGNIZED;
  }
}

export function characterClassToJSON(object: CharacterClass): string {
  switch (object) {
    case CharacterClass.CHARACTER_CLASS_UNSPECIFIED:
      return "CHARACTER_CLASS_UNSPECIFIED";
    case CharacterClass.WARRIOR:
      return "WARRIOR";
    case CharacterClass.MAGE:
      return "MAGE";
    case CharacterClass.ARCHER:
      return "ARCHER";
    case CharacterClass.ROGUE:
      return "ROGUE";
    case CharacterClass.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CharacterRarity {
  CHARACTER_RARITY_UNSPECIFIED = 0,
  CHARACTER_RARITY_COMMON = 1,
  CHARACTER_RARITY_UNCOMMON = 2,
  CHARACTER_RARITY_RARE = 3,
  CHARACTER_RARITY_EPIC = 4,
  CHARACTER_RARITY_LEGENDARY = 5,
  UNRECOGNIZED = -1,
}

export function characterRarityFromJSON(object: any): CharacterRarity {
  switch (object) {
    case 0:
    case "CHARACTER_RARITY_UNSPECIFIED":
      return CharacterRarity.CHARACTER_RARITY_UNSPECIFIED;
    case 1:
    case "CHARACTER_RARITY_COMMON":
      return CharacterRarity.CHARACTER_RARITY_COMMON;
    case 2:
    case "CHARACTER_RARITY_UNCOMMON":
      return CharacterRarity.CHARACTER_RARITY_UNCOMMON;
    case 3:
    case "CHARACTER_RARITY_RARE":
      return CharacterRarity.CHARACTER_RARITY_RARE;
    case 4:
    case "CHARACTER_RARITY_EPIC":
      return CharacterRarity.CHARACTER_RARITY_EPIC;
    case 5:
    case "CHARACTER_RARITY_LEGENDARY":
      return CharacterRarity.CHARACTER_RARITY_LEGENDARY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CharacterRarity.UNRECOGNIZED;
  }
}

export function characterRarityToJSON(object: CharacterRarity): string {
  switch (object) {
    case CharacterRarity.CHARACTER_RARITY_UNSPECIFIED:
      return "CHARACTER_RARITY_UNSPECIFIED";
    case CharacterRarity.CHARACTER_RARITY_COMMON:
      return "CHARACTER_RARITY_COMMON";
    case CharacterRarity.CHARACTER_RARITY_UNCOMMON:
      return "CHARACTER_RARITY_UNCOMMON";
    case CharacterRarity.CHARACTER_RARITY_RARE:
      return "CHARACTER_RARITY_RARE";
    case CharacterRarity.CHARACTER_RARITY_EPIC:
      return "CHARACTER_RARITY_EPIC";
    case CharacterRarity.CHARACTER_RARITY_LEGENDARY:
      return "CHARACTER_RARITY_LEGENDARY";
    case CharacterRarity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CharacterStatus {
  CHARACTER_STATUS_UNSPECIFIED = 0,
  ALIVE = 1,
  DEAD = 2,
  UNRECOGNIZED = -1,
}

export function characterStatusFromJSON(object: any): CharacterStatus {
  switch (object) {
    case 0:
    case "CHARACTER_STATUS_UNSPECIFIED":
      return CharacterStatus.CHARACTER_STATUS_UNSPECIFIED;
    case 1:
    case "ALIVE":
      return CharacterStatus.ALIVE;
    case 2:
    case "DEAD":
      return CharacterStatus.DEAD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CharacterStatus.UNRECOGNIZED;
  }
}

export function characterStatusToJSON(object: CharacterStatus): string {
  switch (object) {
    case CharacterStatus.CHARACTER_STATUS_UNSPECIFIED:
      return "CHARACTER_STATUS_UNSPECIFIED";
    case CharacterStatus.ALIVE:
      return "ALIVE";
    case CharacterStatus.DEAD:
      return "DEAD";
    case CharacterStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CharacterStatsType {
  UPGRADE_CHARACTER_STATS_TYPE_UNSPECIFIED = 0,
  UPGRADE_CHARACTER_STATS_TYPE_STRENGTH = 1,
  UPGRADE_CHARACTER_STATS_TYPE_SPEED = 2,
  UPGRADE_CHARACTER_STATS_TYPE_DEFENSE = 3,
  UNRECOGNIZED = -1,
}

export function characterStatsTypeFromJSON(object: any): CharacterStatsType {
  switch (object) {
    case 0:
    case "UPGRADE_CHARACTER_STATS_TYPE_UNSPECIFIED":
      return CharacterStatsType.UPGRADE_CHARACTER_STATS_TYPE_UNSPECIFIED;
    case 1:
    case "UPGRADE_CHARACTER_STATS_TYPE_STRENGTH":
      return CharacterStatsType.UPGRADE_CHARACTER_STATS_TYPE_STRENGTH;
    case 2:
    case "UPGRADE_CHARACTER_STATS_TYPE_SPEED":
      return CharacterStatsType.UPGRADE_CHARACTER_STATS_TYPE_SPEED;
    case 3:
    case "UPGRADE_CHARACTER_STATS_TYPE_DEFENSE":
      return CharacterStatsType.UPGRADE_CHARACTER_STATS_TYPE_DEFENSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CharacterStatsType.UNRECOGNIZED;
  }
}

export function characterStatsTypeToJSON(object: CharacterStatsType): string {
  switch (object) {
    case CharacterStatsType.UPGRADE_CHARACTER_STATS_TYPE_UNSPECIFIED:
      return "UPGRADE_CHARACTER_STATS_TYPE_UNSPECIFIED";
    case CharacterStatsType.UPGRADE_CHARACTER_STATS_TYPE_STRENGTH:
      return "UPGRADE_CHARACTER_STATS_TYPE_STRENGTH";
    case CharacterStatsType.UPGRADE_CHARACTER_STATS_TYPE_SPEED:
      return "UPGRADE_CHARACTER_STATS_TYPE_SPEED";
    case CharacterStatsType.UPGRADE_CHARACTER_STATS_TYPE_DEFENSE:
      return "UPGRADE_CHARACTER_STATS_TYPE_DEFENSE";
    case CharacterStatsType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MarketTradeItemStatus {
  MARKET_TRADE_STATUS_UNSPECIFIED = 0,
  MARKET_TRADE_ACTIVE = 1,
  MARKET_TRADE_EXPIRED = 2,
  MARKET_TRADE_CANCELLED = 3,
  MARKET_TRADE_SOLD = 4,
  UNRECOGNIZED = -1,
}

export function marketTradeItemStatusFromJSON(object: any): MarketTradeItemStatus {
  switch (object) {
    case 0:
    case "MARKET_TRADE_STATUS_UNSPECIFIED":
      return MarketTradeItemStatus.MARKET_TRADE_STATUS_UNSPECIFIED;
    case 1:
    case "MARKET_TRADE_ACTIVE":
      return MarketTradeItemStatus.MARKET_TRADE_ACTIVE;
    case 2:
    case "MARKET_TRADE_EXPIRED":
      return MarketTradeItemStatus.MARKET_TRADE_EXPIRED;
    case 3:
    case "MARKET_TRADE_CANCELLED":
      return MarketTradeItemStatus.MARKET_TRADE_CANCELLED;
    case 4:
    case "MARKET_TRADE_SOLD":
      return MarketTradeItemStatus.MARKET_TRADE_SOLD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MarketTradeItemStatus.UNRECOGNIZED;
  }
}

export function marketTradeItemStatusToJSON(object: MarketTradeItemStatus): string {
  switch (object) {
    case MarketTradeItemStatus.MARKET_TRADE_STATUS_UNSPECIFIED:
      return "MARKET_TRADE_STATUS_UNSPECIFIED";
    case MarketTradeItemStatus.MARKET_TRADE_ACTIVE:
      return "MARKET_TRADE_ACTIVE";
    case MarketTradeItemStatus.MARKET_TRADE_EXPIRED:
      return "MARKET_TRADE_EXPIRED";
    case MarketTradeItemStatus.MARKET_TRADE_CANCELLED:
      return "MARKET_TRADE_CANCELLED";
    case MarketTradeItemStatus.MARKET_TRADE_SOLD:
      return "MARKET_TRADE_SOLD";
    case MarketTradeItemStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ItemType {
  ITEM_TYPE_UNSPECIFIED = 0,
  /** WEAPON - For character equipment */
  WEAPON = 1,
  /** ARMOR - For character equipment */
  ARMOR = 2,
  /** CONSUMABLE - For character equipment */
  CONSUMABLE = 3,
  /** MATERIAL - For crafting */
  MATERIAL = 4,
  /** PLANT - For land farming */
  PLANT = 5,
  /** SKILL - For skill item */
  SKILL = 6,
  UNRECOGNIZED = -1,
}

export function itemTypeFromJSON(object: any): ItemType {
  switch (object) {
    case 0:
    case "ITEM_TYPE_UNSPECIFIED":
      return ItemType.ITEM_TYPE_UNSPECIFIED;
    case 1:
    case "WEAPON":
      return ItemType.WEAPON;
    case 2:
    case "ARMOR":
      return ItemType.ARMOR;
    case 3:
    case "CONSUMABLE":
      return ItemType.CONSUMABLE;
    case 4:
    case "MATERIAL":
      return ItemType.MATERIAL;
    case 5:
    case "PLANT":
      return ItemType.PLANT;
    case 6:
    case "SKILL":
      return ItemType.SKILL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ItemType.UNRECOGNIZED;
  }
}

export function itemTypeToJSON(object: ItemType): string {
  switch (object) {
    case ItemType.ITEM_TYPE_UNSPECIFIED:
      return "ITEM_TYPE_UNSPECIFIED";
    case ItemType.WEAPON:
      return "WEAPON";
    case ItemType.ARMOR:
      return "ARMOR";
    case ItemType.CONSUMABLE:
      return "CONSUMABLE";
    case ItemType.MATERIAL:
      return "MATERIAL";
    case ItemType.PLANT:
      return "PLANT";
    case ItemType.SKILL:
      return "SKILL";
    case ItemType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ItemRarity {
  ITEM_RARITY_UNSPECIFIED = 0,
  COMMON = 1,
  UNCOMMON = 2,
  RARE = 3,
  EPIC = 4,
  LEGENDARY = 5,
  UNRECOGNIZED = -1,
}

export function itemRarityFromJSON(object: any): ItemRarity {
  switch (object) {
    case 0:
    case "ITEM_RARITY_UNSPECIFIED":
      return ItemRarity.ITEM_RARITY_UNSPECIFIED;
    case 1:
    case "COMMON":
      return ItemRarity.COMMON;
    case 2:
    case "UNCOMMON":
      return ItemRarity.UNCOMMON;
    case 3:
    case "RARE":
      return ItemRarity.RARE;
    case 4:
    case "EPIC":
      return ItemRarity.EPIC;
    case 5:
    case "LEGENDARY":
      return ItemRarity.LEGENDARY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ItemRarity.UNRECOGNIZED;
  }
}

export function itemRarityToJSON(object: ItemRarity): string {
  switch (object) {
    case ItemRarity.ITEM_RARITY_UNSPECIFIED:
      return "ITEM_RARITY_UNSPECIFIED";
    case ItemRarity.COMMON:
      return "COMMON";
    case ItemRarity.UNCOMMON:
      return "UNCOMMON";
    case ItemRarity.RARE:
      return "RARE";
    case ItemRarity.EPIC:
      return "EPIC";
    case ItemRarity.LEGENDARY:
      return "LEGENDARY";
    case ItemRarity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CurrencyType {
  CURRENCY_TYPE_UNSPECIFIED = 0,
  COIN = 1,
  USD = 2,
  VND = 3,
  UNRECOGNIZED = -1,
}

export function currencyTypeFromJSON(object: any): CurrencyType {
  switch (object) {
    case 0:
    case "CURRENCY_TYPE_UNSPECIFIED":
      return CurrencyType.CURRENCY_TYPE_UNSPECIFIED;
    case 1:
    case "COIN":
      return CurrencyType.COIN;
    case 2:
    case "USD":
      return CurrencyType.USD;
    case 3:
    case "VND":
      return CurrencyType.VND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CurrencyType.UNRECOGNIZED;
  }
}

export function currencyTypeToJSON(object: CurrencyType): string {
  switch (object) {
    case CurrencyType.CURRENCY_TYPE_UNSPECIFIED:
      return "CURRENCY_TYPE_UNSPECIFIED";
    case CurrencyType.COIN:
      return "COIN";
    case CurrencyType.USD:
      return "USD";
    case CurrencyType.VND:
      return "VND";
    case CurrencyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WalletStatus {
  WALLET_STATUS_UNSPECIFIED = 0,
  ACTIVE = 1,
  FROZEN = 2,
  PENDING = 3,
  UNRECOGNIZED = -1,
}

export function walletStatusFromJSON(object: any): WalletStatus {
  switch (object) {
    case 0:
    case "WALLET_STATUS_UNSPECIFIED":
      return WalletStatus.WALLET_STATUS_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return WalletStatus.ACTIVE;
    case 2:
    case "FROZEN":
      return WalletStatus.FROZEN;
    case 3:
    case "PENDING":
      return WalletStatus.PENDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WalletStatus.UNRECOGNIZED;
  }
}

export function walletStatusToJSON(object: WalletStatus): string {
  switch (object) {
    case WalletStatus.WALLET_STATUS_UNSPECIFIED:
      return "WALLET_STATUS_UNSPECIFIED";
    case WalletStatus.ACTIVE:
      return "ACTIVE";
    case WalletStatus.FROZEN:
      return "FROZEN";
    case WalletStatus.PENDING:
      return "PENDING";
    case WalletStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ChestType {
  CHEST_TYPE_UNSPECIFIED = 0,
  /** RUBY_CHEST - pve chest */
  RUBY_CHEST = 1,
  /** AMETHYST_CHEST - pve chest */
  AMETHYST_CHEST = 2,
  /** COMMON_CHEST - store chest */
  COMMON_CHEST = 3,
  UNCOMMON_CHEST = 4,
  RARE_CHEST = 5,
  EPIC_CHEST = 6,
  UNRECOGNIZED = -1,
}

export function chestTypeFromJSON(object: any): ChestType {
  switch (object) {
    case 0:
    case "CHEST_TYPE_UNSPECIFIED":
      return ChestType.CHEST_TYPE_UNSPECIFIED;
    case 1:
    case "RUBY_CHEST":
      return ChestType.RUBY_CHEST;
    case 2:
    case "AMETHYST_CHEST":
      return ChestType.AMETHYST_CHEST;
    case 3:
    case "COMMON_CHEST":
      return ChestType.COMMON_CHEST;
    case 4:
    case "UNCOMMON_CHEST":
      return ChestType.UNCOMMON_CHEST;
    case 5:
    case "RARE_CHEST":
      return ChestType.RARE_CHEST;
    case 6:
    case "EPIC_CHEST":
      return ChestType.EPIC_CHEST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChestType.UNRECOGNIZED;
  }
}

export function chestTypeToJSON(object: ChestType): string {
  switch (object) {
    case ChestType.CHEST_TYPE_UNSPECIFIED:
      return "CHEST_TYPE_UNSPECIFIED";
    case ChestType.RUBY_CHEST:
      return "RUBY_CHEST";
    case ChestType.AMETHYST_CHEST:
      return "AMETHYST_CHEST";
    case ChestType.COMMON_CHEST:
      return "COMMON_CHEST";
    case ChestType.UNCOMMON_CHEST:
      return "UNCOMMON_CHEST";
    case ChestType.RARE_CHEST:
      return "RARE_CHEST";
    case ChestType.EPIC_CHEST:
      return "EPIC_CHEST";
    case ChestType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LandWeatherType {
  LAND_WEATHER_TYPE_UNSPECIFIED = 0,
  NORMAL = 1,
  GOOD = 2,
  BAD = 3,
  UNRECOGNIZED = -1,
}

export function landWeatherTypeFromJSON(object: any): LandWeatherType {
  switch (object) {
    case 0:
    case "LAND_WEATHER_TYPE_UNSPECIFIED":
      return LandWeatherType.LAND_WEATHER_TYPE_UNSPECIFIED;
    case 1:
    case "NORMAL":
      return LandWeatherType.NORMAL;
    case 2:
    case "GOOD":
      return LandWeatherType.GOOD;
    case 3:
    case "BAD":
      return LandWeatherType.BAD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LandWeatherType.UNRECOGNIZED;
  }
}

export function landWeatherTypeToJSON(object: LandWeatherType): string {
  switch (object) {
    case LandWeatherType.LAND_WEATHER_TYPE_UNSPECIFIED:
      return "LAND_WEATHER_TYPE_UNSPECIFIED";
    case LandWeatherType.NORMAL:
      return "NORMAL";
    case LandWeatherType.GOOD:
      return "GOOD";
    case LandWeatherType.BAD:
      return "BAD";
    case LandWeatherType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LandSeasonType {
  LAND_SEASON_TYPE_UNSPECIFIED = 0,
  SPRING = 1,
  SUMMER = 2,
  AUTUMN = 3,
  WINTER = 4,
  UNRECOGNIZED = -1,
}

export function landSeasonTypeFromJSON(object: any): LandSeasonType {
  switch (object) {
    case 0:
    case "LAND_SEASON_TYPE_UNSPECIFIED":
      return LandSeasonType.LAND_SEASON_TYPE_UNSPECIFIED;
    case 1:
    case "SPRING":
      return LandSeasonType.SPRING;
    case 2:
    case "SUMMER":
      return LandSeasonType.SUMMER;
    case 3:
    case "AUTUMN":
      return LandSeasonType.AUTUMN;
    case 4:
    case "WINTER":
      return LandSeasonType.WINTER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LandSeasonType.UNRECOGNIZED;
  }
}

export function landSeasonTypeToJSON(object: LandSeasonType): string {
  switch (object) {
    case LandSeasonType.LAND_SEASON_TYPE_UNSPECIFIED:
      return "LAND_SEASON_TYPE_UNSPECIFIED";
    case LandSeasonType.SPRING:
      return "SPRING";
    case LandSeasonType.SUMMER:
      return "SUMMER";
    case LandSeasonType.AUTUMN:
      return "AUTUMN";
    case LandSeasonType.WINTER:
      return "WINTER";
    case LandSeasonType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LandCellState {
  LAND_CELL_STATE_UNSPECIFIED = 0,
  NOT_PLANT_ANYTHING = 1,
  PLANTED_NORMAL = 2,
  PLANTED_DRY_NEED_WATER = 3,
  PLANTED_NEED_FERTILIZER = 4,
  UNRECOGNIZED = -1,
}

export function landCellStateFromJSON(object: any): LandCellState {
  switch (object) {
    case 0:
    case "LAND_CELL_STATE_UNSPECIFIED":
      return LandCellState.LAND_CELL_STATE_UNSPECIFIED;
    case 1:
    case "NOT_PLANT_ANYTHING":
      return LandCellState.NOT_PLANT_ANYTHING;
    case 2:
    case "PLANTED_NORMAL":
      return LandCellState.PLANTED_NORMAL;
    case 3:
    case "PLANTED_DRY_NEED_WATER":
      return LandCellState.PLANTED_DRY_NEED_WATER;
    case 4:
    case "PLANTED_NEED_FERTILIZER":
      return LandCellState.PLANTED_NEED_FERTILIZER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LandCellState.UNRECOGNIZED;
  }
}

export function landCellStateToJSON(object: LandCellState): string {
  switch (object) {
    case LandCellState.LAND_CELL_STATE_UNSPECIFIED:
      return "LAND_CELL_STATE_UNSPECIFIED";
    case LandCellState.NOT_PLANT_ANYTHING:
      return "NOT_PLANT_ANYTHING";
    case LandCellState.PLANTED_NORMAL:
      return "PLANTED_NORMAL";
    case LandCellState.PLANTED_DRY_NEED_WATER:
      return "PLANTED_DRY_NEED_WATER";
    case LandCellState.PLANTED_NEED_FERTILIZER:
      return "PLANTED_NEED_FERTILIZER";
    case LandCellState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LandCellStatus {
  LAND_CELL_STATUS_UNSPECIFIED = 0,
  LOCKED = 1,
  AVAILABLE = 2,
  UNRECOGNIZED = -1,
}

export function landCellStatusFromJSON(object: any): LandCellStatus {
  switch (object) {
    case 0:
    case "LAND_CELL_STATUS_UNSPECIFIED":
      return LandCellStatus.LAND_CELL_STATUS_UNSPECIFIED;
    case 1:
    case "LOCKED":
      return LandCellStatus.LOCKED;
    case 2:
    case "AVAILABLE":
      return LandCellStatus.AVAILABLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LandCellStatus.UNRECOGNIZED;
  }
}

export function landCellStatusToJSON(object: LandCellStatus): string {
  switch (object) {
    case LandCellStatus.LAND_CELL_STATUS_UNSPECIFIED:
      return "LAND_CELL_STATUS_UNSPECIFIED";
    case LandCellStatus.LOCKED:
      return "LOCKED";
    case LandCellStatus.AVAILABLE:
      return "AVAILABLE";
    case LandCellStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LandInteractionType {
  LAND_INTERACTION_TYPE_UNSPECIFIED = 0,
  PLANT_SEEDS = 1,
  WATER_PLANT = 2,
  FERTILIZER_PLANT = 3,
  UNRECOGNIZED = -1,
}

export function landInteractionTypeFromJSON(object: any): LandInteractionType {
  switch (object) {
    case 0:
    case "LAND_INTERACTION_TYPE_UNSPECIFIED":
      return LandInteractionType.LAND_INTERACTION_TYPE_UNSPECIFIED;
    case 1:
    case "PLANT_SEEDS":
      return LandInteractionType.PLANT_SEEDS;
    case 2:
    case "WATER_PLANT":
      return LandInteractionType.WATER_PLANT;
    case 3:
    case "FERTILIZER_PLANT":
      return LandInteractionType.FERTILIZER_PLANT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LandInteractionType.UNRECOGNIZED;
  }
}

export function landInteractionTypeToJSON(object: LandInteractionType): string {
  switch (object) {
    case LandInteractionType.LAND_INTERACTION_TYPE_UNSPECIFIED:
      return "LAND_INTERACTION_TYPE_UNSPECIFIED";
    case LandInteractionType.PLANT_SEEDS:
      return "PLANT_SEEDS";
    case LandInteractionType.WATER_PLANT:
      return "WATER_PLANT";
    case LandInteractionType.FERTILIZER_PLANT:
      return "FERTILIZER_PLANT";
    case LandInteractionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BattleType {
  BATTLE_TYPE_UNSPECIFIED = 0,
  /** PVE - PvE battle */
  PVE = 1,
  /** PVP - PvP battle */
  PVP = 2,
  UNRECOGNIZED = -1,
}

export function battleTypeFromJSON(object: any): BattleType {
  switch (object) {
    case 0:
    case "BATTLE_TYPE_UNSPECIFIED":
      return BattleType.BATTLE_TYPE_UNSPECIFIED;
    case 1:
    case "PVE":
      return BattleType.PVE;
    case 2:
    case "PVP":
      return BattleType.PVP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BattleType.UNRECOGNIZED;
  }
}

export function battleTypeToJSON(object: BattleType): string {
  switch (object) {
    case BattleType.BATTLE_TYPE_UNSPECIFIED:
      return "BATTLE_TYPE_UNSPECIFIED";
    case BattleType.PVE:
      return "PVE";
    case BattleType.PVP:
      return "PVP";
    case BattleType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Standard response status */
export interface Status {
  /** HTTP status code */
  code: number;
  /** Status message */
  message: string;
  /** Success indicator */
  isSuccess: boolean;
}

/** Standard error details */
export interface Error {
  /** Error code */
  code: string;
  /** Error message */
  message: string;
  /** Error details */
  details?:
    | { [key: string]: any }
    | undefined;
  /** Error timestamp */
  timestamp: Date | undefined;
}

/** Standard response metadata */
export interface ResponseMetadata {
  /** Request ID for tracing */
  requestId: string;
  /** Response timestamp */
  timestamp:
    | Date
    | undefined;
  /** API version */
  version: string;
}

export interface CommonResponse {
  /** status code, message, success */
  status:
    | Status
    | undefined;
  /** error code, message, details */
  error?:
    | Error
    | undefined;
  /** request_id, timestamp, version */
  metadata?:
    | ResponseMetadata
    | undefined;
  /** data */
  data?: { [key: string]: any } | undefined;
}

/** Standard pagination request */
export interface PageRequest {
  /** Page size (default: 20, max: 100) */
  pageSize: number;
  /** Page token for cursor-based pagination */
  pageToken: string;
  /** Page number for offset-based pagination (alternative to page_token) */
  pageNumber: number;
}

/** Standard pagination response */
export interface PageResponse {
  /** Current page token */
  pageToken: string;
  /** Next page token (empty if no more pages) */
  nextPageToken: string;
  /** Previous page token (empty if first page) */
  prevPageToken: string;
  /** Total number of items */
  totalCount: number;
  /** Total number of pages */
  totalPages: number;
  /** Current page number */
  currentPage: number;
  /** Items per page */
  pageSize: number;
}

/** Standard sorting options */
export interface SortOption {
  /** Field to sort by */
  field: string;
  /** Sort direction */
  direction: SortDirection;
}

/** Standard filter options */
export interface FilterOption {
  /** Field to filter by */
  field: string;
  /** Filter operator */
  operator: FilterOperator;
  /** Single value for most operators */
  value: string;
  /** Multiple values for IN/NOT_IN operators */
  values: string[];
}

/** Standard search options */
export interface SearchOption {
  /** Search query */
  query: string;
  /** Fields to search in */
  fields: string[];
  /** Enable fuzzy search */
  fuzzy: boolean;
  /** Search language */
  language: string;
}

/** User entity matching app.users table */
export interface User {
  /** Unique identifier (UUID) */
  id: string;
  /** Username */
  username: string;
  /** Display name */
  displayName: string;
  /** Avatar URL */
  avatarUrl: string;
  /** Language tag */
  langTag: string;
  /** Nk account ID */
  nkAccountId?:
    | string
    | undefined;
  /** Email */
  email?:
    | string
    | undefined;
  /** Phone number */
  phoneNumber?: string | undefined;
}

export interface UserRef {
  id: string;
  username: string;
  displayName: string;
  avatarUrl: string;
  nkAccountId?: string | undefined;
}

export interface UserProfile {
  /** Unique identifier (UUID) */
  id: string;
  /** Username */
  username: string;
  /** Display name */
  displayName: string;
  /** Avatar URL */
  avatarUrl: string;
  /** Language tag */
  langTag: string;
  /** Nk account ID */
  nkAccountId?:
    | string
    | undefined;
  /** Email */
  email?:
    | string
    | undefined;
  /** Phone number */
  phoneNumber?:
    | string
    | undefined;
  /** Enable farming */
  enableFarming: boolean;
  /** Metadata */
  metadata?:
    | { [key: string]: any }
    | undefined;
  /** Experience points */
  experiencePoints: number;
  /** Level */
  level: number;
  /** Total experience points */
  accountStatus: AccountStatus;
  /** last login at */
  lastLoginAt?:
    | string
    | undefined;
  /** land */
  land?: LandRef | undefined;
}

/** Item reference for both item and inventory item */
export interface ItemRef {
  itemCode: string;
  /** quantity of item which is required/dropped/received */
  quantity: number;
  itemName?:
    | string
    | undefined;
  /** total quantity of item in inventory user has (after drop/receive) */
  totalQuantity?: number | undefined;
}

export interface CharacterRef {
  id: string;
  name: string;
  rarity: CharacterRarity;
  level: number;
  experiencePoints: number;
}

/** Character entity matching app.characters table */
export interface Character {
  /** Unique identifier (UUID) */
  id: string;
  /** User ID (owner) */
  userId: string;
  /** Character name */
  characterName: string;
  /** Character class */
  characterClass?:
    | CharacterClass
    | undefined;
  /** Character rarity */
  rarity: CharacterRarity;
  /** Character level */
  level: number;
  /** Experience points */
  experiencePoints: number;
  /** Base stats (JSONB) */
  baseStats:
    | { [key: string]: any }
    | undefined;
  /** Current stats including equipment bonuses (JSONB) */
  currentStats:
    | { [key: string]: any }
    | undefined;
  /** Equipped items (JSONB) */
  equippedItems:
    | { [key: string]: any }
    | undefined;
  /** Skills (JSONB array) */
  appearance?:
    | { [key: string]: any }
    | undefined;
  /** Character status */
  status: CharacterStatus;
  /** Last battle timestamp */
  lastBattleAt?:
    | string
    | undefined;
  /** Lifetime duration */
  lifetimeDurationInHours?:
    | number
    | undefined;
  /** Start lifetime */
  startLifetime?:
    | string
    | undefined;
  /** End lifetime */
  endLifetime?:
    | string
    | undefined;
  /** Is alive */
  isAlive: boolean;
  /** Required food */
  requiredFood?:
    | number
    | undefined;
  /** Current energy */
  currentEnergy: number;
  /** Used energy in day */
  usedEnergyInDay: number;
  /** max energy per day (this get from config) */
  maxEnergyPerDay: number;
  /** Metadata */
  metadata?:
    | { [key: string]: any }
    | undefined;
  /** Creation timestamp */
  createdAt: string;
  /** Last update timestamp */
  updatedAt?:
    | string
    | undefined;
  /** Egg type (GEN1, GEN2) which character is from */
  eggType: string;
  /** Experience to next level */
  eXPToNextLevel: number;
  /** coin upgrade fee */
  coinUpgradeFee?:
    | number
    | undefined;
  /** item requirements */
  requiredItemsToUpgrade: ItemRef[];
  /**
   * unlock skill slot config of next level. If there is no next level, this
   * will be null. ex: unlock 2 skill slots, next_unlock_skill_slot_config will
   * be for slot 3.
   */
  nextUnlockSkillSlotConfig?:
    | SkillSlotConfig
    | undefined;
  /** character skills (0-7) . There are 8 skill slots in total. */
  characterSkills: CharacterSkill[];
}

export interface SkillSlotConfig {
  /** 0-7 (0-7 means there are 8 skill slots in total) */
  slotNumber: number;
  /** level required to unlock the skill slot */
  levelRequired: number;
  /** items required to unlock the skill slot */
  requiredItems: ItemRef[];
  /** coin unlock fee to unlock the skill slot */
  coinUnlockFee: number;
}

export interface CharacterSkill {
  /**
   * slot number of character skill slot (0-7). There are 8 skill slots in
   * total.
   */
  slotNumber: number;
  isUnlocked: boolean;
  /** if this slot is unlocked and has skill, this will be the skill detail. */
  skill?: UserSkill | undefined;
}

export interface UserSkill {
  id: string;
  code: string;
  name: string;
  elementType: ElementType;
  level: number;
  primaryAttributeType: string;
  /** point, percent */
  primaryAttributeRate: string;
  primaryAttributeValue: number;
  secondaryAttributeType?:
    | string
    | undefined;
  /** point, percent */
  secondaryAttributeRate?: string | undefined;
  secondaryAttributeValue?: number | undefined;
  description: string;
  acquiredAt: string;
}

export interface ListCharactersRequest {
  userId: string;
  page: PageRequest | undefined;
  sort: SortOption[];
  filters: FilterOption[];
  search: SearchOption | undefined;
}

export interface ListCharactersResponse {
  status: Status | undefined;
  data: ListCharactersData | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface ListCharactersData {
  characters: Character[];
  pagination: PageResponse | undefined;
}

export interface GetCharacterRequest {
  characterId: string;
}

export interface GetCharacterResponse {
  status: Status | undefined;
  data: Character | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface UpdateCharacterRequest {
  characterId: string;
  characterName?: string | undefined;
  updateMask: string[] | undefined;
}

export interface UpdateCharacterResponse {
  status: Status | undefined;
  data: Character | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface EquipItemRequest {
  characterId: string;
  userSkillId: string;
  slotNumber: number;
}

export interface EquipItemResponse {
  status: Status | undefined;
  data: Character | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface UnequipItemRequest {
  characterId: string;
  slotNumber: number;
}

export interface UnequipItemResponse {
  status: Status | undefined;
  data: Character | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface FeedCharacterRequest {
  characterId: string;
}

export interface FeedCharacterResponse {
  status: Status | undefined;
  data: Character | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface RequestUnlockSkillSlot {
  characterId: string;
}

export interface ResponseUnlockSkillSlot {
  status: Status | undefined;
  data: Character | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface SetDefaultCharacterRequest {
  characterId: string;
}

export interface SetDefaultCharacterResponse {
  status: Status | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface LevelUpCharacterRequest {
  characterId: string;
}

export interface LevelUpCharacterResponse {
  status: Status | undefined;
  data: Character | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface UpgradeCharacterStatsRequest {
  characterId: string;
  userId: string;
  statsType: CharacterStatsType;
}

export interface UpgradeCharacterStatsResponse {
  status: Status | undefined;
  data: UpgradeCharacterStatsData | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface UpgradeCharacterStatsData {
  character: Character | undefined;
  isSuccessful: boolean;
}

/** Item entity matching app.items table */
export interface Item {
  /** Unique identifier (UUID) */
  id: string;
  /** Item code (unique) */
  itemCode: string;
  /** Item name */
  itemName: string;
  /** Item type */
  itemType: ItemType;
  /** Item rarity */
  rarity: ItemRarity;
  /** Item category */
  category?:
    | string
    | undefined;
  /** Stats (JSONB) */
  stats?:
    | { [key: string]: any }
    | undefined;
  /** Requirements (JSONB) */
  requirements?:
    | { [key: string]: any }
    | undefined;
  /** Effects (JSONB) */
  effects?:
    | { [key: string]: any }
    | undefined;
  /** Base price */
  basePrice: number;
  /** sell price */
  sellPrice: number;
  /** Maximum stack size */
  maxStack: number;
  /** Is tradeable */
  isTradeable: boolean;
  /** Is consumable */
  isConsumable: boolean;
  /** is active */
  isActive: boolean;
  /** Description */
  description?:
    | string
    | undefined;
  /** Icon URL */
  iconUrl?:
    | string
    | undefined;
  /** Metadata (JSONB) */
  metadata?:
    | { [key: string]: any }
    | undefined;
  /** wishlist status */
  isWishlisted?: boolean | undefined;
}

export interface MarketTradeItem {
  id: string;
  item: Item | undefined;
  seller: UserRef | undefined;
  quantity: number;
  pricePerUnit: number;
  totalPrice: number;
  currencyType: CurrencyType;
  status: MarketTradeItemStatus;
  createdAt: string;
}

export interface ListShopItemsRequest {
  page: PageRequest | undefined;
  sort: SortOption[];
  filters: FilterOption[];
  search: SearchOption | undefined;
  itemType?: ItemType | undefined;
  rarity?: ItemRarity | undefined;
  isWishlisted?: boolean | undefined;
}

export interface ListShopItemsResponse {
  status: Status | undefined;
  data: ListShopItemsData | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface ListShopItemsData {
  items: Item[];
  pagination: PageResponse | undefined;
}

export interface BuyShopItemRequest {
  itemId: string;
  quantity: number;
}

export interface BuyShopItemResponse {
  status: Status | undefined;
  data: UserInventory | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface AddItemToShopRequest {
  item: Item | undefined;
}

export interface AddItemToShopResponse {
  status: Status | undefined;
  data: Item | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface AddToWishlistRequest {
  itemId: string;
}

export interface AddToWishlistResponse {
  status: Status | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface RemoveFromWishlistRequest {
  itemId: string;
}

export interface RemoveFromWishlistResponse {
  status: Status | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface ListMarketTradeItemsRequest {
  page: PageRequest | undefined;
  sort: SortOption[];
  filters: FilterOption[];
  search: SearchOption | undefined;
  itemType?: ItemType | undefined;
  rarity?: ItemRarity | undefined;
  isWishlisted?: boolean | undefined;
  userId?: string | undefined;
}

export interface ListMarketTradeItemsResponse {
  status: Status | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
  data: ListMarketTradeItemsData | undefined;
}

export interface ListMarketTradeItemsData {
  items: MarketTradeItem[];
  pagination: PageResponse | undefined;
}

export interface SellMarketTradeItemRequest {
  inventoryItemId: string;
  quantity: number;
  pricePerUnit: number;
  currencyType?: CurrencyType | undefined;
}

export interface SellMarketTradeItemResponse {
  status: Status | undefined;
  data: MarketTradeItem | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface BuyMarketTradeItemRequest {
  marketTradeItemId: string;
  quantity: number;
}

export interface BuyMarketTradeItemResponse {
  status: Status | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
  data: BuyMarketTradeItemData | undefined;
}

export interface BuyMarketTradeItemData {
  marketTradeItemId: string;
  userInventory: UserInventory | undefined;
  walletBalanceAfter: number;
}

export interface CancelMarketTradeItemRequest {
  marketTradeItemId: string;
}

export interface CancelMarketTradeItemResponse {
  status: Status | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

/** User inventory entity matching app.user_inventory table */
export interface UserInventory {
  /** Unique identifier (UUID) */
  id: string;
  /** User ID */
  userId: string;
  /** Item ID */
  itemId: string;
  /** Item details (joined from items table) */
  item:
    | Item
    | undefined;
  /** Quantity owned */
  quantity: number;
  /** Quantity locked in marketplace */
  lockedQuantity: number;
  /** Available quantity (quantity - locked_quantity) */
  availableQuantity: number;
  /** When item was acquired */
  acquiredAt: string;
  /** Item-specific metadata (JSONB) */
  metadata?:
    | { [key: string]: any }
    | undefined;
  /** Creation timestamp */
  createdAt: string;
  /** Last update timestamp */
  updatedAt?:
    | string
    | undefined;
  /** skill item if type is SKILL */
  skillItem?: UserSkill | undefined;
}

export interface GetUserInventoryRequest {
  userId: string;
  page: PageRequest | undefined;
  sort: SortOption[];
  filters: FilterOption[];
  search: SearchOption | undefined;
  itemType?: ItemType | undefined;
}

export interface GetUserInventoryResponse {
  status: Status | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
  data: GetUserInventoryData | undefined;
}

export interface GetUserInventoryData {
  items: UserInventory[];
  pagination: PageResponse | undefined;
}

export interface AddItemToInventoryRequest {
  userId: string;
  itemId: string;
  quantity: number;
  metadata: { [key: string]: string };
}

export interface AddItemToInventoryRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface AddItemToInventoryResponse {
  status: Status | undefined;
  data: UserInventory | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface GetUserInventoryCurrencyRequest {
  userId: string;
}

export interface GetUserInventoryCurrencyResponse {
  status: Status | undefined;
  data: GetUserInventoryCurrencyData | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface GetUserInventoryCurrencyData {
  /** currency_type -> total balance */
  totalBalances: { [key: string]: number };
}

export interface GetUserInventoryCurrencyData_TotalBalancesEntry {
  key: string;
  value: number;
}

export interface SellItemRequest {
  inventoryItemId: string;
  quantity: number;
}

export interface SellItemResponse {
  status: Status | undefined;
  data: UserInventory | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface GetEggSystemConfigRequest {
  userId: string;
}

export interface GetEggSystemConfigResponse {
  status: Status | undefined;
  data: GetEggSystemConfigData | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface GetEggSystemConfigData {
  /** GEN1 crafting configuration */
  gen1CraftingFee: number;
  gen1RequiredFragments: number;
  /** Percentage (0-100) */
  gen1SuccessRate: number;
  gen1FragmentsLostOnFailure: number;
  /** GEN2 opening configuration */
  gen2OpeningFee: number;
  /** Lucky leaf configuration */
  luckyLeafBoost: number;
  /** Required lucky leaf quantity */
  luckyLeafRequired: number;
  /** Lucky leaf item ID */
  luckyLeafItemId?: string | undefined;
}

/** Egg crafting request */
export interface CraftEggRequest {
  userId: string;
  /** Number of lucky leaves to use */
  luckyLeafQuantity: number;
}

/** Egg crafting response */
export interface CraftEggResponse {
  status: Status | undefined;
  data: CraftEggData | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface CraftEggData {
  success: boolean;
  /** GEN1_EGG item ID (only on success) */
  craftedEggId: string;
  /** Number of eggs crafted */
  craftedEggQuantity: number;
  /** Number of fragments consumed */
  fragmentsUsed: number;
  /** Number of lucky leaves consumed */
  luckyLeavesUsed: number;
  /** Fee paid for crafting */
  craftingFee: number;
  /** Wallet balance after crafting */
  walletBalanceAfter: number;
  /** Success/failure message */
  message: string;
}

export interface OpenItemRequest {
  userId: string;
  /** when user open item from inventory */
  inventoryItemId?: string | undefined;
  quantity: number;
  /** when user interact with some item in whole game */
  itemCode?: string | undefined;
}

export interface OpenItemResponse {
  status: Status | undefined;
  data: OpenItemData | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface OpenItemData {
  /** Generated items */
  inventoryItems: ItemRef[];
  /** Generated characters */
  characters: CharacterRef[];
  /** Generated skills */
  skills: UserSkill[];
  /** Fee paid for opening (only on success) */
  openingFee: number;
  /** Wallet balance after opening */
  walletBalanceAfter: number;
  /** Success/failure message */
  message?: string | undefined;
}

export interface GetGameSystemConfigRequest {
  userId: string;
}

export interface GetGameSystemConfigResponse {
  status: Status | undefined;
  data: GameSystemConfigData | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface GameSystemConfigData {
}

export interface ClaimChestRequest {
  chestType: ChestType;
}

export interface ClaimChestResponse {
  status: Status | undefined;
  error?: Error | undefined;
  metadata?: ResponseMetadata | undefined;
  data: OpenItemData | undefined;
}

/** Wallet entity matching app.wallets table */
export interface Wallet {
  /** Unique identifier (UUID) */
  id: string;
  /** User ID */
  userId: string;
  /** Currency type */
  currency: CurrencyType;
  /** Current balance */
  balance: number;
  /** Locked balance (for pending transactions) */
  lockedBalance: number;
  /** Available balance (balance - locked_balance) */
  availableBalance: number;
  /** Wallet status */
  status: WalletStatus;
  /** Created at */
  createdAt: string;
  /** Updated at */
  updatedAt?: string | undefined;
}

export interface GetUserWalletsRequest {
  userId: string;
}

export interface GetUserWalletsResponse {
  status: Status | undefined;
  data: GetUserWalletsData | undefined;
  error?: Error | undefined;
  metadata?: ResponseMetadata | undefined;
}

export interface GetUserWalletsData {
  wallets: Wallet[];
  /** currency_type -> total balance */
  totalBalances: { [key: string]: number };
}

export interface GetUserWalletsData_TotalBalancesEntry {
  key: string;
  value: number;
}

export interface AddCurrencyRequest {
  userId: string;
  currency: CurrencyType;
  amount: number;
  reason?: string | undefined;
}

export interface AddCurrencyResponse {
  status: Status | undefined;
  data: Wallet | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface SpendCurrencyRequest {
  userId: string;
  currency: CurrencyType;
  amount: number;
  reason?: string | undefined;
}

export interface SpendCurrencyResponse {
  status: Status | undefined;
  data: Wallet | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface RequestHelloNakama {
  name: string;
}

export interface ResponseHelloNakama {
  message: string;
}

/** Server time request (empty for now, can be extended with timezone info) */
export interface RequestServerTime {
  /** Optional timezone information */
  timezone?: string | undefined;
}

/** Server time response with current server time */
export interface ResponseServerTime {
  /** Unix timestamp in UTC */
  timestampUtc: number;
  /** ISO 8601 in UTC */
  isoTimeUtc: string;
  /** Requested timezone or "UTC" */
  timezone: string;
  /** Unix timestamp in requested timezone */
  timestampLocal: number;
  /** ISO 8601 in requested timezone */
  isoTimeLocal: string;
}

export interface GetCwUserIdByNkUserIdRequest {
  nkUserId: string;
}

export interface GetCwUserIdByNkUserIdResponse {
  cwUserId: string;
  nkUserId: string;
}

export interface GetGlobalUserRankingRequest {
  page:
    | PageRequest
    | undefined;
  /** specific user id to get user ranking */
  userId?: string | undefined;
}

export interface GetGlobalUserRankingResponse {
  status: Status | undefined;
  data: GetGlobalUserRankingData | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface GetGlobalUserRankingData {
  data: UserRankingData[];
  pagination:
    | PageResponse
    | undefined;
  /**
   * default is current authenticated user, if user_id is provided, will get
   * that specific user ranking
   */
  userRanking: UserRankingData | undefined;
}

export interface UserRankingData {
  userId: string;
  username: string;
  displayName: string;
  avatarUrl: string;
  nkUserId: string;
  rank: number;
  /** all active character exp + land exp */
  totalExp: number;
  totalCharacterExp: number;
  /** clan info (for later) */
  clanId: string;
  clanName: string;
  clanAvatarUrl: string;
  /** land info */
  landId: string;
  landLevel: number;
  landExp: number;
  landSeasonType: string;
  /** character info */
  characters: CharacterRef[];
  /** last ranking updated at (around 5-15 minutes) */
  lastUpdatedAt: string;
}

export interface GetGlobalLandRankingRequest {
  page:
    | PageRequest
    | undefined;
  /** specific user id to get user ranking */
  userId?: string | undefined;
}

export interface GetGlobalLandRankingResponse {
  status: Status | undefined;
  data: GetGlobalLandRankingData | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface GetGlobalLandRankingData {
  data: LandRankingData[];
  pagination:
    | PageResponse
    | undefined;
  /**
   * default is current authenticated user, if user_id is provided, will get
   * that specific user ranking
   */
  userRanking: LandRankingData | undefined;
}

export interface LandRankingData {
  userId: string;
  username: string;
  displayName: string;
  avatarUrl: string;
  nkUserId: string;
  rank: number;
  /** land info */
  landId: string;
  landLevel: number;
  landExp: number;
  landSeasonType: string;
  /** last ranking updated at (around 5-15 minutes) */
  lastUpdatedAt: string;
}

export interface RequestHello {
  name: string;
}

export interface ResponseHello {
  message: string;
}

export interface ResponseCommon {
  code: number;
  message: string;
}

export interface RequestSyncAccount {
  accountId: string;
  fullName: string;
  deviceId: string;
  username: string;
  password: string;
  displayName?: string | undefined;
  avatarUrl?: string | undefined;
  langTag?: string | undefined;
  location?: string | undefined;
  timezone?: string | undefined;
}

export interface ResponseSyncAccount {
  status: Status | undefined;
  data?: { [key: string]: any } | undefined;
  error?: Error | undefined;
  metadata?: ResponseMetadata | undefined;
}

export interface GetAccountByUsernameRequest {
  username: string;
}

export interface GetAccountByUsernameResponse {
  status: Status | undefined;
  error?: Error | undefined;
  metadata?:
    | ResponseMetadata
    | undefined;
  /** optional google.protobuf.Struct data = 5; */
  user?: User | undefined;
}

export interface UpdateAccountRequest {
  username: string;
  displayName: string;
  avatarUrl: string;
  langTag: string;
  location: string;
  timezone: string;
}

export interface UpdateAccountResponse {
  response: CommonResponse | undefined;
}

export interface RegisterAccountRequest {
  username: string;
  password: string;
  nkAccountId?: string | undefined;
  displayName?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
}

export interface AuthenticateAccountRequest {
  username: string;
  password: string;
  nkAccountId?: string | undefined;
}

export interface AuthenticateAccountData {
  user: User | undefined;
  accessToken: string;
  refreshToken: string;
  expiresIn: string;
}

export interface AuthenticateAccountResponse {
  status: Status | undefined;
  data?: AuthenticateAccountData | undefined;
  error?: Error | undefined;
  metadata?: ResponseMetadata | undefined;
}

export interface GetProfileRequest {
  userId: string;
}

export interface GetProfileResponse {
  status: Status | undefined;
  error?: Error | undefined;
  metadata?: ResponseMetadata | undefined;
  data?: UserProfile | undefined;
}

export interface GetChestInfoRequest {
}

export interface ChestInfo {
  id: string;
  type: ChestType;
  name: string;
  description: string;
  iconUrl: string;
  /** required items to open the chest */
  requiredItems: ItemRef[];
  /** reward items */
  rewardItems: ItemRef[];
  /** reward characters */
  rewardCharacters: CharacterRef[];
  /** price of the chest */
  price: number;
  /** currency type of the price */
  currencyType: CurrencyType;
  /**
   * discount price of the chest
   * if discount_price is not 0, it means the chest is on sale
   */
  discountPrice: number;
}

export interface GetChestInfoResponse {
  status: Status | undefined;
  error?: Error | undefined;
  metadata?: ResponseMetadata | undefined;
  data: ChestInfo[];
}

export interface LandCellInfo {
  /** Cell id */
  cellId: string;
  /** Time planted (ISO 8601 format) - plantedAt */
  timePlanted?:
    | string
    | undefined;
  /** State */
  state: LandCellState;
  /** Number of planted seeds */
  numberOfPlantedSeeds: number;
  /** cell status */
  cellStatus: LandCellStatus;
  /** slot number */
  cellNumber: number;
  /** plant duration in seconds */
  plantDurationS: number;
  /** exp gain in the cell when harvest/interaction (water/fertilizer) */
  gainedExp: number;
  /** has been stolen amount */
  stolenAmount?:
    | number
    | undefined;
  /** last stolen at */
  lastStolenAt?: string | undefined;
}

export interface LandInfo {
  /** Land cells */
  landCells: LandCellInfo[];
  /** Land level whole land */
  landLevel: number;
  /** Experience of whole land */
  eXP: number;
  /** Experience to next level */
  eXPToNextLevel: number;
  /** coin fee */
  coinFeeToNextLevel: number;
  /** Weather type (normal, good, bad) */
  weatherType: LandWeatherType;
  /** Season type (spring, summer, autumn, winter) */
  seasonType: LandSeasonType;
  /** Number of seed per cell */
  numberOfSeedPerCell: number;
  /** Grass amount */
  grassAmount: number;
  /** Seed amount */
  seedAmount: number;
}

export interface LandRef {
  id: string;
  userId: string;
  level: number;
  exp: number;
  /** Season type (spring, summer, autumn, winter) */
  seasonType: LandSeasonType;
}

export interface RequestLandInteraction {
  /** land cell number: 0 - 15 (total 16 cells) */
  landCellNumber: number;
  interactionType: LandInteractionType;
  userId: string;
}

/** Data for land interaction */
export interface LandInteractionData {
  /** Interaction type */
  interactionType: LandInteractionType;
  /** Experience updated of whole land */
  eXPUpdated: number;
  /** Updated land cell info */
  updatedLandCellInfo:
    | LandCellInfo
    | undefined;
  /** Seed amount updated in the inventory */
  seedAmountUpdated: number;
}

export interface ResponseLandInteraction {
  status: Status | undefined;
  data: LandInteractionData | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

/** Request for land level up */
export interface RequestLandLevelUp {
}

/** Data for land level up */
export interface LandLevelUpData {
  /** Land level after level up */
  landLevelUpdated: number;
  /** Experience updated */
  eXPUpdated: number;
  /** Experience to next level updated */
  eXPToNextLevelUpdated: number;
}

export interface ResponseLandLevelUp {
  status: Status | undefined;
  data: LandLevelUpData | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

/** Request for land harvest */
export interface RequestLandHarvest {
  /** If not provided, will harvest all land cells */
  landCellNumber?:
    | number
    | undefined;
  /** If true, will harvest all land cells */
  isAutoHarvest: boolean;
  /**
   * when user want to steal other user's land, user_id is the user id of the
   * neighbor user
   */
  userId: string;
}

export interface HarvestedLandCellInfo {
  /**
   * list of land cell info that harvested, only one cell if land_cell_number
   * is provided
   */
  landCell:
    | LandCellInfo
    | undefined;
  /** list of dropped items when harvest */
  droppedItems: ItemRef[];
}

/** Data for land harvest */
export interface LandHarvestData {
  /** Experience updated of whole land */
  eXPUpdated: number;
  /** Is season boost */
  isSeasonBoost: boolean;
  /**
   * total grass amount after harvest (grass amount before harvest + harvested
   * amount)
   */
  grassAmountUpdated: number;
  /**
   * Harvested land cell info. Only one cell if land_cell_number is provided,
   * otherwise all eligible cells will be harvested.
   */
  harvestedLandCells: HarvestedLandCellInfo[];
}

export interface ResponseLandHarvest {
  status: Status | undefined;
  data: LandHarvestData | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface RequestGetLandInfo {
  userId: string;
}

export interface ResponseGetLandInfo {
  status: Status | undefined;
  data?: LandInfo | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

/** Character level requirements */
export interface CharacterLevelRequirement {
  /** Minimum character level to reach this level */
  minLevel: number;
  /** Maximum character level to reach this level */
  maxLevel: number;
}

/** Experience rewards */
export interface ExperienceReward {
  /** Minimum character experience received from battle if win */
  characterMinExp: number;
  /** Maximum character experience received from battle if win */
  characterMaxExp: number;
  /** Minimum user experience received from battle if win */
  userMinExp: number;
  /** Maximum user experience received from battle if win */
  userMaxExp: number;
}

/** Currency reward */
export interface CurrencyReward {
  /** Currency type */
  currency: CurrencyType;
  /** Amount of currency */
  amount: number;
}

/** PvE level configuration */
export interface BattlePvELevelConfig {
  /** Level of the map */
  level: number;
  /** Energy lose for this level */
  energyLose: number;
  /** Character level requirements */
  characterLevel:
    | CharacterLevelRequirement
    | undefined;
  /** Experience rewards */
  receiveExp:
    | ExperienceReward
    | undefined;
  /** Currency reward */
  reward:
    | CurrencyReward
    | undefined;
  /** Probability of winning the battle (0-100) */
  probabilityWin: number;
  /** List of items that could drop */
  dropItems: ItemRef[];
}

/** PvE map information */
export interface BattlePvEMapInfo {
  /** Total level of the map */
  totalLevel: number;
  /** Config requirements, reward and experience for each level */
  levelConfigs: BattlePvELevelConfig[];
}

export interface RequestGetBattlePvEInfo {
}

export interface ResponseGetBattlePvEInfo {
  status: Status | undefined;
  data: BattlePvEMapInfo | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface RequestGetBattlePvpInfo {
}

export interface ResponseGetBattlePvpInfo {
  status: Status | undefined;
  data: BattlePvpInfo | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface RequestBattlePvE {
  /** if true, use all the energy */
  isAutoBattle: boolean;
  /** the character id of the user */
  characterId: string;
}

export interface ResponseBattlePvE {
  status:
    | Status
    | undefined;
  /**
   * 1 item if is_auto_battle is false, array of items if is_auto_battle is
   * true
   */
  data: BattlePvEData[];
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface BattlePvEData {
  isWin: boolean;
  characterExp: number;
  userExp: number;
  currencyReward: CurrencyReward | undefined;
  droppedItems: ItemRef[];
  damageDealt: number;
  damageTaken: number;
  maxDamageDealt: number;
  dodges: number;
}

export interface RequestBattlePvp {
  userId: string;
  characterId: string;
  opponentCharacterId: string;
}

export interface ResponseBattlePvp {
  status: Status | undefined;
  data: BattlePvpInfo | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface BattlePvpInfo {
  userId: string;
  characterId: string;
  opponentCharacterId: string;
}

export interface RequestGetBattleHistory {
  characterId: string;
  battleType: BattleType;
  /** ISO 8601 format */
  fromDate?:
    | string
    | undefined;
  /** ISO 8601 format */
  toDate?: string | undefined;
  page: PageRequest | undefined;
}

export interface ResponseGetBattleHistory {
  status: Status | undefined;
  data: BattleHistoryData | undefined;
  error: Error | undefined;
  metadata: ResponseMetadata | undefined;
}

export interface BattleHistoryData {
  data: BattleHistory[];
  pagination: PageResponse | undefined;
}

export interface BattleHistory {
  /** battle id */
  id: string;
  userId: string;
  characterId: string;
  opponentCharacterId?: string | undefined;
  battleType: BattleType;
  battleAt: string;
  isWin: boolean;
  characterExp: number;
  userExp: number;
  currencyReward: CurrencyReward | undefined;
  droppedItems: ItemRef[];
  damageDealt: number;
  damageTaken: number;
  maxDamageDealt: number;
  dodges: number;
}

function createBaseStatus(): Status {
  return { code: 0, message: "", isSuccess: false };
}

export const Status: MessageFns<Status> = {
  encode(message: Status, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.isSuccess !== false) {
      writer.uint32(24).bool(message.isSuccess);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Status {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isSuccess = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Status {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      isSuccess: isSet(object.isSuccess) ? globalThis.Boolean(object.isSuccess) : false,
    };
  },

  toJSON(message: Status): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.isSuccess !== false) {
      obj.isSuccess = message.isSuccess;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Status>, I>>(base?: I): Status {
    return Status.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Status>, I>>(object: I): Status {
    const message = createBaseStatus();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.isSuccess = object.isSuccess ?? false;
    return message;
  },
};

function createBaseError(): Error {
  return { code: "", message: "", details: undefined, timestamp: undefined };
}

export const Error: MessageFns<Error> = {
  encode(message: Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.details !== undefined) {
      Struct.encode(Struct.wrap(message.details), writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      details: isObject(object.details) ? object.details : undefined,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.details !== undefined) {
      obj.details = message.details;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.code = object.code ?? "";
    message.message = object.message ?? "";
    message.details = object.details ?? undefined;
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBaseResponseMetadata(): ResponseMetadata {
  return { requestId: "", timestamp: undefined, version: "" };
}

export const ResponseMetadata: MessageFns<ResponseMetadata> = {
  encode(message: ResponseMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).join();
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseMetadata {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: ResponseMetadata): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseMetadata>, I>>(base?: I): ResponseMetadata {
    return ResponseMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseMetadata>, I>>(object: I): ResponseMetadata {
    const message = createBaseResponseMetadata();
    message.requestId = object.requestId ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseCommonResponse(): CommonResponse {
  return { status: undefined, error: undefined, metadata: undefined, data: undefined };
}

export const CommonResponse: MessageFns<CommonResponse> = {
  encode(message: CommonResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.data !== undefined) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommonResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
      data: isObject(object.data) ? object.data : undefined,
    };
  },

  toJSON(message: CommonResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommonResponse>, I>>(base?: I): CommonResponse {
    return CommonResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommonResponse>, I>>(object: I): CommonResponse {
    const message = createBaseCommonResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    message.data = object.data ?? undefined;
    return message;
  },
};

function createBasePageRequest(): PageRequest {
  return { pageSize: 0, pageToken: "", pageNumber: 0 };
}

export const PageRequest: MessageFns<PageRequest> = {
  encode(message: PageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.pageNumber !== 0) {
      writer.uint32(24).int32(message.pageNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageNumber = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PageRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      pageNumber: isSet(object.pageNumber) ? globalThis.Number(object.pageNumber) : 0,
    };
  },

  toJSON(message: PageRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.pageNumber !== 0) {
      obj.pageNumber = Math.round(message.pageNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PageRequest>, I>>(base?: I): PageRequest {
    return PageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PageRequest>, I>>(object: I): PageRequest {
    const message = createBasePageRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.pageNumber = object.pageNumber ?? 0;
    return message;
  },
};

function createBasePageResponse(): PageResponse {
  return {
    pageToken: "",
    nextPageToken: "",
    prevPageToken: "",
    totalCount: 0,
    totalPages: 0,
    currentPage: 0,
    pageSize: 0,
  };
}

export const PageResponse: MessageFns<PageResponse> = {
  encode(message: PageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageToken !== "") {
      writer.uint32(10).string(message.pageToken);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.prevPageToken !== "") {
      writer.uint32(26).string(message.prevPageToken);
    }
    if (message.totalCount !== 0) {
      writer.uint32(32).int32(message.totalCount);
    }
    if (message.totalPages !== 0) {
      writer.uint32(40).int32(message.totalPages);
    }
    if (message.currentPage !== 0) {
      writer.uint32(48).int32(message.currentPage);
    }
    if (message.pageSize !== 0) {
      writer.uint32(56).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.prevPageToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.currentPage = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PageResponse {
    return {
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      prevPageToken: isSet(object.prevPageToken) ? globalThis.String(object.prevPageToken) : "",
      totalCount: isSet(object.totalCount) ? globalThis.Number(object.totalCount) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
      currentPage: isSet(object.currentPage) ? globalThis.Number(object.currentPage) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: PageResponse): unknown {
    const obj: any = {};
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.prevPageToken !== "") {
      obj.prevPageToken = message.prevPageToken;
    }
    if (message.totalCount !== 0) {
      obj.totalCount = Math.round(message.totalCount);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    if (message.currentPage !== 0) {
      obj.currentPage = Math.round(message.currentPage);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PageResponse>, I>>(base?: I): PageResponse {
    return PageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PageResponse>, I>>(object: I): PageResponse {
    const message = createBasePageResponse();
    message.pageToken = object.pageToken ?? "";
    message.nextPageToken = object.nextPageToken ?? "";
    message.prevPageToken = object.prevPageToken ?? "";
    message.totalCount = object.totalCount ?? 0;
    message.totalPages = object.totalPages ?? 0;
    message.currentPage = object.currentPage ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseSortOption(): SortOption {
  return { field: "", direction: 0 };
}

export const SortOption: MessageFns<SortOption> = {
  encode(message: SortOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.direction !== 0) {
      writer.uint32(16).int32(message.direction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SortOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSortOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SortOption {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      direction: isSet(object.direction) ? sortDirectionFromJSON(object.direction) : 0,
    };
  },

  toJSON(message: SortOption): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.direction !== 0) {
      obj.direction = sortDirectionToJSON(message.direction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SortOption>, I>>(base?: I): SortOption {
    return SortOption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SortOption>, I>>(object: I): SortOption {
    const message = createBaseSortOption();
    message.field = object.field ?? "";
    message.direction = object.direction ?? 0;
    return message;
  },
};

function createBaseFilterOption(): FilterOption {
  return { field: "", operator: 0, value: "", values: [] };
}

export const FilterOption: MessageFns<FilterOption> = {
  encode(message: FilterOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.operator !== 0) {
      writer.uint32(16).int32(message.operator);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    for (const v of message.values) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.operator = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.values.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterOption {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      operator: isSet(object.operator) ? filterOperatorFromJSON(object.operator) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: FilterOption): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.operator !== 0) {
      obj.operator = filterOperatorToJSON(message.operator);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FilterOption>, I>>(base?: I): FilterOption {
    return FilterOption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FilterOption>, I>>(object: I): FilterOption {
    const message = createBaseFilterOption();
    message.field = object.field ?? "";
    message.operator = object.operator ?? 0;
    message.value = object.value ?? "";
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseSearchOption(): SearchOption {
  return { query: "", fields: [], fuzzy: false, language: "" };
}

export const SearchOption: MessageFns<SearchOption> = {
  encode(message: SearchOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    for (const v of message.fields) {
      writer.uint32(18).string(v!);
    }
    if (message.fuzzy !== false) {
      writer.uint32(24).bool(message.fuzzy);
    }
    if (message.language !== "") {
      writer.uint32(34).string(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fields.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fuzzy = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.language = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchOption {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => globalThis.String(e)) : [],
      fuzzy: isSet(object.fuzzy) ? globalThis.Boolean(object.fuzzy) : false,
      language: isSet(object.language) ? globalThis.String(object.language) : "",
    };
  },

  toJSON(message: SearchOption): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.fields?.length) {
      obj.fields = message.fields;
    }
    if (message.fuzzy !== false) {
      obj.fuzzy = message.fuzzy;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchOption>, I>>(base?: I): SearchOption {
    return SearchOption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchOption>, I>>(object: I): SearchOption {
    const message = createBaseSearchOption();
    message.query = object.query ?? "";
    message.fields = object.fields?.map((e) => e) || [];
    message.fuzzy = object.fuzzy ?? false;
    message.language = object.language ?? "";
    return message;
  },
};

function createBaseUser(): User {
  return {
    id: "",
    username: "",
    displayName: "",
    avatarUrl: "",
    langTag: "",
    nkAccountId: undefined,
    email: undefined,
    phoneNumber: undefined,
  };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.avatarUrl !== "") {
      writer.uint32(34).string(message.avatarUrl);
    }
    if (message.langTag !== "") {
      writer.uint32(42).string(message.langTag);
    }
    if (message.nkAccountId !== undefined) {
      writer.uint32(50).string(message.nkAccountId);
    }
    if (message.email !== undefined) {
      writer.uint32(58).string(message.email);
    }
    if (message.phoneNumber !== undefined) {
      writer.uint32(66).string(message.phoneNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.langTag = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.nkAccountId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      avatarUrl: isSet(object.avatarUrl) ? globalThis.String(object.avatarUrl) : "",
      langTag: isSet(object.langTag) ? globalThis.String(object.langTag) : "",
      nkAccountId: isSet(object.nkAccountId) ? globalThis.String(object.nkAccountId) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : undefined,
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.avatarUrl !== "") {
      obj.avatarUrl = message.avatarUrl;
    }
    if (message.langTag !== "") {
      obj.langTag = message.langTag;
    }
    if (message.nkAccountId !== undefined) {
      obj.nkAccountId = message.nkAccountId;
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.phoneNumber !== undefined) {
      obj.phoneNumber = message.phoneNumber;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.id = object.id ?? "";
    message.username = object.username ?? "";
    message.displayName = object.displayName ?? "";
    message.avatarUrl = object.avatarUrl ?? "";
    message.langTag = object.langTag ?? "";
    message.nkAccountId = object.nkAccountId ?? undefined;
    message.email = object.email ?? undefined;
    message.phoneNumber = object.phoneNumber ?? undefined;
    return message;
  },
};

function createBaseUserRef(): UserRef {
  return { id: "", username: "", displayName: "", avatarUrl: "", nkAccountId: undefined };
}

export const UserRef: MessageFns<UserRef> = {
  encode(message: UserRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.avatarUrl !== "") {
      writer.uint32(34).string(message.avatarUrl);
    }
    if (message.nkAccountId !== undefined) {
      writer.uint32(42).string(message.nkAccountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nkAccountId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserRef {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      avatarUrl: isSet(object.avatarUrl) ? globalThis.String(object.avatarUrl) : "",
      nkAccountId: isSet(object.nkAccountId) ? globalThis.String(object.nkAccountId) : undefined,
    };
  },

  toJSON(message: UserRef): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.avatarUrl !== "") {
      obj.avatarUrl = message.avatarUrl;
    }
    if (message.nkAccountId !== undefined) {
      obj.nkAccountId = message.nkAccountId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserRef>, I>>(base?: I): UserRef {
    return UserRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserRef>, I>>(object: I): UserRef {
    const message = createBaseUserRef();
    message.id = object.id ?? "";
    message.username = object.username ?? "";
    message.displayName = object.displayName ?? "";
    message.avatarUrl = object.avatarUrl ?? "";
    message.nkAccountId = object.nkAccountId ?? undefined;
    return message;
  },
};

function createBaseUserProfile(): UserProfile {
  return {
    id: "",
    username: "",
    displayName: "",
    avatarUrl: "",
    langTag: "",
    nkAccountId: undefined,
    email: undefined,
    phoneNumber: undefined,
    enableFarming: false,
    metadata: undefined,
    experiencePoints: 0,
    level: 0,
    accountStatus: 0,
    lastLoginAt: undefined,
    land: undefined,
  };
}

export const UserProfile: MessageFns<UserProfile> = {
  encode(message: UserProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.avatarUrl !== "") {
      writer.uint32(34).string(message.avatarUrl);
    }
    if (message.langTag !== "") {
      writer.uint32(42).string(message.langTag);
    }
    if (message.nkAccountId !== undefined) {
      writer.uint32(50).string(message.nkAccountId);
    }
    if (message.email !== undefined) {
      writer.uint32(58).string(message.email);
    }
    if (message.phoneNumber !== undefined) {
      writer.uint32(66).string(message.phoneNumber);
    }
    if (message.enableFarming !== false) {
      writer.uint32(72).bool(message.enableFarming);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(82).fork()).join();
    }
    if (message.experiencePoints !== 0) {
      writer.uint32(88).int64(message.experiencePoints);
    }
    if (message.level !== 0) {
      writer.uint32(96).int32(message.level);
    }
    if (message.accountStatus !== 0) {
      writer.uint32(104).int32(message.accountStatus);
    }
    if (message.lastLoginAt !== undefined) {
      writer.uint32(114).string(message.lastLoginAt);
    }
    if (message.land !== undefined) {
      LandRef.encode(message.land, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.langTag = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.nkAccountId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.enableFarming = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.experiencePoints = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.level = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.accountStatus = reader.int32() as any;
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.lastLoginAt = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.land = LandRef.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProfile {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      avatarUrl: isSet(object.avatarUrl) ? globalThis.String(object.avatarUrl) : "",
      langTag: isSet(object.langTag) ? globalThis.String(object.langTag) : "",
      nkAccountId: isSet(object.nkAccountId) ? globalThis.String(object.nkAccountId) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : undefined,
      enableFarming: isSet(object.enableFarming) ? globalThis.Boolean(object.enableFarming) : false,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      experiencePoints: isSet(object.experiencePoints) ? globalThis.Number(object.experiencePoints) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      accountStatus: isSet(object.accountStatus) ? accountStatusFromJSON(object.accountStatus) : 0,
      lastLoginAt: isSet(object.lastLoginAt) ? globalThis.String(object.lastLoginAt) : undefined,
      land: isSet(object.land) ? LandRef.fromJSON(object.land) : undefined,
    };
  },

  toJSON(message: UserProfile): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.avatarUrl !== "") {
      obj.avatarUrl = message.avatarUrl;
    }
    if (message.langTag !== "") {
      obj.langTag = message.langTag;
    }
    if (message.nkAccountId !== undefined) {
      obj.nkAccountId = message.nkAccountId;
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.phoneNumber !== undefined) {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.enableFarming !== false) {
      obj.enableFarming = message.enableFarming;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.experiencePoints !== 0) {
      obj.experiencePoints = Math.round(message.experiencePoints);
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.accountStatus !== 0) {
      obj.accountStatus = accountStatusToJSON(message.accountStatus);
    }
    if (message.lastLoginAt !== undefined) {
      obj.lastLoginAt = message.lastLoginAt;
    }
    if (message.land !== undefined) {
      obj.land = LandRef.toJSON(message.land);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserProfile>, I>>(base?: I): UserProfile {
    return UserProfile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserProfile>, I>>(object: I): UserProfile {
    const message = createBaseUserProfile();
    message.id = object.id ?? "";
    message.username = object.username ?? "";
    message.displayName = object.displayName ?? "";
    message.avatarUrl = object.avatarUrl ?? "";
    message.langTag = object.langTag ?? "";
    message.nkAccountId = object.nkAccountId ?? undefined;
    message.email = object.email ?? undefined;
    message.phoneNumber = object.phoneNumber ?? undefined;
    message.enableFarming = object.enableFarming ?? false;
    message.metadata = object.metadata ?? undefined;
    message.experiencePoints = object.experiencePoints ?? 0;
    message.level = object.level ?? 0;
    message.accountStatus = object.accountStatus ?? 0;
    message.lastLoginAt = object.lastLoginAt ?? undefined;
    message.land = (object.land !== undefined && object.land !== null) ? LandRef.fromPartial(object.land) : undefined;
    return message;
  },
};

function createBaseItemRef(): ItemRef {
  return { itemCode: "", quantity: 0, itemName: undefined, totalQuantity: undefined };
}

export const ItemRef: MessageFns<ItemRef> = {
  encode(message: ItemRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemCode !== "") {
      writer.uint32(10).string(message.itemCode);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).uint32(message.quantity);
    }
    if (message.itemName !== undefined) {
      writer.uint32(26).string(message.itemName);
    }
    if (message.totalQuantity !== undefined) {
      writer.uint32(32).uint32(message.totalQuantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.itemCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.itemName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalQuantity = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemRef {
    return {
      itemCode: isSet(object.itemCode) ? globalThis.String(object.itemCode) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      itemName: isSet(object.itemName) ? globalThis.String(object.itemName) : undefined,
      totalQuantity: isSet(object.totalQuantity) ? globalThis.Number(object.totalQuantity) : undefined,
    };
  },

  toJSON(message: ItemRef): unknown {
    const obj: any = {};
    if (message.itemCode !== "") {
      obj.itemCode = message.itemCode;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.itemName !== undefined) {
      obj.itemName = message.itemName;
    }
    if (message.totalQuantity !== undefined) {
      obj.totalQuantity = Math.round(message.totalQuantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemRef>, I>>(base?: I): ItemRef {
    return ItemRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemRef>, I>>(object: I): ItemRef {
    const message = createBaseItemRef();
    message.itemCode = object.itemCode ?? "";
    message.quantity = object.quantity ?? 0;
    message.itemName = object.itemName ?? undefined;
    message.totalQuantity = object.totalQuantity ?? undefined;
    return message;
  },
};

function createBaseCharacterRef(): CharacterRef {
  return { id: "", name: "", rarity: 0, level: 0, experiencePoints: 0 };
}

export const CharacterRef: MessageFns<CharacterRef> = {
  encode(message: CharacterRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.rarity !== 0) {
      writer.uint32(24).int32(message.rarity);
    }
    if (message.level !== 0) {
      writer.uint32(32).uint32(message.level);
    }
    if (message.experiencePoints !== 0) {
      writer.uint32(40).int64(message.experiencePoints);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rarity = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.level = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.experiencePoints = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterRef {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      rarity: isSet(object.rarity) ? characterRarityFromJSON(object.rarity) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      experiencePoints: isSet(object.experiencePoints) ? globalThis.Number(object.experiencePoints) : 0,
    };
  },

  toJSON(message: CharacterRef): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.rarity !== 0) {
      obj.rarity = characterRarityToJSON(message.rarity);
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.experiencePoints !== 0) {
      obj.experiencePoints = Math.round(message.experiencePoints);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterRef>, I>>(base?: I): CharacterRef {
    return CharacterRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterRef>, I>>(object: I): CharacterRef {
    const message = createBaseCharacterRef();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.rarity = object.rarity ?? 0;
    message.level = object.level ?? 0;
    message.experiencePoints = object.experiencePoints ?? 0;
    return message;
  },
};

function createBaseCharacter(): Character {
  return {
    id: "",
    userId: "",
    characterName: "",
    characterClass: undefined,
    rarity: 0,
    level: 0,
    experiencePoints: 0,
    baseStats: undefined,
    currentStats: undefined,
    equippedItems: undefined,
    appearance: undefined,
    status: 0,
    lastBattleAt: undefined,
    lifetimeDurationInHours: undefined,
    startLifetime: undefined,
    endLifetime: undefined,
    isAlive: false,
    requiredFood: undefined,
    currentEnergy: 0,
    usedEnergyInDay: 0,
    maxEnergyPerDay: 0,
    metadata: undefined,
    createdAt: "",
    updatedAt: undefined,
    eggType: "",
    eXPToNextLevel: 0,
    coinUpgradeFee: undefined,
    requiredItemsToUpgrade: [],
    nextUnlockSkillSlotConfig: undefined,
    characterSkills: [],
  };
}

export const Character: MessageFns<Character> = {
  encode(message: Character, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.characterName !== "") {
      writer.uint32(26).string(message.characterName);
    }
    if (message.characterClass !== undefined) {
      writer.uint32(32).int32(message.characterClass);
    }
    if (message.rarity !== 0) {
      writer.uint32(40).int32(message.rarity);
    }
    if (message.level !== 0) {
      writer.uint32(48).uint32(message.level);
    }
    if (message.experiencePoints !== 0) {
      writer.uint32(56).int64(message.experiencePoints);
    }
    if (message.baseStats !== undefined) {
      Struct.encode(Struct.wrap(message.baseStats), writer.uint32(66).fork()).join();
    }
    if (message.currentStats !== undefined) {
      Struct.encode(Struct.wrap(message.currentStats), writer.uint32(74).fork()).join();
    }
    if (message.equippedItems !== undefined) {
      Struct.encode(Struct.wrap(message.equippedItems), writer.uint32(82).fork()).join();
    }
    if (message.appearance !== undefined) {
      Struct.encode(Struct.wrap(message.appearance), writer.uint32(90).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(96).int32(message.status);
    }
    if (message.lastBattleAt !== undefined) {
      writer.uint32(106).string(message.lastBattleAt);
    }
    if (message.lifetimeDurationInHours !== undefined) {
      writer.uint32(112).int32(message.lifetimeDurationInHours);
    }
    if (message.startLifetime !== undefined) {
      writer.uint32(122).string(message.startLifetime);
    }
    if (message.endLifetime !== undefined) {
      writer.uint32(130).string(message.endLifetime);
    }
    if (message.isAlive !== false) {
      writer.uint32(136).bool(message.isAlive);
    }
    if (message.requiredFood !== undefined) {
      writer.uint32(144).int32(message.requiredFood);
    }
    if (message.currentEnergy !== 0) {
      writer.uint32(152).int32(message.currentEnergy);
    }
    if (message.usedEnergyInDay !== 0) {
      writer.uint32(160).int32(message.usedEnergyInDay);
    }
    if (message.maxEnergyPerDay !== 0) {
      writer.uint32(168).int32(message.maxEnergyPerDay);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(178).fork()).join();
    }
    if (message.createdAt !== "") {
      writer.uint32(186).string(message.createdAt);
    }
    if (message.updatedAt !== undefined) {
      writer.uint32(194).string(message.updatedAt);
    }
    if (message.eggType !== "") {
      writer.uint32(202).string(message.eggType);
    }
    if (message.eXPToNextLevel !== 0) {
      writer.uint32(208).int64(message.eXPToNextLevel);
    }
    if (message.coinUpgradeFee !== undefined) {
      writer.uint32(216).uint32(message.coinUpgradeFee);
    }
    for (const v of message.requiredItemsToUpgrade) {
      ItemRef.encode(v!, writer.uint32(226).fork()).join();
    }
    if (message.nextUnlockSkillSlotConfig !== undefined) {
      SkillSlotConfig.encode(message.nextUnlockSkillSlotConfig, writer.uint32(234).fork()).join();
    }
    for (const v of message.characterSkills) {
      CharacterSkill.encode(v!, writer.uint32(242).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Character {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.characterName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.characterClass = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rarity = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.level = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.experiencePoints = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.baseStats = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.currentStats = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.equippedItems = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.appearance = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.lastBattleAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.lifetimeDurationInHours = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.startLifetime = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.endLifetime = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.isAlive = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.requiredFood = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.currentEnergy = reader.int32();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.usedEnergyInDay = reader.int32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.maxEnergyPerDay = reader.int32();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.eggType = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.eXPToNextLevel = longToNumber(reader.int64());
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.coinUpgradeFee = reader.uint32();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.requiredItemsToUpgrade.push(ItemRef.decode(reader, reader.uint32()));
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.nextUnlockSkillSlotConfig = SkillSlotConfig.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.characterSkills.push(CharacterSkill.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Character {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      characterName: isSet(object.characterName) ? globalThis.String(object.characterName) : "",
      characterClass: isSet(object.characterClass) ? characterClassFromJSON(object.characterClass) : undefined,
      rarity: isSet(object.rarity) ? characterRarityFromJSON(object.rarity) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      experiencePoints: isSet(object.experiencePoints) ? globalThis.Number(object.experiencePoints) : 0,
      baseStats: isObject(object.baseStats) ? object.baseStats : undefined,
      currentStats: isObject(object.currentStats) ? object.currentStats : undefined,
      equippedItems: isObject(object.equippedItems) ? object.equippedItems : undefined,
      appearance: isObject(object.appearance) ? object.appearance : undefined,
      status: isSet(object.status) ? characterStatusFromJSON(object.status) : 0,
      lastBattleAt: isSet(object.lastBattleAt) ? globalThis.String(object.lastBattleAt) : undefined,
      lifetimeDurationInHours: isSet(object.lifetimeDurationInHours)
        ? globalThis.Number(object.lifetimeDurationInHours)
        : undefined,
      startLifetime: isSet(object.startLifetime) ? globalThis.String(object.startLifetime) : undefined,
      endLifetime: isSet(object.endLifetime) ? globalThis.String(object.endLifetime) : undefined,
      isAlive: isSet(object.isAlive) ? globalThis.Boolean(object.isAlive) : false,
      requiredFood: isSet(object.requiredFood) ? globalThis.Number(object.requiredFood) : undefined,
      currentEnergy: isSet(object.currentEnergy) ? globalThis.Number(object.currentEnergy) : 0,
      usedEnergyInDay: isSet(object.usedEnergyInDay) ? globalThis.Number(object.usedEnergyInDay) : 0,
      maxEnergyPerDay: isSet(object.maxEnergyPerDay) ? globalThis.Number(object.maxEnergyPerDay) : 0,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : undefined,
      eggType: isSet(object.eggType) ? globalThis.String(object.eggType) : "",
      eXPToNextLevel: isSet(object.eXPToNextLevel) ? globalThis.Number(object.eXPToNextLevel) : 0,
      coinUpgradeFee: isSet(object.coinUpgradeFee) ? globalThis.Number(object.coinUpgradeFee) : undefined,
      requiredItemsToUpgrade: globalThis.Array.isArray(object?.requiredItemsToUpgrade)
        ? object.requiredItemsToUpgrade.map((e: any) => ItemRef.fromJSON(e))
        : [],
      nextUnlockSkillSlotConfig: isSet(object.nextUnlockSkillSlotConfig)
        ? SkillSlotConfig.fromJSON(object.nextUnlockSkillSlotConfig)
        : undefined,
      characterSkills: globalThis.Array.isArray(object?.characterSkills)
        ? object.characterSkills.map((e: any) => CharacterSkill.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Character): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.characterName !== "") {
      obj.characterName = message.characterName;
    }
    if (message.characterClass !== undefined) {
      obj.characterClass = characterClassToJSON(message.characterClass);
    }
    if (message.rarity !== 0) {
      obj.rarity = characterRarityToJSON(message.rarity);
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.experiencePoints !== 0) {
      obj.experiencePoints = Math.round(message.experiencePoints);
    }
    if (message.baseStats !== undefined) {
      obj.baseStats = message.baseStats;
    }
    if (message.currentStats !== undefined) {
      obj.currentStats = message.currentStats;
    }
    if (message.equippedItems !== undefined) {
      obj.equippedItems = message.equippedItems;
    }
    if (message.appearance !== undefined) {
      obj.appearance = message.appearance;
    }
    if (message.status !== 0) {
      obj.status = characterStatusToJSON(message.status);
    }
    if (message.lastBattleAt !== undefined) {
      obj.lastBattleAt = message.lastBattleAt;
    }
    if (message.lifetimeDurationInHours !== undefined) {
      obj.lifetimeDurationInHours = Math.round(message.lifetimeDurationInHours);
    }
    if (message.startLifetime !== undefined) {
      obj.startLifetime = message.startLifetime;
    }
    if (message.endLifetime !== undefined) {
      obj.endLifetime = message.endLifetime;
    }
    if (message.isAlive !== false) {
      obj.isAlive = message.isAlive;
    }
    if (message.requiredFood !== undefined) {
      obj.requiredFood = Math.round(message.requiredFood);
    }
    if (message.currentEnergy !== 0) {
      obj.currentEnergy = Math.round(message.currentEnergy);
    }
    if (message.usedEnergyInDay !== 0) {
      obj.usedEnergyInDay = Math.round(message.usedEnergyInDay);
    }
    if (message.maxEnergyPerDay !== 0) {
      obj.maxEnergyPerDay = Math.round(message.maxEnergyPerDay);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt;
    }
    if (message.eggType !== "") {
      obj.eggType = message.eggType;
    }
    if (message.eXPToNextLevel !== 0) {
      obj.eXPToNextLevel = Math.round(message.eXPToNextLevel);
    }
    if (message.coinUpgradeFee !== undefined) {
      obj.coinUpgradeFee = Math.round(message.coinUpgradeFee);
    }
    if (message.requiredItemsToUpgrade?.length) {
      obj.requiredItemsToUpgrade = message.requiredItemsToUpgrade.map((e) => ItemRef.toJSON(e));
    }
    if (message.nextUnlockSkillSlotConfig !== undefined) {
      obj.nextUnlockSkillSlotConfig = SkillSlotConfig.toJSON(message.nextUnlockSkillSlotConfig);
    }
    if (message.characterSkills?.length) {
      obj.characterSkills = message.characterSkills.map((e) => CharacterSkill.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Character>, I>>(base?: I): Character {
    return Character.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Character>, I>>(object: I): Character {
    const message = createBaseCharacter();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.characterName = object.characterName ?? "";
    message.characterClass = object.characterClass ?? undefined;
    message.rarity = object.rarity ?? 0;
    message.level = object.level ?? 0;
    message.experiencePoints = object.experiencePoints ?? 0;
    message.baseStats = object.baseStats ?? undefined;
    message.currentStats = object.currentStats ?? undefined;
    message.equippedItems = object.equippedItems ?? undefined;
    message.appearance = object.appearance ?? undefined;
    message.status = object.status ?? 0;
    message.lastBattleAt = object.lastBattleAt ?? undefined;
    message.lifetimeDurationInHours = object.lifetimeDurationInHours ?? undefined;
    message.startLifetime = object.startLifetime ?? undefined;
    message.endLifetime = object.endLifetime ?? undefined;
    message.isAlive = object.isAlive ?? false;
    message.requiredFood = object.requiredFood ?? undefined;
    message.currentEnergy = object.currentEnergy ?? 0;
    message.usedEnergyInDay = object.usedEnergyInDay ?? 0;
    message.maxEnergyPerDay = object.maxEnergyPerDay ?? 0;
    message.metadata = object.metadata ?? undefined;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? undefined;
    message.eggType = object.eggType ?? "";
    message.eXPToNextLevel = object.eXPToNextLevel ?? 0;
    message.coinUpgradeFee = object.coinUpgradeFee ?? undefined;
    message.requiredItemsToUpgrade = object.requiredItemsToUpgrade?.map((e) => ItemRef.fromPartial(e)) || [];
    message.nextUnlockSkillSlotConfig =
      (object.nextUnlockSkillSlotConfig !== undefined && object.nextUnlockSkillSlotConfig !== null)
        ? SkillSlotConfig.fromPartial(object.nextUnlockSkillSlotConfig)
        : undefined;
    message.characterSkills = object.characterSkills?.map((e) => CharacterSkill.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSkillSlotConfig(): SkillSlotConfig {
  return { slotNumber: 0, levelRequired: 0, requiredItems: [], coinUnlockFee: 0 };
}

export const SkillSlotConfig: MessageFns<SkillSlotConfig> = {
  encode(message: SkillSlotConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slotNumber !== 0) {
      writer.uint32(8).uint32(message.slotNumber);
    }
    if (message.levelRequired !== 0) {
      writer.uint32(16).uint32(message.levelRequired);
    }
    for (const v of message.requiredItems) {
      ItemRef.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.coinUnlockFee !== 0) {
      writer.uint32(32).uint32(message.coinUnlockFee);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillSlotConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillSlotConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.slotNumber = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.levelRequired = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requiredItems.push(ItemRef.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.coinUnlockFee = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillSlotConfig {
    return {
      slotNumber: isSet(object.slotNumber) ? globalThis.Number(object.slotNumber) : 0,
      levelRequired: isSet(object.levelRequired) ? globalThis.Number(object.levelRequired) : 0,
      requiredItems: globalThis.Array.isArray(object?.requiredItems)
        ? object.requiredItems.map((e: any) => ItemRef.fromJSON(e))
        : [],
      coinUnlockFee: isSet(object.coinUnlockFee) ? globalThis.Number(object.coinUnlockFee) : 0,
    };
  },

  toJSON(message: SkillSlotConfig): unknown {
    const obj: any = {};
    if (message.slotNumber !== 0) {
      obj.slotNumber = Math.round(message.slotNumber);
    }
    if (message.levelRequired !== 0) {
      obj.levelRequired = Math.round(message.levelRequired);
    }
    if (message.requiredItems?.length) {
      obj.requiredItems = message.requiredItems.map((e) => ItemRef.toJSON(e));
    }
    if (message.coinUnlockFee !== 0) {
      obj.coinUnlockFee = Math.round(message.coinUnlockFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillSlotConfig>, I>>(base?: I): SkillSlotConfig {
    return SkillSlotConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillSlotConfig>, I>>(object: I): SkillSlotConfig {
    const message = createBaseSkillSlotConfig();
    message.slotNumber = object.slotNumber ?? 0;
    message.levelRequired = object.levelRequired ?? 0;
    message.requiredItems = object.requiredItems?.map((e) => ItemRef.fromPartial(e)) || [];
    message.coinUnlockFee = object.coinUnlockFee ?? 0;
    return message;
  },
};

function createBaseCharacterSkill(): CharacterSkill {
  return { slotNumber: 0, isUnlocked: false, skill: undefined };
}

export const CharacterSkill: MessageFns<CharacterSkill> = {
  encode(message: CharacterSkill, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slotNumber !== 0) {
      writer.uint32(8).uint32(message.slotNumber);
    }
    if (message.isUnlocked !== false) {
      writer.uint32(16).bool(message.isUnlocked);
    }
    if (message.skill !== undefined) {
      UserSkill.encode(message.skill, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterSkill {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterSkill();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.slotNumber = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isUnlocked = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.skill = UserSkill.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterSkill {
    return {
      slotNumber: isSet(object.slotNumber) ? globalThis.Number(object.slotNumber) : 0,
      isUnlocked: isSet(object.isUnlocked) ? globalThis.Boolean(object.isUnlocked) : false,
      skill: isSet(object.skill) ? UserSkill.fromJSON(object.skill) : undefined,
    };
  },

  toJSON(message: CharacterSkill): unknown {
    const obj: any = {};
    if (message.slotNumber !== 0) {
      obj.slotNumber = Math.round(message.slotNumber);
    }
    if (message.isUnlocked !== false) {
      obj.isUnlocked = message.isUnlocked;
    }
    if (message.skill !== undefined) {
      obj.skill = UserSkill.toJSON(message.skill);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterSkill>, I>>(base?: I): CharacterSkill {
    return CharacterSkill.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterSkill>, I>>(object: I): CharacterSkill {
    const message = createBaseCharacterSkill();
    message.slotNumber = object.slotNumber ?? 0;
    message.isUnlocked = object.isUnlocked ?? false;
    message.skill = (object.skill !== undefined && object.skill !== null)
      ? UserSkill.fromPartial(object.skill)
      : undefined;
    return message;
  },
};

function createBaseUserSkill(): UserSkill {
  return {
    id: "",
    code: "",
    name: "",
    elementType: 0,
    level: 0,
    primaryAttributeType: "",
    primaryAttributeRate: "",
    primaryAttributeValue: 0,
    secondaryAttributeType: undefined,
    secondaryAttributeRate: undefined,
    secondaryAttributeValue: undefined,
    description: "",
    acquiredAt: "",
  };
}

export const UserSkill: MessageFns<UserSkill> = {
  encode(message: UserSkill, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.elementType !== 0) {
      writer.uint32(32).int32(message.elementType);
    }
    if (message.level !== 0) {
      writer.uint32(40).uint32(message.level);
    }
    if (message.primaryAttributeType !== "") {
      writer.uint32(50).string(message.primaryAttributeType);
    }
    if (message.primaryAttributeRate !== "") {
      writer.uint32(58).string(message.primaryAttributeRate);
    }
    if (message.primaryAttributeValue !== 0) {
      writer.uint32(64).uint32(message.primaryAttributeValue);
    }
    if (message.secondaryAttributeType !== undefined) {
      writer.uint32(74).string(message.secondaryAttributeType);
    }
    if (message.secondaryAttributeRate !== undefined) {
      writer.uint32(82).string(message.secondaryAttributeRate);
    }
    if (message.secondaryAttributeValue !== undefined) {
      writer.uint32(88).uint32(message.secondaryAttributeValue);
    }
    if (message.description !== "") {
      writer.uint32(98).string(message.description);
    }
    if (message.acquiredAt !== "") {
      writer.uint32(106).string(message.acquiredAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSkill {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSkill();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.elementType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.level = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.primaryAttributeType = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.primaryAttributeRate = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.primaryAttributeValue = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.secondaryAttributeType = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.secondaryAttributeRate = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.secondaryAttributeValue = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.acquiredAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSkill {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      elementType: isSet(object.elementType) ? elementTypeFromJSON(object.elementType) : 0,
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      primaryAttributeType: isSet(object.primaryAttributeType) ? globalThis.String(object.primaryAttributeType) : "",
      primaryAttributeRate: isSet(object.primaryAttributeRate) ? globalThis.String(object.primaryAttributeRate) : "",
      primaryAttributeValue: isSet(object.primaryAttributeValue) ? globalThis.Number(object.primaryAttributeValue) : 0,
      secondaryAttributeType: isSet(object.secondaryAttributeType)
        ? globalThis.String(object.secondaryAttributeType)
        : undefined,
      secondaryAttributeRate: isSet(object.secondaryAttributeRate)
        ? globalThis.String(object.secondaryAttributeRate)
        : undefined,
      secondaryAttributeValue: isSet(object.secondaryAttributeValue)
        ? globalThis.Number(object.secondaryAttributeValue)
        : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      acquiredAt: isSet(object.acquiredAt) ? globalThis.String(object.acquiredAt) : "",
    };
  },

  toJSON(message: UserSkill): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.elementType !== 0) {
      obj.elementType = elementTypeToJSON(message.elementType);
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.primaryAttributeType !== "") {
      obj.primaryAttributeType = message.primaryAttributeType;
    }
    if (message.primaryAttributeRate !== "") {
      obj.primaryAttributeRate = message.primaryAttributeRate;
    }
    if (message.primaryAttributeValue !== 0) {
      obj.primaryAttributeValue = Math.round(message.primaryAttributeValue);
    }
    if (message.secondaryAttributeType !== undefined) {
      obj.secondaryAttributeType = message.secondaryAttributeType;
    }
    if (message.secondaryAttributeRate !== undefined) {
      obj.secondaryAttributeRate = message.secondaryAttributeRate;
    }
    if (message.secondaryAttributeValue !== undefined) {
      obj.secondaryAttributeValue = Math.round(message.secondaryAttributeValue);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.acquiredAt !== "") {
      obj.acquiredAt = message.acquiredAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserSkill>, I>>(base?: I): UserSkill {
    return UserSkill.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserSkill>, I>>(object: I): UserSkill {
    const message = createBaseUserSkill();
    message.id = object.id ?? "";
    message.code = object.code ?? "";
    message.name = object.name ?? "";
    message.elementType = object.elementType ?? 0;
    message.level = object.level ?? 0;
    message.primaryAttributeType = object.primaryAttributeType ?? "";
    message.primaryAttributeRate = object.primaryAttributeRate ?? "";
    message.primaryAttributeValue = object.primaryAttributeValue ?? 0;
    message.secondaryAttributeType = object.secondaryAttributeType ?? undefined;
    message.secondaryAttributeRate = object.secondaryAttributeRate ?? undefined;
    message.secondaryAttributeValue = object.secondaryAttributeValue ?? undefined;
    message.description = object.description ?? "";
    message.acquiredAt = object.acquiredAt ?? "";
    return message;
  },
};

function createBaseListCharactersRequest(): ListCharactersRequest {
  return { userId: "", page: undefined, sort: [], filters: [], search: undefined };
}

export const ListCharactersRequest: MessageFns<ListCharactersRequest> = {
  encode(message: ListCharactersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.page !== undefined) {
      PageRequest.encode(message.page, writer.uint32(18).fork()).join();
    }
    for (const v of message.sort) {
      SortOption.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.filters) {
      FilterOption.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.search !== undefined) {
      SearchOption.encode(message.search, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCharactersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCharactersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.page = PageRequest.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sort.push(SortOption.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filters.push(FilterOption.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.search = SearchOption.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCharactersRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      page: isSet(object.page) ? PageRequest.fromJSON(object.page) : undefined,
      sort: globalThis.Array.isArray(object?.sort) ? object.sort.map((e: any) => SortOption.fromJSON(e)) : [],
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => FilterOption.fromJSON(e))
        : [],
      search: isSet(object.search) ? SearchOption.fromJSON(object.search) : undefined,
    };
  },

  toJSON(message: ListCharactersRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.page !== undefined) {
      obj.page = PageRequest.toJSON(message.page);
    }
    if (message.sort?.length) {
      obj.sort = message.sort.map((e) => SortOption.toJSON(e));
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => FilterOption.toJSON(e));
    }
    if (message.search !== undefined) {
      obj.search = SearchOption.toJSON(message.search);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCharactersRequest>, I>>(base?: I): ListCharactersRequest {
    return ListCharactersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCharactersRequest>, I>>(object: I): ListCharactersRequest {
    const message = createBaseListCharactersRequest();
    message.userId = object.userId ?? "";
    message.page = (object.page !== undefined && object.page !== null)
      ? PageRequest.fromPartial(object.page)
      : undefined;
    message.sort = object.sort?.map((e) => SortOption.fromPartial(e)) || [];
    message.filters = object.filters?.map((e) => FilterOption.fromPartial(e)) || [];
    message.search = (object.search !== undefined && object.search !== null)
      ? SearchOption.fromPartial(object.search)
      : undefined;
    return message;
  },
};

function createBaseListCharactersResponse(): ListCharactersResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const ListCharactersResponse: MessageFns<ListCharactersResponse> = {
  encode(message: ListCharactersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      ListCharactersData.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCharactersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCharactersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = ListCharactersData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCharactersResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? ListCharactersData.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ListCharactersResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = ListCharactersData.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCharactersResponse>, I>>(base?: I): ListCharactersResponse {
    return ListCharactersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCharactersResponse>, I>>(object: I): ListCharactersResponse {
    const message = createBaseListCharactersResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? ListCharactersData.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseListCharactersData(): ListCharactersData {
  return { characters: [], pagination: undefined };
}

export const ListCharactersData: MessageFns<ListCharactersData> = {
  encode(message: ListCharactersData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.characters) {
      Character.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCharactersData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCharactersData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characters.push(Character.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCharactersData {
    return {
      characters: globalThis.Array.isArray(object?.characters)
        ? object.characters.map((e: any) => Character.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListCharactersData): unknown {
    const obj: any = {};
    if (message.characters?.length) {
      obj.characters = message.characters.map((e) => Character.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCharactersData>, I>>(base?: I): ListCharactersData {
    return ListCharactersData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCharactersData>, I>>(object: I): ListCharactersData {
    const message = createBaseListCharactersData();
    message.characters = object.characters?.map((e) => Character.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetCharacterRequest(): GetCharacterRequest {
  return { characterId: "" };
}

export const GetCharacterRequest: MessageFns<GetCharacterRequest> = {
  encode(message: GetCharacterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.characterId !== "") {
      writer.uint32(10).string(message.characterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCharacterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCharacterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCharacterRequest {
    return { characterId: isSet(object.characterId) ? globalThis.String(object.characterId) : "" };
  },

  toJSON(message: GetCharacterRequest): unknown {
    const obj: any = {};
    if (message.characterId !== "") {
      obj.characterId = message.characterId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCharacterRequest>, I>>(base?: I): GetCharacterRequest {
    return GetCharacterRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCharacterRequest>, I>>(object: I): GetCharacterRequest {
    const message = createBaseGetCharacterRequest();
    message.characterId = object.characterId ?? "";
    return message;
  },
};

function createBaseGetCharacterResponse(): GetCharacterResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const GetCharacterResponse: MessageFns<GetCharacterResponse> = {
  encode(message: GetCharacterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      Character.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCharacterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCharacterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Character.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCharacterResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? Character.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: GetCharacterResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = Character.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCharacterResponse>, I>>(base?: I): GetCharacterResponse {
    return GetCharacterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCharacterResponse>, I>>(object: I): GetCharacterResponse {
    const message = createBaseGetCharacterResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? Character.fromPartial(object.data) : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseUpdateCharacterRequest(): UpdateCharacterRequest {
  return { characterId: "", characterName: undefined, updateMask: undefined };
}

export const UpdateCharacterRequest: MessageFns<UpdateCharacterRequest> = {
  encode(message: UpdateCharacterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.characterId !== "") {
      writer.uint32(10).string(message.characterId);
    }
    if (message.characterName !== undefined) {
      writer.uint32(18).string(message.characterName);
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCharacterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCharacterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characterId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.characterName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCharacterRequest {
    return {
      characterId: isSet(object.characterId) ? globalThis.String(object.characterId) : "",
      characterName: isSet(object.characterName) ? globalThis.String(object.characterName) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateCharacterRequest): unknown {
    const obj: any = {};
    if (message.characterId !== "") {
      obj.characterId = message.characterId;
    }
    if (message.characterName !== undefined) {
      obj.characterName = message.characterName;
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCharacterRequest>, I>>(base?: I): UpdateCharacterRequest {
    return UpdateCharacterRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCharacterRequest>, I>>(object: I): UpdateCharacterRequest {
    const message = createBaseUpdateCharacterRequest();
    message.characterId = object.characterId ?? "";
    message.characterName = object.characterName ?? undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseUpdateCharacterResponse(): UpdateCharacterResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const UpdateCharacterResponse: MessageFns<UpdateCharacterResponse> = {
  encode(message: UpdateCharacterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      Character.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCharacterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCharacterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Character.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCharacterResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? Character.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: UpdateCharacterResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = Character.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCharacterResponse>, I>>(base?: I): UpdateCharacterResponse {
    return UpdateCharacterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCharacterResponse>, I>>(object: I): UpdateCharacterResponse {
    const message = createBaseUpdateCharacterResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? Character.fromPartial(object.data) : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseEquipItemRequest(): EquipItemRequest {
  return { characterId: "", userSkillId: "", slotNumber: 0 };
}

export const EquipItemRequest: MessageFns<EquipItemRequest> = {
  encode(message: EquipItemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.characterId !== "") {
      writer.uint32(10).string(message.characterId);
    }
    if (message.userSkillId !== "") {
      writer.uint32(18).string(message.userSkillId);
    }
    if (message.slotNumber !== 0) {
      writer.uint32(24).uint32(message.slotNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EquipItemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEquipItemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characterId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userSkillId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.slotNumber = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EquipItemRequest {
    return {
      characterId: isSet(object.characterId) ? globalThis.String(object.characterId) : "",
      userSkillId: isSet(object.userSkillId) ? globalThis.String(object.userSkillId) : "",
      slotNumber: isSet(object.slotNumber) ? globalThis.Number(object.slotNumber) : 0,
    };
  },

  toJSON(message: EquipItemRequest): unknown {
    const obj: any = {};
    if (message.characterId !== "") {
      obj.characterId = message.characterId;
    }
    if (message.userSkillId !== "") {
      obj.userSkillId = message.userSkillId;
    }
    if (message.slotNumber !== 0) {
      obj.slotNumber = Math.round(message.slotNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EquipItemRequest>, I>>(base?: I): EquipItemRequest {
    return EquipItemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EquipItemRequest>, I>>(object: I): EquipItemRequest {
    const message = createBaseEquipItemRequest();
    message.characterId = object.characterId ?? "";
    message.userSkillId = object.userSkillId ?? "";
    message.slotNumber = object.slotNumber ?? 0;
    return message;
  },
};

function createBaseEquipItemResponse(): EquipItemResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const EquipItemResponse: MessageFns<EquipItemResponse> = {
  encode(message: EquipItemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      Character.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EquipItemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEquipItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Character.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EquipItemResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? Character.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: EquipItemResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = Character.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EquipItemResponse>, I>>(base?: I): EquipItemResponse {
    return EquipItemResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EquipItemResponse>, I>>(object: I): EquipItemResponse {
    const message = createBaseEquipItemResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? Character.fromPartial(object.data) : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseUnequipItemRequest(): UnequipItemRequest {
  return { characterId: "", slotNumber: 0 };
}

export const UnequipItemRequest: MessageFns<UnequipItemRequest> = {
  encode(message: UnequipItemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.characterId !== "") {
      writer.uint32(10).string(message.characterId);
    }
    if (message.slotNumber !== 0) {
      writer.uint32(16).uint32(message.slotNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnequipItemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnequipItemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characterId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.slotNumber = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnequipItemRequest {
    return {
      characterId: isSet(object.characterId) ? globalThis.String(object.characterId) : "",
      slotNumber: isSet(object.slotNumber) ? globalThis.Number(object.slotNumber) : 0,
    };
  },

  toJSON(message: UnequipItemRequest): unknown {
    const obj: any = {};
    if (message.characterId !== "") {
      obj.characterId = message.characterId;
    }
    if (message.slotNumber !== 0) {
      obj.slotNumber = Math.round(message.slotNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnequipItemRequest>, I>>(base?: I): UnequipItemRequest {
    return UnequipItemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnequipItemRequest>, I>>(object: I): UnequipItemRequest {
    const message = createBaseUnequipItemRequest();
    message.characterId = object.characterId ?? "";
    message.slotNumber = object.slotNumber ?? 0;
    return message;
  },
};

function createBaseUnequipItemResponse(): UnequipItemResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const UnequipItemResponse: MessageFns<UnequipItemResponse> = {
  encode(message: UnequipItemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      Character.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnequipItemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnequipItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Character.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnequipItemResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? Character.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: UnequipItemResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = Character.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnequipItemResponse>, I>>(base?: I): UnequipItemResponse {
    return UnequipItemResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnequipItemResponse>, I>>(object: I): UnequipItemResponse {
    const message = createBaseUnequipItemResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? Character.fromPartial(object.data) : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseFeedCharacterRequest(): FeedCharacterRequest {
  return { characterId: "" };
}

export const FeedCharacterRequest: MessageFns<FeedCharacterRequest> = {
  encode(message: FeedCharacterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.characterId !== "") {
      writer.uint32(10).string(message.characterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeedCharacterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeedCharacterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeedCharacterRequest {
    return { characterId: isSet(object.characterId) ? globalThis.String(object.characterId) : "" };
  },

  toJSON(message: FeedCharacterRequest): unknown {
    const obj: any = {};
    if (message.characterId !== "") {
      obj.characterId = message.characterId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeedCharacterRequest>, I>>(base?: I): FeedCharacterRequest {
    return FeedCharacterRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeedCharacterRequest>, I>>(object: I): FeedCharacterRequest {
    const message = createBaseFeedCharacterRequest();
    message.characterId = object.characterId ?? "";
    return message;
  },
};

function createBaseFeedCharacterResponse(): FeedCharacterResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const FeedCharacterResponse: MessageFns<FeedCharacterResponse> = {
  encode(message: FeedCharacterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      Character.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeedCharacterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeedCharacterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Character.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeedCharacterResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? Character.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: FeedCharacterResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = Character.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeedCharacterResponse>, I>>(base?: I): FeedCharacterResponse {
    return FeedCharacterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeedCharacterResponse>, I>>(object: I): FeedCharacterResponse {
    const message = createBaseFeedCharacterResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? Character.fromPartial(object.data) : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseRequestUnlockSkillSlot(): RequestUnlockSkillSlot {
  return { characterId: "" };
}

export const RequestUnlockSkillSlot: MessageFns<RequestUnlockSkillSlot> = {
  encode(message: RequestUnlockSkillSlot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.characterId !== "") {
      writer.uint32(10).string(message.characterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestUnlockSkillSlot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestUnlockSkillSlot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestUnlockSkillSlot {
    return { characterId: isSet(object.characterId) ? globalThis.String(object.characterId) : "" };
  },

  toJSON(message: RequestUnlockSkillSlot): unknown {
    const obj: any = {};
    if (message.characterId !== "") {
      obj.characterId = message.characterId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestUnlockSkillSlot>, I>>(base?: I): RequestUnlockSkillSlot {
    return RequestUnlockSkillSlot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestUnlockSkillSlot>, I>>(object: I): RequestUnlockSkillSlot {
    const message = createBaseRequestUnlockSkillSlot();
    message.characterId = object.characterId ?? "";
    return message;
  },
};

function createBaseResponseUnlockSkillSlot(): ResponseUnlockSkillSlot {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const ResponseUnlockSkillSlot: MessageFns<ResponseUnlockSkillSlot> = {
  encode(message: ResponseUnlockSkillSlot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      Character.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseUnlockSkillSlot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseUnlockSkillSlot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Character.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseUnlockSkillSlot {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? Character.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ResponseUnlockSkillSlot): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = Character.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseUnlockSkillSlot>, I>>(base?: I): ResponseUnlockSkillSlot {
    return ResponseUnlockSkillSlot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseUnlockSkillSlot>, I>>(object: I): ResponseUnlockSkillSlot {
    const message = createBaseResponseUnlockSkillSlot();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? Character.fromPartial(object.data) : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseSetDefaultCharacterRequest(): SetDefaultCharacterRequest {
  return { characterId: "" };
}

export const SetDefaultCharacterRequest: MessageFns<SetDefaultCharacterRequest> = {
  encode(message: SetDefaultCharacterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.characterId !== "") {
      writer.uint32(10).string(message.characterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetDefaultCharacterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetDefaultCharacterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetDefaultCharacterRequest {
    return { characterId: isSet(object.characterId) ? globalThis.String(object.characterId) : "" };
  },

  toJSON(message: SetDefaultCharacterRequest): unknown {
    const obj: any = {};
    if (message.characterId !== "") {
      obj.characterId = message.characterId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetDefaultCharacterRequest>, I>>(base?: I): SetDefaultCharacterRequest {
    return SetDefaultCharacterRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetDefaultCharacterRequest>, I>>(object: I): SetDefaultCharacterRequest {
    const message = createBaseSetDefaultCharacterRequest();
    message.characterId = object.characterId ?? "";
    return message;
  },
};

function createBaseSetDefaultCharacterResponse(): SetDefaultCharacterResponse {
  return { status: undefined, error: undefined, metadata: undefined };
}

export const SetDefaultCharacterResponse: MessageFns<SetDefaultCharacterResponse> = {
  encode(message: SetDefaultCharacterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetDefaultCharacterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetDefaultCharacterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetDefaultCharacterResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: SetDefaultCharacterResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetDefaultCharacterResponse>, I>>(base?: I): SetDefaultCharacterResponse {
    return SetDefaultCharacterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetDefaultCharacterResponse>, I>>(object: I): SetDefaultCharacterResponse {
    const message = createBaseSetDefaultCharacterResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseLevelUpCharacterRequest(): LevelUpCharacterRequest {
  return { characterId: "" };
}

export const LevelUpCharacterRequest: MessageFns<LevelUpCharacterRequest> = {
  encode(message: LevelUpCharacterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.characterId !== "") {
      writer.uint32(10).string(message.characterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LevelUpCharacterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLevelUpCharacterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LevelUpCharacterRequest {
    return { characterId: isSet(object.characterId) ? globalThis.String(object.characterId) : "" };
  },

  toJSON(message: LevelUpCharacterRequest): unknown {
    const obj: any = {};
    if (message.characterId !== "") {
      obj.characterId = message.characterId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LevelUpCharacterRequest>, I>>(base?: I): LevelUpCharacterRequest {
    return LevelUpCharacterRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LevelUpCharacterRequest>, I>>(object: I): LevelUpCharacterRequest {
    const message = createBaseLevelUpCharacterRequest();
    message.characterId = object.characterId ?? "";
    return message;
  },
};

function createBaseLevelUpCharacterResponse(): LevelUpCharacterResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const LevelUpCharacterResponse: MessageFns<LevelUpCharacterResponse> = {
  encode(message: LevelUpCharacterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      Character.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LevelUpCharacterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLevelUpCharacterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Character.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LevelUpCharacterResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? Character.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: LevelUpCharacterResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = Character.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LevelUpCharacterResponse>, I>>(base?: I): LevelUpCharacterResponse {
    return LevelUpCharacterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LevelUpCharacterResponse>, I>>(object: I): LevelUpCharacterResponse {
    const message = createBaseLevelUpCharacterResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? Character.fromPartial(object.data) : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseUpgradeCharacterStatsRequest(): UpgradeCharacterStatsRequest {
  return { characterId: "", userId: "", statsType: 0 };
}

export const UpgradeCharacterStatsRequest: MessageFns<UpgradeCharacterStatsRequest> = {
  encode(message: UpgradeCharacterStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.characterId !== "") {
      writer.uint32(10).string(message.characterId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.statsType !== 0) {
      writer.uint32(24).int32(message.statsType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpgradeCharacterStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpgradeCharacterStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characterId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.statsType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpgradeCharacterStatsRequest {
    return {
      characterId: isSet(object.characterId) ? globalThis.String(object.characterId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      statsType: isSet(object.statsType) ? characterStatsTypeFromJSON(object.statsType) : 0,
    };
  },

  toJSON(message: UpgradeCharacterStatsRequest): unknown {
    const obj: any = {};
    if (message.characterId !== "") {
      obj.characterId = message.characterId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.statsType !== 0) {
      obj.statsType = characterStatsTypeToJSON(message.statsType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpgradeCharacterStatsRequest>, I>>(base?: I): UpgradeCharacterStatsRequest {
    return UpgradeCharacterStatsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpgradeCharacterStatsRequest>, I>>(object: I): UpgradeCharacterStatsRequest {
    const message = createBaseUpgradeCharacterStatsRequest();
    message.characterId = object.characterId ?? "";
    message.userId = object.userId ?? "";
    message.statsType = object.statsType ?? 0;
    return message;
  },
};

function createBaseUpgradeCharacterStatsResponse(): UpgradeCharacterStatsResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const UpgradeCharacterStatsResponse: MessageFns<UpgradeCharacterStatsResponse> = {
  encode(message: UpgradeCharacterStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      UpgradeCharacterStatsData.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpgradeCharacterStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpgradeCharacterStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = UpgradeCharacterStatsData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpgradeCharacterStatsResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? UpgradeCharacterStatsData.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: UpgradeCharacterStatsResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = UpgradeCharacterStatsData.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpgradeCharacterStatsResponse>, I>>(base?: I): UpgradeCharacterStatsResponse {
    return UpgradeCharacterStatsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpgradeCharacterStatsResponse>, I>>(
    object: I,
  ): UpgradeCharacterStatsResponse {
    const message = createBaseUpgradeCharacterStatsResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? UpgradeCharacterStatsData.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseUpgradeCharacterStatsData(): UpgradeCharacterStatsData {
  return { character: undefined, isSuccessful: false };
}

export const UpgradeCharacterStatsData: MessageFns<UpgradeCharacterStatsData> = {
  encode(message: UpgradeCharacterStatsData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.character !== undefined) {
      Character.encode(message.character, writer.uint32(10).fork()).join();
    }
    if (message.isSuccessful !== false) {
      writer.uint32(16).bool(message.isSuccessful);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpgradeCharacterStatsData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpgradeCharacterStatsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.character = Character.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSuccessful = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpgradeCharacterStatsData {
    return {
      character: isSet(object.character) ? Character.fromJSON(object.character) : undefined,
      isSuccessful: isSet(object.isSuccessful) ? globalThis.Boolean(object.isSuccessful) : false,
    };
  },

  toJSON(message: UpgradeCharacterStatsData): unknown {
    const obj: any = {};
    if (message.character !== undefined) {
      obj.character = Character.toJSON(message.character);
    }
    if (message.isSuccessful !== false) {
      obj.isSuccessful = message.isSuccessful;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpgradeCharacterStatsData>, I>>(base?: I): UpgradeCharacterStatsData {
    return UpgradeCharacterStatsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpgradeCharacterStatsData>, I>>(object: I): UpgradeCharacterStatsData {
    const message = createBaseUpgradeCharacterStatsData();
    message.character = (object.character !== undefined && object.character !== null)
      ? Character.fromPartial(object.character)
      : undefined;
    message.isSuccessful = object.isSuccessful ?? false;
    return message;
  },
};

function createBaseItem(): Item {
  return {
    id: "",
    itemCode: "",
    itemName: "",
    itemType: 0,
    rarity: 0,
    category: undefined,
    stats: undefined,
    requirements: undefined,
    effects: undefined,
    basePrice: 0,
    sellPrice: 0,
    maxStack: 0,
    isTradeable: false,
    isConsumable: false,
    isActive: false,
    description: undefined,
    iconUrl: undefined,
    metadata: undefined,
    isWishlisted: undefined,
  };
}

export const Item: MessageFns<Item> = {
  encode(message: Item, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.itemCode !== "") {
      writer.uint32(18).string(message.itemCode);
    }
    if (message.itemName !== "") {
      writer.uint32(26).string(message.itemName);
    }
    if (message.itemType !== 0) {
      writer.uint32(32).int32(message.itemType);
    }
    if (message.rarity !== 0) {
      writer.uint32(40).int32(message.rarity);
    }
    if (message.category !== undefined) {
      writer.uint32(50).string(message.category);
    }
    if (message.stats !== undefined) {
      Struct.encode(Struct.wrap(message.stats), writer.uint32(58).fork()).join();
    }
    if (message.requirements !== undefined) {
      Struct.encode(Struct.wrap(message.requirements), writer.uint32(66).fork()).join();
    }
    if (message.effects !== undefined) {
      Struct.encode(Struct.wrap(message.effects), writer.uint32(74).fork()).join();
    }
    if (message.basePrice !== 0) {
      writer.uint32(80).uint64(message.basePrice);
    }
    if (message.sellPrice !== 0) {
      writer.uint32(88).uint64(message.sellPrice);
    }
    if (message.maxStack !== 0) {
      writer.uint32(96).int32(message.maxStack);
    }
    if (message.isTradeable !== false) {
      writer.uint32(104).bool(message.isTradeable);
    }
    if (message.isConsumable !== false) {
      writer.uint32(112).bool(message.isConsumable);
    }
    if (message.isActive !== false) {
      writer.uint32(120).bool(message.isActive);
    }
    if (message.description !== undefined) {
      writer.uint32(130).string(message.description);
    }
    if (message.iconUrl !== undefined) {
      writer.uint32(138).string(message.iconUrl);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(146).fork()).join();
    }
    if (message.isWishlisted !== undefined) {
      writer.uint32(152).bool(message.isWishlisted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Item {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.itemCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.itemName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.itemType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.rarity = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.stats = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.requirements = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.effects = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.basePrice = longToNumber(reader.uint64());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.sellPrice = longToNumber(reader.uint64());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.maxStack = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.isTradeable = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.isConsumable = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.iconUrl = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.isWishlisted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Item {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      itemCode: isSet(object.itemCode) ? globalThis.String(object.itemCode) : "",
      itemName: isSet(object.itemName) ? globalThis.String(object.itemName) : "",
      itemType: isSet(object.itemType) ? itemTypeFromJSON(object.itemType) : 0,
      rarity: isSet(object.rarity) ? itemRarityFromJSON(object.rarity) : 0,
      category: isSet(object.category) ? globalThis.String(object.category) : undefined,
      stats: isObject(object.stats) ? object.stats : undefined,
      requirements: isObject(object.requirements) ? object.requirements : undefined,
      effects: isObject(object.effects) ? object.effects : undefined,
      basePrice: isSet(object.basePrice) ? globalThis.Number(object.basePrice) : 0,
      sellPrice: isSet(object.sellPrice) ? globalThis.Number(object.sellPrice) : 0,
      maxStack: isSet(object.maxStack) ? globalThis.Number(object.maxStack) : 0,
      isTradeable: isSet(object.isTradeable) ? globalThis.Boolean(object.isTradeable) : false,
      isConsumable: isSet(object.isConsumable) ? globalThis.Boolean(object.isConsumable) : false,
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      iconUrl: isSet(object.iconUrl) ? globalThis.String(object.iconUrl) : undefined,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      isWishlisted: isSet(object.isWishlisted) ? globalThis.Boolean(object.isWishlisted) : undefined,
    };
  },

  toJSON(message: Item): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.itemCode !== "") {
      obj.itemCode = message.itemCode;
    }
    if (message.itemName !== "") {
      obj.itemName = message.itemName;
    }
    if (message.itemType !== 0) {
      obj.itemType = itemTypeToJSON(message.itemType);
    }
    if (message.rarity !== 0) {
      obj.rarity = itemRarityToJSON(message.rarity);
    }
    if (message.category !== undefined) {
      obj.category = message.category;
    }
    if (message.stats !== undefined) {
      obj.stats = message.stats;
    }
    if (message.requirements !== undefined) {
      obj.requirements = message.requirements;
    }
    if (message.effects !== undefined) {
      obj.effects = message.effects;
    }
    if (message.basePrice !== 0) {
      obj.basePrice = Math.round(message.basePrice);
    }
    if (message.sellPrice !== 0) {
      obj.sellPrice = Math.round(message.sellPrice);
    }
    if (message.maxStack !== 0) {
      obj.maxStack = Math.round(message.maxStack);
    }
    if (message.isTradeable !== false) {
      obj.isTradeable = message.isTradeable;
    }
    if (message.isConsumable !== false) {
      obj.isConsumable = message.isConsumable;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.iconUrl !== undefined) {
      obj.iconUrl = message.iconUrl;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.isWishlisted !== undefined) {
      obj.isWishlisted = message.isWishlisted;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Item>, I>>(base?: I): Item {
    return Item.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Item>, I>>(object: I): Item {
    const message = createBaseItem();
    message.id = object.id ?? "";
    message.itemCode = object.itemCode ?? "";
    message.itemName = object.itemName ?? "";
    message.itemType = object.itemType ?? 0;
    message.rarity = object.rarity ?? 0;
    message.category = object.category ?? undefined;
    message.stats = object.stats ?? undefined;
    message.requirements = object.requirements ?? undefined;
    message.effects = object.effects ?? undefined;
    message.basePrice = object.basePrice ?? 0;
    message.sellPrice = object.sellPrice ?? 0;
    message.maxStack = object.maxStack ?? 0;
    message.isTradeable = object.isTradeable ?? false;
    message.isConsumable = object.isConsumable ?? false;
    message.isActive = object.isActive ?? false;
    message.description = object.description ?? undefined;
    message.iconUrl = object.iconUrl ?? undefined;
    message.metadata = object.metadata ?? undefined;
    message.isWishlisted = object.isWishlisted ?? undefined;
    return message;
  },
};

function createBaseMarketTradeItem(): MarketTradeItem {
  return {
    id: "",
    item: undefined,
    seller: undefined,
    quantity: 0,
    pricePerUnit: 0,
    totalPrice: 0,
    currencyType: 0,
    status: 0,
    createdAt: "",
  };
}

export const MarketTradeItem: MessageFns<MarketTradeItem> = {
  encode(message: MarketTradeItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.item !== undefined) {
      Item.encode(message.item, writer.uint32(18).fork()).join();
    }
    if (message.seller !== undefined) {
      UserRef.encode(message.seller, writer.uint32(26).fork()).join();
    }
    if (message.quantity !== 0) {
      writer.uint32(32).uint32(message.quantity);
    }
    if (message.pricePerUnit !== 0) {
      writer.uint32(40).uint64(message.pricePerUnit);
    }
    if (message.totalPrice !== 0) {
      writer.uint32(48).uint64(message.totalPrice);
    }
    if (message.currencyType !== 0) {
      writer.uint32(56).int32(message.currencyType);
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    if (message.createdAt !== "") {
      writer.uint32(74).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketTradeItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketTradeItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.item = Item.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.seller = UserRef.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.quantity = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pricePerUnit = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalPrice = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.currencyType = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketTradeItem {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      item: isSet(object.item) ? Item.fromJSON(object.item) : undefined,
      seller: isSet(object.seller) ? UserRef.fromJSON(object.seller) : undefined,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      pricePerUnit: isSet(object.pricePerUnit) ? globalThis.Number(object.pricePerUnit) : 0,
      totalPrice: isSet(object.totalPrice) ? globalThis.Number(object.totalPrice) : 0,
      currencyType: isSet(object.currencyType) ? currencyTypeFromJSON(object.currencyType) : 0,
      status: isSet(object.status) ? marketTradeItemStatusFromJSON(object.status) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
    };
  },

  toJSON(message: MarketTradeItem): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.item !== undefined) {
      obj.item = Item.toJSON(message.item);
    }
    if (message.seller !== undefined) {
      obj.seller = UserRef.toJSON(message.seller);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.pricePerUnit !== 0) {
      obj.pricePerUnit = Math.round(message.pricePerUnit);
    }
    if (message.totalPrice !== 0) {
      obj.totalPrice = Math.round(message.totalPrice);
    }
    if (message.currencyType !== 0) {
      obj.currencyType = currencyTypeToJSON(message.currencyType);
    }
    if (message.status !== 0) {
      obj.status = marketTradeItemStatusToJSON(message.status);
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketTradeItem>, I>>(base?: I): MarketTradeItem {
    return MarketTradeItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketTradeItem>, I>>(object: I): MarketTradeItem {
    const message = createBaseMarketTradeItem();
    message.id = object.id ?? "";
    message.item = (object.item !== undefined && object.item !== null) ? Item.fromPartial(object.item) : undefined;
    message.seller = (object.seller !== undefined && object.seller !== null)
      ? UserRef.fromPartial(object.seller)
      : undefined;
    message.quantity = object.quantity ?? 0;
    message.pricePerUnit = object.pricePerUnit ?? 0;
    message.totalPrice = object.totalPrice ?? 0;
    message.currencyType = object.currencyType ?? 0;
    message.status = object.status ?? 0;
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseListShopItemsRequest(): ListShopItemsRequest {
  return {
    page: undefined,
    sort: [],
    filters: [],
    search: undefined,
    itemType: undefined,
    rarity: undefined,
    isWishlisted: undefined,
  };
}

export const ListShopItemsRequest: MessageFns<ListShopItemsRequest> = {
  encode(message: ListShopItemsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== undefined) {
      PageRequest.encode(message.page, writer.uint32(10).fork()).join();
    }
    for (const v of message.sort) {
      SortOption.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.filters) {
      FilterOption.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.search !== undefined) {
      SearchOption.encode(message.search, writer.uint32(34).fork()).join();
    }
    if (message.itemType !== undefined) {
      writer.uint32(40).int32(message.itemType);
    }
    if (message.rarity !== undefined) {
      writer.uint32(48).int32(message.rarity);
    }
    if (message.isWishlisted !== undefined) {
      writer.uint32(56).bool(message.isWishlisted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListShopItemsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListShopItemsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.page = PageRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sort.push(SortOption.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filters.push(FilterOption.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.search = SearchOption.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.itemType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rarity = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isWishlisted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListShopItemsRequest {
    return {
      page: isSet(object.page) ? PageRequest.fromJSON(object.page) : undefined,
      sort: globalThis.Array.isArray(object?.sort) ? object.sort.map((e: any) => SortOption.fromJSON(e)) : [],
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => FilterOption.fromJSON(e))
        : [],
      search: isSet(object.search) ? SearchOption.fromJSON(object.search) : undefined,
      itemType: isSet(object.itemType) ? itemTypeFromJSON(object.itemType) : undefined,
      rarity: isSet(object.rarity) ? itemRarityFromJSON(object.rarity) : undefined,
      isWishlisted: isSet(object.isWishlisted) ? globalThis.Boolean(object.isWishlisted) : undefined,
    };
  },

  toJSON(message: ListShopItemsRequest): unknown {
    const obj: any = {};
    if (message.page !== undefined) {
      obj.page = PageRequest.toJSON(message.page);
    }
    if (message.sort?.length) {
      obj.sort = message.sort.map((e) => SortOption.toJSON(e));
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => FilterOption.toJSON(e));
    }
    if (message.search !== undefined) {
      obj.search = SearchOption.toJSON(message.search);
    }
    if (message.itemType !== undefined) {
      obj.itemType = itemTypeToJSON(message.itemType);
    }
    if (message.rarity !== undefined) {
      obj.rarity = itemRarityToJSON(message.rarity);
    }
    if (message.isWishlisted !== undefined) {
      obj.isWishlisted = message.isWishlisted;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListShopItemsRequest>, I>>(base?: I): ListShopItemsRequest {
    return ListShopItemsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListShopItemsRequest>, I>>(object: I): ListShopItemsRequest {
    const message = createBaseListShopItemsRequest();
    message.page = (object.page !== undefined && object.page !== null)
      ? PageRequest.fromPartial(object.page)
      : undefined;
    message.sort = object.sort?.map((e) => SortOption.fromPartial(e)) || [];
    message.filters = object.filters?.map((e) => FilterOption.fromPartial(e)) || [];
    message.search = (object.search !== undefined && object.search !== null)
      ? SearchOption.fromPartial(object.search)
      : undefined;
    message.itemType = object.itemType ?? undefined;
    message.rarity = object.rarity ?? undefined;
    message.isWishlisted = object.isWishlisted ?? undefined;
    return message;
  },
};

function createBaseListShopItemsResponse(): ListShopItemsResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const ListShopItemsResponse: MessageFns<ListShopItemsResponse> = {
  encode(message: ListShopItemsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      ListShopItemsData.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListShopItemsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListShopItemsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = ListShopItemsData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListShopItemsResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? ListShopItemsData.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ListShopItemsResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = ListShopItemsData.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListShopItemsResponse>, I>>(base?: I): ListShopItemsResponse {
    return ListShopItemsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListShopItemsResponse>, I>>(object: I): ListShopItemsResponse {
    const message = createBaseListShopItemsResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? ListShopItemsData.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseListShopItemsData(): ListShopItemsData {
  return { items: [], pagination: undefined };
}

export const ListShopItemsData: MessageFns<ListShopItemsData> = {
  encode(message: ListShopItemsData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      Item.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListShopItemsData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListShopItemsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(Item.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListShopItemsData {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Item.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListShopItemsData): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Item.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListShopItemsData>, I>>(base?: I): ListShopItemsData {
    return ListShopItemsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListShopItemsData>, I>>(object: I): ListShopItemsData {
    const message = createBaseListShopItemsData();
    message.items = object.items?.map((e) => Item.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseBuyShopItemRequest(): BuyShopItemRequest {
  return { itemId: "", quantity: 0 };
}

export const BuyShopItemRequest: MessageFns<BuyShopItemRequest> = {
  encode(message: BuyShopItemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemId !== "") {
      writer.uint32(10).string(message.itemId);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int32(message.quantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuyShopItemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuyShopItemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.itemId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuyShopItemRequest {
    return {
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
    };
  },

  toJSON(message: BuyShopItemRequest): unknown {
    const obj: any = {};
    if (message.itemId !== "") {
      obj.itemId = message.itemId;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuyShopItemRequest>, I>>(base?: I): BuyShopItemRequest {
    return BuyShopItemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuyShopItemRequest>, I>>(object: I): BuyShopItemRequest {
    const message = createBaseBuyShopItemRequest();
    message.itemId = object.itemId ?? "";
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

function createBaseBuyShopItemResponse(): BuyShopItemResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const BuyShopItemResponse: MessageFns<BuyShopItemResponse> = {
  encode(message: BuyShopItemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      UserInventory.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuyShopItemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuyShopItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = UserInventory.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuyShopItemResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? UserInventory.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: BuyShopItemResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = UserInventory.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuyShopItemResponse>, I>>(base?: I): BuyShopItemResponse {
    return BuyShopItemResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuyShopItemResponse>, I>>(object: I): BuyShopItemResponse {
    const message = createBaseBuyShopItemResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? UserInventory.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseAddItemToShopRequest(): AddItemToShopRequest {
  return { item: undefined };
}

export const AddItemToShopRequest: MessageFns<AddItemToShopRequest> = {
  encode(message: AddItemToShopRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.item !== undefined) {
      Item.encode(message.item, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddItemToShopRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddItemToShopRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.item = Item.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddItemToShopRequest {
    return { item: isSet(object.item) ? Item.fromJSON(object.item) : undefined };
  },

  toJSON(message: AddItemToShopRequest): unknown {
    const obj: any = {};
    if (message.item !== undefined) {
      obj.item = Item.toJSON(message.item);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddItemToShopRequest>, I>>(base?: I): AddItemToShopRequest {
    return AddItemToShopRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddItemToShopRequest>, I>>(object: I): AddItemToShopRequest {
    const message = createBaseAddItemToShopRequest();
    message.item = (object.item !== undefined && object.item !== null) ? Item.fromPartial(object.item) : undefined;
    return message;
  },
};

function createBaseAddItemToShopResponse(): AddItemToShopResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const AddItemToShopResponse: MessageFns<AddItemToShopResponse> = {
  encode(message: AddItemToShopResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      Item.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddItemToShopResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddItemToShopResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Item.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddItemToShopResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? Item.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: AddItemToShopResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = Item.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddItemToShopResponse>, I>>(base?: I): AddItemToShopResponse {
    return AddItemToShopResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddItemToShopResponse>, I>>(object: I): AddItemToShopResponse {
    const message = createBaseAddItemToShopResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? Item.fromPartial(object.data) : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseAddToWishlistRequest(): AddToWishlistRequest {
  return { itemId: "" };
}

export const AddToWishlistRequest: MessageFns<AddToWishlistRequest> = {
  encode(message: AddToWishlistRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemId !== "") {
      writer.uint32(10).string(message.itemId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddToWishlistRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddToWishlistRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.itemId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddToWishlistRequest {
    return { itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "" };
  },

  toJSON(message: AddToWishlistRequest): unknown {
    const obj: any = {};
    if (message.itemId !== "") {
      obj.itemId = message.itemId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddToWishlistRequest>, I>>(base?: I): AddToWishlistRequest {
    return AddToWishlistRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddToWishlistRequest>, I>>(object: I): AddToWishlistRequest {
    const message = createBaseAddToWishlistRequest();
    message.itemId = object.itemId ?? "";
    return message;
  },
};

function createBaseAddToWishlistResponse(): AddToWishlistResponse {
  return { status: undefined, error: undefined, metadata: undefined };
}

export const AddToWishlistResponse: MessageFns<AddToWishlistResponse> = {
  encode(message: AddToWishlistResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddToWishlistResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddToWishlistResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddToWishlistResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: AddToWishlistResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddToWishlistResponse>, I>>(base?: I): AddToWishlistResponse {
    return AddToWishlistResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddToWishlistResponse>, I>>(object: I): AddToWishlistResponse {
    const message = createBaseAddToWishlistResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseRemoveFromWishlistRequest(): RemoveFromWishlistRequest {
  return { itemId: "" };
}

export const RemoveFromWishlistRequest: MessageFns<RemoveFromWishlistRequest> = {
  encode(message: RemoveFromWishlistRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemId !== "") {
      writer.uint32(10).string(message.itemId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveFromWishlistRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveFromWishlistRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.itemId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveFromWishlistRequest {
    return { itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "" };
  },

  toJSON(message: RemoveFromWishlistRequest): unknown {
    const obj: any = {};
    if (message.itemId !== "") {
      obj.itemId = message.itemId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveFromWishlistRequest>, I>>(base?: I): RemoveFromWishlistRequest {
    return RemoveFromWishlistRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveFromWishlistRequest>, I>>(object: I): RemoveFromWishlistRequest {
    const message = createBaseRemoveFromWishlistRequest();
    message.itemId = object.itemId ?? "";
    return message;
  },
};

function createBaseRemoveFromWishlistResponse(): RemoveFromWishlistResponse {
  return { status: undefined, error: undefined, metadata: undefined };
}

export const RemoveFromWishlistResponse: MessageFns<RemoveFromWishlistResponse> = {
  encode(message: RemoveFromWishlistResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveFromWishlistResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveFromWishlistResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveFromWishlistResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: RemoveFromWishlistResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveFromWishlistResponse>, I>>(base?: I): RemoveFromWishlistResponse {
    return RemoveFromWishlistResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveFromWishlistResponse>, I>>(object: I): RemoveFromWishlistResponse {
    const message = createBaseRemoveFromWishlistResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseListMarketTradeItemsRequest(): ListMarketTradeItemsRequest {
  return {
    page: undefined,
    sort: [],
    filters: [],
    search: undefined,
    itemType: undefined,
    rarity: undefined,
    isWishlisted: undefined,
    userId: undefined,
  };
}

export const ListMarketTradeItemsRequest: MessageFns<ListMarketTradeItemsRequest> = {
  encode(message: ListMarketTradeItemsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== undefined) {
      PageRequest.encode(message.page, writer.uint32(10).fork()).join();
    }
    for (const v of message.sort) {
      SortOption.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.filters) {
      FilterOption.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.search !== undefined) {
      SearchOption.encode(message.search, writer.uint32(34).fork()).join();
    }
    if (message.itemType !== undefined) {
      writer.uint32(40).int32(message.itemType);
    }
    if (message.rarity !== undefined) {
      writer.uint32(48).int32(message.rarity);
    }
    if (message.isWishlisted !== undefined) {
      writer.uint32(56).bool(message.isWishlisted);
    }
    if (message.userId !== undefined) {
      writer.uint32(66).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMarketTradeItemsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMarketTradeItemsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.page = PageRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sort.push(SortOption.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filters.push(FilterOption.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.search = SearchOption.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.itemType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rarity = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isWishlisted = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMarketTradeItemsRequest {
    return {
      page: isSet(object.page) ? PageRequest.fromJSON(object.page) : undefined,
      sort: globalThis.Array.isArray(object?.sort) ? object.sort.map((e: any) => SortOption.fromJSON(e)) : [],
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => FilterOption.fromJSON(e))
        : [],
      search: isSet(object.search) ? SearchOption.fromJSON(object.search) : undefined,
      itemType: isSet(object.itemType) ? itemTypeFromJSON(object.itemType) : undefined,
      rarity: isSet(object.rarity) ? itemRarityFromJSON(object.rarity) : undefined,
      isWishlisted: isSet(object.isWishlisted) ? globalThis.Boolean(object.isWishlisted) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : undefined,
    };
  },

  toJSON(message: ListMarketTradeItemsRequest): unknown {
    const obj: any = {};
    if (message.page !== undefined) {
      obj.page = PageRequest.toJSON(message.page);
    }
    if (message.sort?.length) {
      obj.sort = message.sort.map((e) => SortOption.toJSON(e));
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => FilterOption.toJSON(e));
    }
    if (message.search !== undefined) {
      obj.search = SearchOption.toJSON(message.search);
    }
    if (message.itemType !== undefined) {
      obj.itemType = itemTypeToJSON(message.itemType);
    }
    if (message.rarity !== undefined) {
      obj.rarity = itemRarityToJSON(message.rarity);
    }
    if (message.isWishlisted !== undefined) {
      obj.isWishlisted = message.isWishlisted;
    }
    if (message.userId !== undefined) {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListMarketTradeItemsRequest>, I>>(base?: I): ListMarketTradeItemsRequest {
    return ListMarketTradeItemsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListMarketTradeItemsRequest>, I>>(object: I): ListMarketTradeItemsRequest {
    const message = createBaseListMarketTradeItemsRequest();
    message.page = (object.page !== undefined && object.page !== null)
      ? PageRequest.fromPartial(object.page)
      : undefined;
    message.sort = object.sort?.map((e) => SortOption.fromPartial(e)) || [];
    message.filters = object.filters?.map((e) => FilterOption.fromPartial(e)) || [];
    message.search = (object.search !== undefined && object.search !== null)
      ? SearchOption.fromPartial(object.search)
      : undefined;
    message.itemType = object.itemType ?? undefined;
    message.rarity = object.rarity ?? undefined;
    message.isWishlisted = object.isWishlisted ?? undefined;
    message.userId = object.userId ?? undefined;
    return message;
  },
};

function createBaseListMarketTradeItemsResponse(): ListMarketTradeItemsResponse {
  return { status: undefined, error: undefined, metadata: undefined, data: undefined };
}

export const ListMarketTradeItemsResponse: MessageFns<ListMarketTradeItemsResponse> = {
  encode(message: ListMarketTradeItemsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.data !== undefined) {
      ListMarketTradeItemsData.encode(message.data, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMarketTradeItemsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMarketTradeItemsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = ListMarketTradeItemsData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMarketTradeItemsResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
      data: isSet(object.data) ? ListMarketTradeItemsData.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: ListMarketTradeItemsResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    if (message.data !== undefined) {
      obj.data = ListMarketTradeItemsData.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListMarketTradeItemsResponse>, I>>(base?: I): ListMarketTradeItemsResponse {
    return ListMarketTradeItemsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListMarketTradeItemsResponse>, I>>(object: I): ListMarketTradeItemsResponse {
    const message = createBaseListMarketTradeItemsResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? ListMarketTradeItemsData.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseListMarketTradeItemsData(): ListMarketTradeItemsData {
  return { items: [], pagination: undefined };
}

export const ListMarketTradeItemsData: MessageFns<ListMarketTradeItemsData> = {
  encode(message: ListMarketTradeItemsData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      MarketTradeItem.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMarketTradeItemsData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMarketTradeItemsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(MarketTradeItem.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMarketTradeItemsData {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => MarketTradeItem.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListMarketTradeItemsData): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => MarketTradeItem.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListMarketTradeItemsData>, I>>(base?: I): ListMarketTradeItemsData {
    return ListMarketTradeItemsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListMarketTradeItemsData>, I>>(object: I): ListMarketTradeItemsData {
    const message = createBaseListMarketTradeItemsData();
    message.items = object.items?.map((e) => MarketTradeItem.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseSellMarketTradeItemRequest(): SellMarketTradeItemRequest {
  return { inventoryItemId: "", quantity: 0, pricePerUnit: 0, currencyType: undefined };
}

export const SellMarketTradeItemRequest: MessageFns<SellMarketTradeItemRequest> = {
  encode(message: SellMarketTradeItemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inventoryItemId !== "") {
      writer.uint32(10).string(message.inventoryItemId);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).uint32(message.quantity);
    }
    if (message.pricePerUnit !== 0) {
      writer.uint32(24).uint32(message.pricePerUnit);
    }
    if (message.currencyType !== undefined) {
      writer.uint32(32).int32(message.currencyType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SellMarketTradeItemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSellMarketTradeItemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inventoryItemId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pricePerUnit = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.currencyType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SellMarketTradeItemRequest {
    return {
      inventoryItemId: isSet(object.inventoryItemId) ? globalThis.String(object.inventoryItemId) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      pricePerUnit: isSet(object.pricePerUnit) ? globalThis.Number(object.pricePerUnit) : 0,
      currencyType: isSet(object.currencyType) ? currencyTypeFromJSON(object.currencyType) : undefined,
    };
  },

  toJSON(message: SellMarketTradeItemRequest): unknown {
    const obj: any = {};
    if (message.inventoryItemId !== "") {
      obj.inventoryItemId = message.inventoryItemId;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.pricePerUnit !== 0) {
      obj.pricePerUnit = Math.round(message.pricePerUnit);
    }
    if (message.currencyType !== undefined) {
      obj.currencyType = currencyTypeToJSON(message.currencyType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SellMarketTradeItemRequest>, I>>(base?: I): SellMarketTradeItemRequest {
    return SellMarketTradeItemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SellMarketTradeItemRequest>, I>>(object: I): SellMarketTradeItemRequest {
    const message = createBaseSellMarketTradeItemRequest();
    message.inventoryItemId = object.inventoryItemId ?? "";
    message.quantity = object.quantity ?? 0;
    message.pricePerUnit = object.pricePerUnit ?? 0;
    message.currencyType = object.currencyType ?? undefined;
    return message;
  },
};

function createBaseSellMarketTradeItemResponse(): SellMarketTradeItemResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const SellMarketTradeItemResponse: MessageFns<SellMarketTradeItemResponse> = {
  encode(message: SellMarketTradeItemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      MarketTradeItem.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SellMarketTradeItemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSellMarketTradeItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = MarketTradeItem.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SellMarketTradeItemResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? MarketTradeItem.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: SellMarketTradeItemResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = MarketTradeItem.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SellMarketTradeItemResponse>, I>>(base?: I): SellMarketTradeItemResponse {
    return SellMarketTradeItemResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SellMarketTradeItemResponse>, I>>(object: I): SellMarketTradeItemResponse {
    const message = createBaseSellMarketTradeItemResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? MarketTradeItem.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseBuyMarketTradeItemRequest(): BuyMarketTradeItemRequest {
  return { marketTradeItemId: "", quantity: 0 };
}

export const BuyMarketTradeItemRequest: MessageFns<BuyMarketTradeItemRequest> = {
  encode(message: BuyMarketTradeItemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketTradeItemId !== "") {
      writer.uint32(10).string(message.marketTradeItemId);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).uint32(message.quantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuyMarketTradeItemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuyMarketTradeItemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.marketTradeItemId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuyMarketTradeItemRequest {
    return {
      marketTradeItemId: isSet(object.marketTradeItemId) ? globalThis.String(object.marketTradeItemId) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
    };
  },

  toJSON(message: BuyMarketTradeItemRequest): unknown {
    const obj: any = {};
    if (message.marketTradeItemId !== "") {
      obj.marketTradeItemId = message.marketTradeItemId;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuyMarketTradeItemRequest>, I>>(base?: I): BuyMarketTradeItemRequest {
    return BuyMarketTradeItemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuyMarketTradeItemRequest>, I>>(object: I): BuyMarketTradeItemRequest {
    const message = createBaseBuyMarketTradeItemRequest();
    message.marketTradeItemId = object.marketTradeItemId ?? "";
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

function createBaseBuyMarketTradeItemResponse(): BuyMarketTradeItemResponse {
  return { status: undefined, error: undefined, metadata: undefined, data: undefined };
}

export const BuyMarketTradeItemResponse: MessageFns<BuyMarketTradeItemResponse> = {
  encode(message: BuyMarketTradeItemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.data !== undefined) {
      BuyMarketTradeItemData.encode(message.data, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuyMarketTradeItemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuyMarketTradeItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = BuyMarketTradeItemData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuyMarketTradeItemResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
      data: isSet(object.data) ? BuyMarketTradeItemData.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: BuyMarketTradeItemResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    if (message.data !== undefined) {
      obj.data = BuyMarketTradeItemData.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuyMarketTradeItemResponse>, I>>(base?: I): BuyMarketTradeItemResponse {
    return BuyMarketTradeItemResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuyMarketTradeItemResponse>, I>>(object: I): BuyMarketTradeItemResponse {
    const message = createBaseBuyMarketTradeItemResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? BuyMarketTradeItemData.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseBuyMarketTradeItemData(): BuyMarketTradeItemData {
  return { marketTradeItemId: "", userInventory: undefined, walletBalanceAfter: 0 };
}

export const BuyMarketTradeItemData: MessageFns<BuyMarketTradeItemData> = {
  encode(message: BuyMarketTradeItemData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketTradeItemId !== "") {
      writer.uint32(10).string(message.marketTradeItemId);
    }
    if (message.userInventory !== undefined) {
      UserInventory.encode(message.userInventory, writer.uint32(18).fork()).join();
    }
    if (message.walletBalanceAfter !== 0) {
      writer.uint32(24).uint64(message.walletBalanceAfter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BuyMarketTradeItemData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuyMarketTradeItemData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.marketTradeItemId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userInventory = UserInventory.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.walletBalanceAfter = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuyMarketTradeItemData {
    return {
      marketTradeItemId: isSet(object.marketTradeItemId) ? globalThis.String(object.marketTradeItemId) : "",
      userInventory: isSet(object.userInventory) ? UserInventory.fromJSON(object.userInventory) : undefined,
      walletBalanceAfter: isSet(object.walletBalanceAfter) ? globalThis.Number(object.walletBalanceAfter) : 0,
    };
  },

  toJSON(message: BuyMarketTradeItemData): unknown {
    const obj: any = {};
    if (message.marketTradeItemId !== "") {
      obj.marketTradeItemId = message.marketTradeItemId;
    }
    if (message.userInventory !== undefined) {
      obj.userInventory = UserInventory.toJSON(message.userInventory);
    }
    if (message.walletBalanceAfter !== 0) {
      obj.walletBalanceAfter = Math.round(message.walletBalanceAfter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuyMarketTradeItemData>, I>>(base?: I): BuyMarketTradeItemData {
    return BuyMarketTradeItemData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuyMarketTradeItemData>, I>>(object: I): BuyMarketTradeItemData {
    const message = createBaseBuyMarketTradeItemData();
    message.marketTradeItemId = object.marketTradeItemId ?? "";
    message.userInventory = (object.userInventory !== undefined && object.userInventory !== null)
      ? UserInventory.fromPartial(object.userInventory)
      : undefined;
    message.walletBalanceAfter = object.walletBalanceAfter ?? 0;
    return message;
  },
};

function createBaseCancelMarketTradeItemRequest(): CancelMarketTradeItemRequest {
  return { marketTradeItemId: "" };
}

export const CancelMarketTradeItemRequest: MessageFns<CancelMarketTradeItemRequest> = {
  encode(message: CancelMarketTradeItemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketTradeItemId !== "") {
      writer.uint32(10).string(message.marketTradeItemId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelMarketTradeItemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelMarketTradeItemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.marketTradeItemId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelMarketTradeItemRequest {
    return { marketTradeItemId: isSet(object.marketTradeItemId) ? globalThis.String(object.marketTradeItemId) : "" };
  },

  toJSON(message: CancelMarketTradeItemRequest): unknown {
    const obj: any = {};
    if (message.marketTradeItemId !== "") {
      obj.marketTradeItemId = message.marketTradeItemId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelMarketTradeItemRequest>, I>>(base?: I): CancelMarketTradeItemRequest {
    return CancelMarketTradeItemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelMarketTradeItemRequest>, I>>(object: I): CancelMarketTradeItemRequest {
    const message = createBaseCancelMarketTradeItemRequest();
    message.marketTradeItemId = object.marketTradeItemId ?? "";
    return message;
  },
};

function createBaseCancelMarketTradeItemResponse(): CancelMarketTradeItemResponse {
  return { status: undefined, error: undefined, metadata: undefined };
}

export const CancelMarketTradeItemResponse: MessageFns<CancelMarketTradeItemResponse> = {
  encode(message: CancelMarketTradeItemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelMarketTradeItemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelMarketTradeItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelMarketTradeItemResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: CancelMarketTradeItemResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelMarketTradeItemResponse>, I>>(base?: I): CancelMarketTradeItemResponse {
    return CancelMarketTradeItemResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelMarketTradeItemResponse>, I>>(
    object: I,
  ): CancelMarketTradeItemResponse {
    const message = createBaseCancelMarketTradeItemResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseUserInventory(): UserInventory {
  return {
    id: "",
    userId: "",
    itemId: "",
    item: undefined,
    quantity: 0,
    lockedQuantity: 0,
    availableQuantity: 0,
    acquiredAt: "",
    metadata: undefined,
    createdAt: "",
    updatedAt: undefined,
    skillItem: undefined,
  };
}

export const UserInventory: MessageFns<UserInventory> = {
  encode(message: UserInventory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.itemId !== "") {
      writer.uint32(26).string(message.itemId);
    }
    if (message.item !== undefined) {
      Item.encode(message.item, writer.uint32(34).fork()).join();
    }
    if (message.quantity !== 0) {
      writer.uint32(40).uint32(message.quantity);
    }
    if (message.lockedQuantity !== 0) {
      writer.uint32(48).uint32(message.lockedQuantity);
    }
    if (message.availableQuantity !== 0) {
      writer.uint32(56).uint32(message.availableQuantity);
    }
    if (message.acquiredAt !== "") {
      writer.uint32(66).string(message.acquiredAt);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(74).fork()).join();
    }
    if (message.createdAt !== "") {
      writer.uint32(82).string(message.createdAt);
    }
    if (message.updatedAt !== undefined) {
      writer.uint32(90).string(message.updatedAt);
    }
    if (message.skillItem !== undefined) {
      UserSkill.encode(message.skillItem, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInventory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInventory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.itemId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.item = Item.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.quantity = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.lockedQuantity = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.availableQuantity = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.acquiredAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.skillItem = UserSkill.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInventory {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "",
      item: isSet(object.item) ? Item.fromJSON(object.item) : undefined,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      lockedQuantity: isSet(object.lockedQuantity) ? globalThis.Number(object.lockedQuantity) : 0,
      availableQuantity: isSet(object.availableQuantity) ? globalThis.Number(object.availableQuantity) : 0,
      acquiredAt: isSet(object.acquiredAt) ? globalThis.String(object.acquiredAt) : "",
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : undefined,
      skillItem: isSet(object.skillItem) ? UserSkill.fromJSON(object.skillItem) : undefined,
    };
  },

  toJSON(message: UserInventory): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.itemId !== "") {
      obj.itemId = message.itemId;
    }
    if (message.item !== undefined) {
      obj.item = Item.toJSON(message.item);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.lockedQuantity !== 0) {
      obj.lockedQuantity = Math.round(message.lockedQuantity);
    }
    if (message.availableQuantity !== 0) {
      obj.availableQuantity = Math.round(message.availableQuantity);
    }
    if (message.acquiredAt !== "") {
      obj.acquiredAt = message.acquiredAt;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt;
    }
    if (message.skillItem !== undefined) {
      obj.skillItem = UserSkill.toJSON(message.skillItem);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserInventory>, I>>(base?: I): UserInventory {
    return UserInventory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserInventory>, I>>(object: I): UserInventory {
    const message = createBaseUserInventory();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.itemId = object.itemId ?? "";
    message.item = (object.item !== undefined && object.item !== null) ? Item.fromPartial(object.item) : undefined;
    message.quantity = object.quantity ?? 0;
    message.lockedQuantity = object.lockedQuantity ?? 0;
    message.availableQuantity = object.availableQuantity ?? 0;
    message.acquiredAt = object.acquiredAt ?? "";
    message.metadata = object.metadata ?? undefined;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? undefined;
    message.skillItem = (object.skillItem !== undefined && object.skillItem !== null)
      ? UserSkill.fromPartial(object.skillItem)
      : undefined;
    return message;
  },
};

function createBaseGetUserInventoryRequest(): GetUserInventoryRequest {
  return { userId: "", page: undefined, sort: [], filters: [], search: undefined, itemType: undefined };
}

export const GetUserInventoryRequest: MessageFns<GetUserInventoryRequest> = {
  encode(message: GetUserInventoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.page !== undefined) {
      PageRequest.encode(message.page, writer.uint32(18).fork()).join();
    }
    for (const v of message.sort) {
      SortOption.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.filters) {
      FilterOption.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.search !== undefined) {
      SearchOption.encode(message.search, writer.uint32(42).fork()).join();
    }
    if (message.itemType !== undefined) {
      writer.uint32(48).int32(message.itemType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserInventoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserInventoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.page = PageRequest.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sort.push(SortOption.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filters.push(FilterOption.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.search = SearchOption.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.itemType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserInventoryRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      page: isSet(object.page) ? PageRequest.fromJSON(object.page) : undefined,
      sort: globalThis.Array.isArray(object?.sort) ? object.sort.map((e: any) => SortOption.fromJSON(e)) : [],
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => FilterOption.fromJSON(e))
        : [],
      search: isSet(object.search) ? SearchOption.fromJSON(object.search) : undefined,
      itemType: isSet(object.itemType) ? itemTypeFromJSON(object.itemType) : undefined,
    };
  },

  toJSON(message: GetUserInventoryRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.page !== undefined) {
      obj.page = PageRequest.toJSON(message.page);
    }
    if (message.sort?.length) {
      obj.sort = message.sort.map((e) => SortOption.toJSON(e));
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => FilterOption.toJSON(e));
    }
    if (message.search !== undefined) {
      obj.search = SearchOption.toJSON(message.search);
    }
    if (message.itemType !== undefined) {
      obj.itemType = itemTypeToJSON(message.itemType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserInventoryRequest>, I>>(base?: I): GetUserInventoryRequest {
    return GetUserInventoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserInventoryRequest>, I>>(object: I): GetUserInventoryRequest {
    const message = createBaseGetUserInventoryRequest();
    message.userId = object.userId ?? "";
    message.page = (object.page !== undefined && object.page !== null)
      ? PageRequest.fromPartial(object.page)
      : undefined;
    message.sort = object.sort?.map((e) => SortOption.fromPartial(e)) || [];
    message.filters = object.filters?.map((e) => FilterOption.fromPartial(e)) || [];
    message.search = (object.search !== undefined && object.search !== null)
      ? SearchOption.fromPartial(object.search)
      : undefined;
    message.itemType = object.itemType ?? undefined;
    return message;
  },
};

function createBaseGetUserInventoryResponse(): GetUserInventoryResponse {
  return { status: undefined, error: undefined, metadata: undefined, data: undefined };
}

export const GetUserInventoryResponse: MessageFns<GetUserInventoryResponse> = {
  encode(message: GetUserInventoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.data !== undefined) {
      GetUserInventoryData.encode(message.data, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserInventoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserInventoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = GetUserInventoryData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserInventoryResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
      data: isSet(object.data) ? GetUserInventoryData.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: GetUserInventoryResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    if (message.data !== undefined) {
      obj.data = GetUserInventoryData.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserInventoryResponse>, I>>(base?: I): GetUserInventoryResponse {
    return GetUserInventoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserInventoryResponse>, I>>(object: I): GetUserInventoryResponse {
    const message = createBaseGetUserInventoryResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? GetUserInventoryData.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseGetUserInventoryData(): GetUserInventoryData {
  return { items: [], pagination: undefined };
}

export const GetUserInventoryData: MessageFns<GetUserInventoryData> = {
  encode(message: GetUserInventoryData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      UserInventory.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserInventoryData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserInventoryData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(UserInventory.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserInventoryData {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => UserInventory.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: GetUserInventoryData): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => UserInventory.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserInventoryData>, I>>(base?: I): GetUserInventoryData {
    return GetUserInventoryData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserInventoryData>, I>>(object: I): GetUserInventoryData {
    const message = createBaseGetUserInventoryData();
    message.items = object.items?.map((e) => UserInventory.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseAddItemToInventoryRequest(): AddItemToInventoryRequest {
  return { userId: "", itemId: "", quantity: 0, metadata: {} };
}

export const AddItemToInventoryRequest: MessageFns<AddItemToInventoryRequest> = {
  encode(message: AddItemToInventoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.itemId !== "") {
      writer.uint32(18).string(message.itemId);
    }
    if (message.quantity !== 0) {
      writer.uint32(24).uint32(message.quantity);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      AddItemToInventoryRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddItemToInventoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddItemToInventoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.itemId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.quantity = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = AddItemToInventoryRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddItemToInventoryRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AddItemToInventoryRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.itemId !== "") {
      obj.itemId = message.itemId;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddItemToInventoryRequest>, I>>(base?: I): AddItemToInventoryRequest {
    return AddItemToInventoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddItemToInventoryRequest>, I>>(object: I): AddItemToInventoryRequest {
    const message = createBaseAddItemToInventoryRequest();
    message.userId = object.userId ?? "";
    message.itemId = object.itemId ?? "";
    message.quantity = object.quantity ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAddItemToInventoryRequest_MetadataEntry(): AddItemToInventoryRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const AddItemToInventoryRequest_MetadataEntry: MessageFns<AddItemToInventoryRequest_MetadataEntry> = {
  encode(message: AddItemToInventoryRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddItemToInventoryRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddItemToInventoryRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddItemToInventoryRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AddItemToInventoryRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddItemToInventoryRequest_MetadataEntry>, I>>(
    base?: I,
  ): AddItemToInventoryRequest_MetadataEntry {
    return AddItemToInventoryRequest_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddItemToInventoryRequest_MetadataEntry>, I>>(
    object: I,
  ): AddItemToInventoryRequest_MetadataEntry {
    const message = createBaseAddItemToInventoryRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAddItemToInventoryResponse(): AddItemToInventoryResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const AddItemToInventoryResponse: MessageFns<AddItemToInventoryResponse> = {
  encode(message: AddItemToInventoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      UserInventory.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddItemToInventoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddItemToInventoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = UserInventory.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddItemToInventoryResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? UserInventory.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: AddItemToInventoryResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = UserInventory.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddItemToInventoryResponse>, I>>(base?: I): AddItemToInventoryResponse {
    return AddItemToInventoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddItemToInventoryResponse>, I>>(object: I): AddItemToInventoryResponse {
    const message = createBaseAddItemToInventoryResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? UserInventory.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseGetUserInventoryCurrencyRequest(): GetUserInventoryCurrencyRequest {
  return { userId: "" };
}

export const GetUserInventoryCurrencyRequest: MessageFns<GetUserInventoryCurrencyRequest> = {
  encode(message: GetUserInventoryCurrencyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserInventoryCurrencyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserInventoryCurrencyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserInventoryCurrencyRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetUserInventoryCurrencyRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserInventoryCurrencyRequest>, I>>(base?: I): GetUserInventoryCurrencyRequest {
    return GetUserInventoryCurrencyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserInventoryCurrencyRequest>, I>>(
    object: I,
  ): GetUserInventoryCurrencyRequest {
    const message = createBaseGetUserInventoryCurrencyRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetUserInventoryCurrencyResponse(): GetUserInventoryCurrencyResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const GetUserInventoryCurrencyResponse: MessageFns<GetUserInventoryCurrencyResponse> = {
  encode(message: GetUserInventoryCurrencyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      GetUserInventoryCurrencyData.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserInventoryCurrencyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserInventoryCurrencyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = GetUserInventoryCurrencyData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserInventoryCurrencyResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? GetUserInventoryCurrencyData.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: GetUserInventoryCurrencyResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = GetUserInventoryCurrencyData.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserInventoryCurrencyResponse>, I>>(
    base?: I,
  ): GetUserInventoryCurrencyResponse {
    return GetUserInventoryCurrencyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserInventoryCurrencyResponse>, I>>(
    object: I,
  ): GetUserInventoryCurrencyResponse {
    const message = createBaseGetUserInventoryCurrencyResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? GetUserInventoryCurrencyData.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseGetUserInventoryCurrencyData(): GetUserInventoryCurrencyData {
  return { totalBalances: {} };
}

export const GetUserInventoryCurrencyData: MessageFns<GetUserInventoryCurrencyData> = {
  encode(message: GetUserInventoryCurrencyData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.totalBalances).forEach(([key, value]) => {
      GetUserInventoryCurrencyData_TotalBalancesEntry.encode({ key: key as any, value }, writer.uint32(10).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserInventoryCurrencyData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserInventoryCurrencyData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = GetUserInventoryCurrencyData_TotalBalancesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.totalBalances[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserInventoryCurrencyData {
    return {
      totalBalances: isObject(object.totalBalances)
        ? Object.entries(object.totalBalances).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetUserInventoryCurrencyData): unknown {
    const obj: any = {};
    if (message.totalBalances) {
      const entries = Object.entries(message.totalBalances);
      if (entries.length > 0) {
        obj.totalBalances = {};
        entries.forEach(([k, v]) => {
          obj.totalBalances[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserInventoryCurrencyData>, I>>(base?: I): GetUserInventoryCurrencyData {
    return GetUserInventoryCurrencyData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserInventoryCurrencyData>, I>>(object: I): GetUserInventoryCurrencyData {
    const message = createBaseGetUserInventoryCurrencyData();
    message.totalBalances = Object.entries(object.totalBalances ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGetUserInventoryCurrencyData_TotalBalancesEntry(): GetUserInventoryCurrencyData_TotalBalancesEntry {
  return { key: "", value: 0 };
}

export const GetUserInventoryCurrencyData_TotalBalancesEntry: MessageFns<
  GetUserInventoryCurrencyData_TotalBalancesEntry
> = {
  encode(
    message: GetUserInventoryCurrencyData_TotalBalancesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserInventoryCurrencyData_TotalBalancesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserInventoryCurrencyData_TotalBalancesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserInventoryCurrencyData_TotalBalancesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: GetUserInventoryCurrencyData_TotalBalancesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserInventoryCurrencyData_TotalBalancesEntry>, I>>(
    base?: I,
  ): GetUserInventoryCurrencyData_TotalBalancesEntry {
    return GetUserInventoryCurrencyData_TotalBalancesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserInventoryCurrencyData_TotalBalancesEntry>, I>>(
    object: I,
  ): GetUserInventoryCurrencyData_TotalBalancesEntry {
    const message = createBaseGetUserInventoryCurrencyData_TotalBalancesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseSellItemRequest(): SellItemRequest {
  return { inventoryItemId: "", quantity: 0 };
}

export const SellItemRequest: MessageFns<SellItemRequest> = {
  encode(message: SellItemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inventoryItemId !== "") {
      writer.uint32(10).string(message.inventoryItemId);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).uint32(message.quantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SellItemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSellItemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inventoryItemId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SellItemRequest {
    return {
      inventoryItemId: isSet(object.inventoryItemId) ? globalThis.String(object.inventoryItemId) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
    };
  },

  toJSON(message: SellItemRequest): unknown {
    const obj: any = {};
    if (message.inventoryItemId !== "") {
      obj.inventoryItemId = message.inventoryItemId;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SellItemRequest>, I>>(base?: I): SellItemRequest {
    return SellItemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SellItemRequest>, I>>(object: I): SellItemRequest {
    const message = createBaseSellItemRequest();
    message.inventoryItemId = object.inventoryItemId ?? "";
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

function createBaseSellItemResponse(): SellItemResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const SellItemResponse: MessageFns<SellItemResponse> = {
  encode(message: SellItemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      UserInventory.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SellItemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSellItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = UserInventory.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SellItemResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? UserInventory.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: SellItemResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = UserInventory.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SellItemResponse>, I>>(base?: I): SellItemResponse {
    return SellItemResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SellItemResponse>, I>>(object: I): SellItemResponse {
    const message = createBaseSellItemResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? UserInventory.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseGetEggSystemConfigRequest(): GetEggSystemConfigRequest {
  return { userId: "" };
}

export const GetEggSystemConfigRequest: MessageFns<GetEggSystemConfigRequest> = {
  encode(message: GetEggSystemConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEggSystemConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEggSystemConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEggSystemConfigRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetEggSystemConfigRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEggSystemConfigRequest>, I>>(base?: I): GetEggSystemConfigRequest {
    return GetEggSystemConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEggSystemConfigRequest>, I>>(object: I): GetEggSystemConfigRequest {
    const message = createBaseGetEggSystemConfigRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetEggSystemConfigResponse(): GetEggSystemConfigResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const GetEggSystemConfigResponse: MessageFns<GetEggSystemConfigResponse> = {
  encode(message: GetEggSystemConfigResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      GetEggSystemConfigData.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEggSystemConfigResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEggSystemConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = GetEggSystemConfigData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEggSystemConfigResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? GetEggSystemConfigData.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: GetEggSystemConfigResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = GetEggSystemConfigData.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEggSystemConfigResponse>, I>>(base?: I): GetEggSystemConfigResponse {
    return GetEggSystemConfigResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEggSystemConfigResponse>, I>>(object: I): GetEggSystemConfigResponse {
    const message = createBaseGetEggSystemConfigResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? GetEggSystemConfigData.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseGetEggSystemConfigData(): GetEggSystemConfigData {
  return {
    gen1CraftingFee: 0,
    gen1RequiredFragments: 0,
    gen1SuccessRate: 0,
    gen1FragmentsLostOnFailure: 0,
    gen2OpeningFee: 0,
    luckyLeafBoost: 0,
    luckyLeafRequired: 0,
    luckyLeafItemId: undefined,
  };
}

export const GetEggSystemConfigData: MessageFns<GetEggSystemConfigData> = {
  encode(message: GetEggSystemConfigData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gen1CraftingFee !== 0) {
      writer.uint32(9).double(message.gen1CraftingFee);
    }
    if (message.gen1RequiredFragments !== 0) {
      writer.uint32(16).int32(message.gen1RequiredFragments);
    }
    if (message.gen1SuccessRate !== 0) {
      writer.uint32(25).double(message.gen1SuccessRate);
    }
    if (message.gen1FragmentsLostOnFailure !== 0) {
      writer.uint32(32).int32(message.gen1FragmentsLostOnFailure);
    }
    if (message.gen2OpeningFee !== 0) {
      writer.uint32(41).double(message.gen2OpeningFee);
    }
    if (message.luckyLeafBoost !== 0) {
      writer.uint32(49).double(message.luckyLeafBoost);
    }
    if (message.luckyLeafRequired !== 0) {
      writer.uint32(56).int32(message.luckyLeafRequired);
    }
    if (message.luckyLeafItemId !== undefined) {
      writer.uint32(66).string(message.luckyLeafItemId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEggSystemConfigData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEggSystemConfigData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.gen1CraftingFee = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.gen1RequiredFragments = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.gen1SuccessRate = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gen1FragmentsLostOnFailure = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.gen2OpeningFee = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.luckyLeafBoost = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.luckyLeafRequired = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.luckyLeafItemId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEggSystemConfigData {
    return {
      gen1CraftingFee: isSet(object.gen1CraftingFee) ? globalThis.Number(object.gen1CraftingFee) : 0,
      gen1RequiredFragments: isSet(object.gen1RequiredFragments) ? globalThis.Number(object.gen1RequiredFragments) : 0,
      gen1SuccessRate: isSet(object.gen1SuccessRate) ? globalThis.Number(object.gen1SuccessRate) : 0,
      gen1FragmentsLostOnFailure: isSet(object.gen1FragmentsLostOnFailure)
        ? globalThis.Number(object.gen1FragmentsLostOnFailure)
        : 0,
      gen2OpeningFee: isSet(object.gen2OpeningFee) ? globalThis.Number(object.gen2OpeningFee) : 0,
      luckyLeafBoost: isSet(object.luckyLeafBoost) ? globalThis.Number(object.luckyLeafBoost) : 0,
      luckyLeafRequired: isSet(object.luckyLeafRequired) ? globalThis.Number(object.luckyLeafRequired) : 0,
      luckyLeafItemId: isSet(object.luckyLeafItemId) ? globalThis.String(object.luckyLeafItemId) : undefined,
    };
  },

  toJSON(message: GetEggSystemConfigData): unknown {
    const obj: any = {};
    if (message.gen1CraftingFee !== 0) {
      obj.gen1CraftingFee = message.gen1CraftingFee;
    }
    if (message.gen1RequiredFragments !== 0) {
      obj.gen1RequiredFragments = Math.round(message.gen1RequiredFragments);
    }
    if (message.gen1SuccessRate !== 0) {
      obj.gen1SuccessRate = message.gen1SuccessRate;
    }
    if (message.gen1FragmentsLostOnFailure !== 0) {
      obj.gen1FragmentsLostOnFailure = Math.round(message.gen1FragmentsLostOnFailure);
    }
    if (message.gen2OpeningFee !== 0) {
      obj.gen2OpeningFee = message.gen2OpeningFee;
    }
    if (message.luckyLeafBoost !== 0) {
      obj.luckyLeafBoost = message.luckyLeafBoost;
    }
    if (message.luckyLeafRequired !== 0) {
      obj.luckyLeafRequired = Math.round(message.luckyLeafRequired);
    }
    if (message.luckyLeafItemId !== undefined) {
      obj.luckyLeafItemId = message.luckyLeafItemId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetEggSystemConfigData>, I>>(base?: I): GetEggSystemConfigData {
    return GetEggSystemConfigData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetEggSystemConfigData>, I>>(object: I): GetEggSystemConfigData {
    const message = createBaseGetEggSystemConfigData();
    message.gen1CraftingFee = object.gen1CraftingFee ?? 0;
    message.gen1RequiredFragments = object.gen1RequiredFragments ?? 0;
    message.gen1SuccessRate = object.gen1SuccessRate ?? 0;
    message.gen1FragmentsLostOnFailure = object.gen1FragmentsLostOnFailure ?? 0;
    message.gen2OpeningFee = object.gen2OpeningFee ?? 0;
    message.luckyLeafBoost = object.luckyLeafBoost ?? 0;
    message.luckyLeafRequired = object.luckyLeafRequired ?? 0;
    message.luckyLeafItemId = object.luckyLeafItemId ?? undefined;
    return message;
  },
};

function createBaseCraftEggRequest(): CraftEggRequest {
  return { userId: "", luckyLeafQuantity: 0 };
}

export const CraftEggRequest: MessageFns<CraftEggRequest> = {
  encode(message: CraftEggRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.luckyLeafQuantity !== 0) {
      writer.uint32(16).int32(message.luckyLeafQuantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CraftEggRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCraftEggRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.luckyLeafQuantity = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CraftEggRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      luckyLeafQuantity: isSet(object.luckyLeafQuantity) ? globalThis.Number(object.luckyLeafQuantity) : 0,
    };
  },

  toJSON(message: CraftEggRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.luckyLeafQuantity !== 0) {
      obj.luckyLeafQuantity = Math.round(message.luckyLeafQuantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CraftEggRequest>, I>>(base?: I): CraftEggRequest {
    return CraftEggRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CraftEggRequest>, I>>(object: I): CraftEggRequest {
    const message = createBaseCraftEggRequest();
    message.userId = object.userId ?? "";
    message.luckyLeafQuantity = object.luckyLeafQuantity ?? 0;
    return message;
  },
};

function createBaseCraftEggResponse(): CraftEggResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const CraftEggResponse: MessageFns<CraftEggResponse> = {
  encode(message: CraftEggResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      CraftEggData.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CraftEggResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCraftEggResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = CraftEggData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CraftEggResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? CraftEggData.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: CraftEggResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = CraftEggData.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CraftEggResponse>, I>>(base?: I): CraftEggResponse {
    return CraftEggResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CraftEggResponse>, I>>(object: I): CraftEggResponse {
    const message = createBaseCraftEggResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? CraftEggData.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseCraftEggData(): CraftEggData {
  return {
    success: false,
    craftedEggId: "",
    craftedEggQuantity: 0,
    fragmentsUsed: 0,
    luckyLeavesUsed: 0,
    craftingFee: 0,
    walletBalanceAfter: 0,
    message: "",
  };
}

export const CraftEggData: MessageFns<CraftEggData> = {
  encode(message: CraftEggData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.craftedEggId !== "") {
      writer.uint32(18).string(message.craftedEggId);
    }
    if (message.craftedEggQuantity !== 0) {
      writer.uint32(24).int32(message.craftedEggQuantity);
    }
    if (message.fragmentsUsed !== 0) {
      writer.uint32(32).int32(message.fragmentsUsed);
    }
    if (message.luckyLeavesUsed !== 0) {
      writer.uint32(40).int32(message.luckyLeavesUsed);
    }
    if (message.craftingFee !== 0) {
      writer.uint32(48).int64(message.craftingFee);
    }
    if (message.walletBalanceAfter !== 0) {
      writer.uint32(56).int64(message.walletBalanceAfter);
    }
    if (message.message !== "") {
      writer.uint32(66).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CraftEggData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCraftEggData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.craftedEggId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.craftedEggQuantity = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fragmentsUsed = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.luckyLeavesUsed = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.craftingFee = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.walletBalanceAfter = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CraftEggData {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      craftedEggId: isSet(object.craftedEggId) ? globalThis.String(object.craftedEggId) : "",
      craftedEggQuantity: isSet(object.craftedEggQuantity) ? globalThis.Number(object.craftedEggQuantity) : 0,
      fragmentsUsed: isSet(object.fragmentsUsed) ? globalThis.Number(object.fragmentsUsed) : 0,
      luckyLeavesUsed: isSet(object.luckyLeavesUsed) ? globalThis.Number(object.luckyLeavesUsed) : 0,
      craftingFee: isSet(object.craftingFee) ? globalThis.Number(object.craftingFee) : 0,
      walletBalanceAfter: isSet(object.walletBalanceAfter) ? globalThis.Number(object.walletBalanceAfter) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: CraftEggData): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.craftedEggId !== "") {
      obj.craftedEggId = message.craftedEggId;
    }
    if (message.craftedEggQuantity !== 0) {
      obj.craftedEggQuantity = Math.round(message.craftedEggQuantity);
    }
    if (message.fragmentsUsed !== 0) {
      obj.fragmentsUsed = Math.round(message.fragmentsUsed);
    }
    if (message.luckyLeavesUsed !== 0) {
      obj.luckyLeavesUsed = Math.round(message.luckyLeavesUsed);
    }
    if (message.craftingFee !== 0) {
      obj.craftingFee = Math.round(message.craftingFee);
    }
    if (message.walletBalanceAfter !== 0) {
      obj.walletBalanceAfter = Math.round(message.walletBalanceAfter);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CraftEggData>, I>>(base?: I): CraftEggData {
    return CraftEggData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CraftEggData>, I>>(object: I): CraftEggData {
    const message = createBaseCraftEggData();
    message.success = object.success ?? false;
    message.craftedEggId = object.craftedEggId ?? "";
    message.craftedEggQuantity = object.craftedEggQuantity ?? 0;
    message.fragmentsUsed = object.fragmentsUsed ?? 0;
    message.luckyLeavesUsed = object.luckyLeavesUsed ?? 0;
    message.craftingFee = object.craftingFee ?? 0;
    message.walletBalanceAfter = object.walletBalanceAfter ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseOpenItemRequest(): OpenItemRequest {
  return { userId: "", inventoryItemId: undefined, quantity: 0, itemCode: undefined };
}

export const OpenItemRequest: MessageFns<OpenItemRequest> = {
  encode(message: OpenItemRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.inventoryItemId !== undefined) {
      writer.uint32(18).string(message.inventoryItemId);
    }
    if (message.quantity !== 0) {
      writer.uint32(24).int32(message.quantity);
    }
    if (message.itemCode !== undefined) {
      writer.uint32(34).string(message.itemCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenItemRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenItemRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inventoryItemId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.itemCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenItemRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      inventoryItemId: isSet(object.inventoryItemId) ? globalThis.String(object.inventoryItemId) : undefined,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      itemCode: isSet(object.itemCode) ? globalThis.String(object.itemCode) : undefined,
    };
  },

  toJSON(message: OpenItemRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.inventoryItemId !== undefined) {
      obj.inventoryItemId = message.inventoryItemId;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.itemCode !== undefined) {
      obj.itemCode = message.itemCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenItemRequest>, I>>(base?: I): OpenItemRequest {
    return OpenItemRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenItemRequest>, I>>(object: I): OpenItemRequest {
    const message = createBaseOpenItemRequest();
    message.userId = object.userId ?? "";
    message.inventoryItemId = object.inventoryItemId ?? undefined;
    message.quantity = object.quantity ?? 0;
    message.itemCode = object.itemCode ?? undefined;
    return message;
  },
};

function createBaseOpenItemResponse(): OpenItemResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const OpenItemResponse: MessageFns<OpenItemResponse> = {
  encode(message: OpenItemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      OpenItemData.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenItemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenItemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = OpenItemData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenItemResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? OpenItemData.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: OpenItemResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = OpenItemData.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenItemResponse>, I>>(base?: I): OpenItemResponse {
    return OpenItemResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenItemResponse>, I>>(object: I): OpenItemResponse {
    const message = createBaseOpenItemResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? OpenItemData.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseOpenItemData(): OpenItemData {
  return { inventoryItems: [], characters: [], skills: [], openingFee: 0, walletBalanceAfter: 0, message: undefined };
}

export const OpenItemData: MessageFns<OpenItemData> = {
  encode(message: OpenItemData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.inventoryItems) {
      ItemRef.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.characters) {
      CharacterRef.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.skills) {
      UserSkill.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.openingFee !== 0) {
      writer.uint32(32).int64(message.openingFee);
    }
    if (message.walletBalanceAfter !== 0) {
      writer.uint32(40).int64(message.walletBalanceAfter);
    }
    if (message.message !== undefined) {
      writer.uint32(50).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenItemData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenItemData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inventoryItems.push(ItemRef.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.characters.push(CharacterRef.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.skills.push(UserSkill.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.openingFee = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.walletBalanceAfter = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenItemData {
    return {
      inventoryItems: globalThis.Array.isArray(object?.inventoryItems)
        ? object.inventoryItems.map((e: any) => ItemRef.fromJSON(e))
        : [],
      characters: globalThis.Array.isArray(object?.characters)
        ? object.characters.map((e: any) => CharacterRef.fromJSON(e))
        : [],
      skills: globalThis.Array.isArray(object?.skills) ? object.skills.map((e: any) => UserSkill.fromJSON(e)) : [],
      openingFee: isSet(object.openingFee) ? globalThis.Number(object.openingFee) : 0,
      walletBalanceAfter: isSet(object.walletBalanceAfter) ? globalThis.Number(object.walletBalanceAfter) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: OpenItemData): unknown {
    const obj: any = {};
    if (message.inventoryItems?.length) {
      obj.inventoryItems = message.inventoryItems.map((e) => ItemRef.toJSON(e));
    }
    if (message.characters?.length) {
      obj.characters = message.characters.map((e) => CharacterRef.toJSON(e));
    }
    if (message.skills?.length) {
      obj.skills = message.skills.map((e) => UserSkill.toJSON(e));
    }
    if (message.openingFee !== 0) {
      obj.openingFee = Math.round(message.openingFee);
    }
    if (message.walletBalanceAfter !== 0) {
      obj.walletBalanceAfter = Math.round(message.walletBalanceAfter);
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpenItemData>, I>>(base?: I): OpenItemData {
    return OpenItemData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpenItemData>, I>>(object: I): OpenItemData {
    const message = createBaseOpenItemData();
    message.inventoryItems = object.inventoryItems?.map((e) => ItemRef.fromPartial(e)) || [];
    message.characters = object.characters?.map((e) => CharacterRef.fromPartial(e)) || [];
    message.skills = object.skills?.map((e) => UserSkill.fromPartial(e)) || [];
    message.openingFee = object.openingFee ?? 0;
    message.walletBalanceAfter = object.walletBalanceAfter ?? 0;
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseGetGameSystemConfigRequest(): GetGameSystemConfigRequest {
  return { userId: "" };
}

export const GetGameSystemConfigRequest: MessageFns<GetGameSystemConfigRequest> = {
  encode(message: GetGameSystemConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGameSystemConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGameSystemConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGameSystemConfigRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetGameSystemConfigRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGameSystemConfigRequest>, I>>(base?: I): GetGameSystemConfigRequest {
    return GetGameSystemConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGameSystemConfigRequest>, I>>(object: I): GetGameSystemConfigRequest {
    const message = createBaseGetGameSystemConfigRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetGameSystemConfigResponse(): GetGameSystemConfigResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const GetGameSystemConfigResponse: MessageFns<GetGameSystemConfigResponse> = {
  encode(message: GetGameSystemConfigResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      GameSystemConfigData.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGameSystemConfigResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGameSystemConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = GameSystemConfigData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGameSystemConfigResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? GameSystemConfigData.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: GetGameSystemConfigResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = GameSystemConfigData.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGameSystemConfigResponse>, I>>(base?: I): GetGameSystemConfigResponse {
    return GetGameSystemConfigResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGameSystemConfigResponse>, I>>(object: I): GetGameSystemConfigResponse {
    const message = createBaseGetGameSystemConfigResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? GameSystemConfigData.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseGameSystemConfigData(): GameSystemConfigData {
  return {};
}

export const GameSystemConfigData: MessageFns<GameSystemConfigData> = {
  encode(_: GameSystemConfigData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameSystemConfigData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameSystemConfigData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GameSystemConfigData {
    return {};
  },

  toJSON(_: GameSystemConfigData): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GameSystemConfigData>, I>>(base?: I): GameSystemConfigData {
    return GameSystemConfigData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameSystemConfigData>, I>>(_: I): GameSystemConfigData {
    const message = createBaseGameSystemConfigData();
    return message;
  },
};

function createBaseClaimChestRequest(): ClaimChestRequest {
  return { chestType: 0 };
}

export const ClaimChestRequest: MessageFns<ClaimChestRequest> = {
  encode(message: ClaimChestRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chestType !== 0) {
      writer.uint32(8).int32(message.chestType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimChestRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimChestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.chestType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimChestRequest {
    return { chestType: isSet(object.chestType) ? chestTypeFromJSON(object.chestType) : 0 };
  },

  toJSON(message: ClaimChestRequest): unknown {
    const obj: any = {};
    if (message.chestType !== 0) {
      obj.chestType = chestTypeToJSON(message.chestType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClaimChestRequest>, I>>(base?: I): ClaimChestRequest {
    return ClaimChestRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClaimChestRequest>, I>>(object: I): ClaimChestRequest {
    const message = createBaseClaimChestRequest();
    message.chestType = object.chestType ?? 0;
    return message;
  },
};

function createBaseClaimChestResponse(): ClaimChestResponse {
  return { status: undefined, error: undefined, metadata: undefined, data: undefined };
}

export const ClaimChestResponse: MessageFns<ClaimChestResponse> = {
  encode(message: ClaimChestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.data !== undefined) {
      OpenItemData.encode(message.data, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClaimChestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimChestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = OpenItemData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimChestResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
      data: isSet(object.data) ? OpenItemData.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: ClaimChestResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    if (message.data !== undefined) {
      obj.data = OpenItemData.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClaimChestResponse>, I>>(base?: I): ClaimChestResponse {
    return ClaimChestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClaimChestResponse>, I>>(object: I): ClaimChestResponse {
    const message = createBaseClaimChestResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? OpenItemData.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseWallet(): Wallet {
  return {
    id: "",
    userId: "",
    currency: 0,
    balance: 0,
    lockedBalance: 0,
    availableBalance: 0,
    status: 0,
    createdAt: "",
    updatedAt: undefined,
  };
}

export const Wallet: MessageFns<Wallet> = {
  encode(message: Wallet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.currency !== 0) {
      writer.uint32(24).int32(message.currency);
    }
    if (message.balance !== 0) {
      writer.uint32(32).int64(message.balance);
    }
    if (message.lockedBalance !== 0) {
      writer.uint32(40).int64(message.lockedBalance);
    }
    if (message.availableBalance !== 0) {
      writer.uint32(48).int64(message.availableBalance);
    }
    if (message.status !== 0) {
      writer.uint32(56).int32(message.status);
    }
    if (message.createdAt !== "") {
      writer.uint32(66).string(message.createdAt);
    }
    if (message.updatedAt !== undefined) {
      writer.uint32(74).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Wallet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWallet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.currency = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.balance = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lockedBalance = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.availableBalance = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Wallet {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      currency: isSet(object.currency) ? currencyTypeFromJSON(object.currency) : 0,
      balance: isSet(object.balance) ? globalThis.Number(object.balance) : 0,
      lockedBalance: isSet(object.lockedBalance) ? globalThis.Number(object.lockedBalance) : 0,
      availableBalance: isSet(object.availableBalance) ? globalThis.Number(object.availableBalance) : 0,
      status: isSet(object.status) ? walletStatusFromJSON(object.status) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      updatedAt: isSet(object.updatedAt) ? globalThis.String(object.updatedAt) : undefined,
    };
  },

  toJSON(message: Wallet): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.currency !== 0) {
      obj.currency = currencyTypeToJSON(message.currency);
    }
    if (message.balance !== 0) {
      obj.balance = Math.round(message.balance);
    }
    if (message.lockedBalance !== 0) {
      obj.lockedBalance = Math.round(message.lockedBalance);
    }
    if (message.availableBalance !== 0) {
      obj.availableBalance = Math.round(message.availableBalance);
    }
    if (message.status !== 0) {
      obj.status = walletStatusToJSON(message.status);
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Wallet>, I>>(base?: I): Wallet {
    return Wallet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Wallet>, I>>(object: I): Wallet {
    const message = createBaseWallet();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.currency = object.currency ?? 0;
    message.balance = object.balance ?? 0;
    message.lockedBalance = object.lockedBalance ?? 0;
    message.availableBalance = object.availableBalance ?? 0;
    message.status = object.status ?? 0;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseGetUserWalletsRequest(): GetUserWalletsRequest {
  return { userId: "" };
}

export const GetUserWalletsRequest: MessageFns<GetUserWalletsRequest> = {
  encode(message: GetUserWalletsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserWalletsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserWalletsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserWalletsRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetUserWalletsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserWalletsRequest>, I>>(base?: I): GetUserWalletsRequest {
    return GetUserWalletsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserWalletsRequest>, I>>(object: I): GetUserWalletsRequest {
    const message = createBaseGetUserWalletsRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetUserWalletsResponse(): GetUserWalletsResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const GetUserWalletsResponse: MessageFns<GetUserWalletsResponse> = {
  encode(message: GetUserWalletsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      GetUserWalletsData.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserWalletsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserWalletsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = GetUserWalletsData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserWalletsResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? GetUserWalletsData.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: GetUserWalletsResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = GetUserWalletsData.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserWalletsResponse>, I>>(base?: I): GetUserWalletsResponse {
    return GetUserWalletsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserWalletsResponse>, I>>(object: I): GetUserWalletsResponse {
    const message = createBaseGetUserWalletsResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? GetUserWalletsData.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseGetUserWalletsData(): GetUserWalletsData {
  return { wallets: [], totalBalances: {} };
}

export const GetUserWalletsData: MessageFns<GetUserWalletsData> = {
  encode(message: GetUserWalletsData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.wallets) {
      Wallet.encode(v!, writer.uint32(10).fork()).join();
    }
    Object.entries(message.totalBalances).forEach(([key, value]) => {
      GetUserWalletsData_TotalBalancesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserWalletsData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserWalletsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.wallets.push(Wallet.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = GetUserWalletsData_TotalBalancesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.totalBalances[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserWalletsData {
    return {
      wallets: globalThis.Array.isArray(object?.wallets) ? object.wallets.map((e: any) => Wallet.fromJSON(e)) : [],
      totalBalances: isObject(object.totalBalances)
        ? Object.entries(object.totalBalances).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetUserWalletsData): unknown {
    const obj: any = {};
    if (message.wallets?.length) {
      obj.wallets = message.wallets.map((e) => Wallet.toJSON(e));
    }
    if (message.totalBalances) {
      const entries = Object.entries(message.totalBalances);
      if (entries.length > 0) {
        obj.totalBalances = {};
        entries.forEach(([k, v]) => {
          obj.totalBalances[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserWalletsData>, I>>(base?: I): GetUserWalletsData {
    return GetUserWalletsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserWalletsData>, I>>(object: I): GetUserWalletsData {
    const message = createBaseGetUserWalletsData();
    message.wallets = object.wallets?.map((e) => Wallet.fromPartial(e)) || [];
    message.totalBalances = Object.entries(object.totalBalances ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGetUserWalletsData_TotalBalancesEntry(): GetUserWalletsData_TotalBalancesEntry {
  return { key: "", value: 0 };
}

export const GetUserWalletsData_TotalBalancesEntry: MessageFns<GetUserWalletsData_TotalBalancesEntry> = {
  encode(message: GetUserWalletsData_TotalBalancesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserWalletsData_TotalBalancesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserWalletsData_TotalBalancesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserWalletsData_TotalBalancesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: GetUserWalletsData_TotalBalancesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserWalletsData_TotalBalancesEntry>, I>>(
    base?: I,
  ): GetUserWalletsData_TotalBalancesEntry {
    return GetUserWalletsData_TotalBalancesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserWalletsData_TotalBalancesEntry>, I>>(
    object: I,
  ): GetUserWalletsData_TotalBalancesEntry {
    const message = createBaseGetUserWalletsData_TotalBalancesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseAddCurrencyRequest(): AddCurrencyRequest {
  return { userId: "", currency: 0, amount: 0, reason: undefined };
}

export const AddCurrencyRequest: MessageFns<AddCurrencyRequest> = {
  encode(message: AddCurrencyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.currency !== 0) {
      writer.uint32(16).int32(message.currency);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.reason !== undefined) {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddCurrencyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddCurrencyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.currency = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddCurrencyRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      currency: isSet(object.currency) ? currencyTypeFromJSON(object.currency) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
    };
  },

  toJSON(message: AddCurrencyRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.currency !== 0) {
      obj.currency = currencyTypeToJSON(message.currency);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddCurrencyRequest>, I>>(base?: I): AddCurrencyRequest {
    return AddCurrencyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddCurrencyRequest>, I>>(object: I): AddCurrencyRequest {
    const message = createBaseAddCurrencyRequest();
    message.userId = object.userId ?? "";
    message.currency = object.currency ?? 0;
    message.amount = object.amount ?? 0;
    message.reason = object.reason ?? undefined;
    return message;
  },
};

function createBaseAddCurrencyResponse(): AddCurrencyResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const AddCurrencyResponse: MessageFns<AddCurrencyResponse> = {
  encode(message: AddCurrencyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      Wallet.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddCurrencyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddCurrencyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Wallet.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddCurrencyResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? Wallet.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: AddCurrencyResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = Wallet.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddCurrencyResponse>, I>>(base?: I): AddCurrencyResponse {
    return AddCurrencyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddCurrencyResponse>, I>>(object: I): AddCurrencyResponse {
    const message = createBaseAddCurrencyResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? Wallet.fromPartial(object.data) : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseSpendCurrencyRequest(): SpendCurrencyRequest {
  return { userId: "", currency: 0, amount: 0, reason: undefined };
}

export const SpendCurrencyRequest: MessageFns<SpendCurrencyRequest> = {
  encode(message: SpendCurrencyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.currency !== 0) {
      writer.uint32(16).int32(message.currency);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.reason !== undefined) {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpendCurrencyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpendCurrencyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.currency = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpendCurrencyRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      currency: isSet(object.currency) ? currencyTypeFromJSON(object.currency) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
    };
  },

  toJSON(message: SpendCurrencyRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.currency !== 0) {
      obj.currency = currencyTypeToJSON(message.currency);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpendCurrencyRequest>, I>>(base?: I): SpendCurrencyRequest {
    return SpendCurrencyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpendCurrencyRequest>, I>>(object: I): SpendCurrencyRequest {
    const message = createBaseSpendCurrencyRequest();
    message.userId = object.userId ?? "";
    message.currency = object.currency ?? 0;
    message.amount = object.amount ?? 0;
    message.reason = object.reason ?? undefined;
    return message;
  },
};

function createBaseSpendCurrencyResponse(): SpendCurrencyResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const SpendCurrencyResponse: MessageFns<SpendCurrencyResponse> = {
  encode(message: SpendCurrencyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      Wallet.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpendCurrencyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpendCurrencyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Wallet.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpendCurrencyResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? Wallet.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: SpendCurrencyResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = Wallet.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SpendCurrencyResponse>, I>>(base?: I): SpendCurrencyResponse {
    return SpendCurrencyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SpendCurrencyResponse>, I>>(object: I): SpendCurrencyResponse {
    const message = createBaseSpendCurrencyResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? Wallet.fromPartial(object.data) : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseRequestHelloNakama(): RequestHelloNakama {
  return { name: "" };
}

export const RequestHelloNakama: MessageFns<RequestHelloNakama> = {
  encode(message: RequestHelloNakama, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestHelloNakama {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestHelloNakama();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestHelloNakama {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: RequestHelloNakama): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestHelloNakama>, I>>(base?: I): RequestHelloNakama {
    return RequestHelloNakama.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestHelloNakama>, I>>(object: I): RequestHelloNakama {
    const message = createBaseRequestHelloNakama();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseResponseHelloNakama(): ResponseHelloNakama {
  return { message: "" };
}

export const ResponseHelloNakama: MessageFns<ResponseHelloNakama> = {
  encode(message: ResponseHelloNakama, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseHelloNakama {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseHelloNakama();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseHelloNakama {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: ResponseHelloNakama): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseHelloNakama>, I>>(base?: I): ResponseHelloNakama {
    return ResponseHelloNakama.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseHelloNakama>, I>>(object: I): ResponseHelloNakama {
    const message = createBaseResponseHelloNakama();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseRequestServerTime(): RequestServerTime {
  return { timezone: undefined };
}

export const RequestServerTime: MessageFns<RequestServerTime> = {
  encode(message: RequestServerTime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timezone !== undefined) {
      writer.uint32(10).string(message.timezone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestServerTime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestServerTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timezone = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestServerTime {
    return { timezone: isSet(object.timezone) ? globalThis.String(object.timezone) : undefined };
  },

  toJSON(message: RequestServerTime): unknown {
    const obj: any = {};
    if (message.timezone !== undefined) {
      obj.timezone = message.timezone;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestServerTime>, I>>(base?: I): RequestServerTime {
    return RequestServerTime.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestServerTime>, I>>(object: I): RequestServerTime {
    const message = createBaseRequestServerTime();
    message.timezone = object.timezone ?? undefined;
    return message;
  },
};

function createBaseResponseServerTime(): ResponseServerTime {
  return { timestampUtc: 0, isoTimeUtc: "", timezone: "", timestampLocal: 0, isoTimeLocal: "" };
}

export const ResponseServerTime: MessageFns<ResponseServerTime> = {
  encode(message: ResponseServerTime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestampUtc !== 0) {
      writer.uint32(8).int64(message.timestampUtc);
    }
    if (message.isoTimeUtc !== "") {
      writer.uint32(18).string(message.isoTimeUtc);
    }
    if (message.timezone !== "") {
      writer.uint32(26).string(message.timezone);
    }
    if (message.timestampLocal !== 0) {
      writer.uint32(32).int64(message.timestampLocal);
    }
    if (message.isoTimeLocal !== "") {
      writer.uint32(42).string(message.isoTimeLocal);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseServerTime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseServerTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestampUtc = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.isoTimeUtc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timezone = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timestampLocal = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.isoTimeLocal = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseServerTime {
    return {
      timestampUtc: isSet(object.timestampUtc) ? globalThis.Number(object.timestampUtc) : 0,
      isoTimeUtc: isSet(object.isoTimeUtc) ? globalThis.String(object.isoTimeUtc) : "",
      timezone: isSet(object.timezone) ? globalThis.String(object.timezone) : "",
      timestampLocal: isSet(object.timestampLocal) ? globalThis.Number(object.timestampLocal) : 0,
      isoTimeLocal: isSet(object.isoTimeLocal) ? globalThis.String(object.isoTimeLocal) : "",
    };
  },

  toJSON(message: ResponseServerTime): unknown {
    const obj: any = {};
    if (message.timestampUtc !== 0) {
      obj.timestampUtc = Math.round(message.timestampUtc);
    }
    if (message.isoTimeUtc !== "") {
      obj.isoTimeUtc = message.isoTimeUtc;
    }
    if (message.timezone !== "") {
      obj.timezone = message.timezone;
    }
    if (message.timestampLocal !== 0) {
      obj.timestampLocal = Math.round(message.timestampLocal);
    }
    if (message.isoTimeLocal !== "") {
      obj.isoTimeLocal = message.isoTimeLocal;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseServerTime>, I>>(base?: I): ResponseServerTime {
    return ResponseServerTime.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseServerTime>, I>>(object: I): ResponseServerTime {
    const message = createBaseResponseServerTime();
    message.timestampUtc = object.timestampUtc ?? 0;
    message.isoTimeUtc = object.isoTimeUtc ?? "";
    message.timezone = object.timezone ?? "";
    message.timestampLocal = object.timestampLocal ?? 0;
    message.isoTimeLocal = object.isoTimeLocal ?? "";
    return message;
  },
};

function createBaseGetCwUserIdByNkUserIdRequest(): GetCwUserIdByNkUserIdRequest {
  return { nkUserId: "" };
}

export const GetCwUserIdByNkUserIdRequest: MessageFns<GetCwUserIdByNkUserIdRequest> = {
  encode(message: GetCwUserIdByNkUserIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nkUserId !== "") {
      writer.uint32(10).string(message.nkUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCwUserIdByNkUserIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCwUserIdByNkUserIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nkUserId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCwUserIdByNkUserIdRequest {
    return { nkUserId: isSet(object.nkUserId) ? globalThis.String(object.nkUserId) : "" };
  },

  toJSON(message: GetCwUserIdByNkUserIdRequest): unknown {
    const obj: any = {};
    if (message.nkUserId !== "") {
      obj.nkUserId = message.nkUserId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCwUserIdByNkUserIdRequest>, I>>(base?: I): GetCwUserIdByNkUserIdRequest {
    return GetCwUserIdByNkUserIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCwUserIdByNkUserIdRequest>, I>>(object: I): GetCwUserIdByNkUserIdRequest {
    const message = createBaseGetCwUserIdByNkUserIdRequest();
    message.nkUserId = object.nkUserId ?? "";
    return message;
  },
};

function createBaseGetCwUserIdByNkUserIdResponse(): GetCwUserIdByNkUserIdResponse {
  return { cwUserId: "", nkUserId: "" };
}

export const GetCwUserIdByNkUserIdResponse: MessageFns<GetCwUserIdByNkUserIdResponse> = {
  encode(message: GetCwUserIdByNkUserIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cwUserId !== "") {
      writer.uint32(10).string(message.cwUserId);
    }
    if (message.nkUserId !== "") {
      writer.uint32(18).string(message.nkUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCwUserIdByNkUserIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCwUserIdByNkUserIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cwUserId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nkUserId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCwUserIdByNkUserIdResponse {
    return {
      cwUserId: isSet(object.cwUserId) ? globalThis.String(object.cwUserId) : "",
      nkUserId: isSet(object.nkUserId) ? globalThis.String(object.nkUserId) : "",
    };
  },

  toJSON(message: GetCwUserIdByNkUserIdResponse): unknown {
    const obj: any = {};
    if (message.cwUserId !== "") {
      obj.cwUserId = message.cwUserId;
    }
    if (message.nkUserId !== "") {
      obj.nkUserId = message.nkUserId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCwUserIdByNkUserIdResponse>, I>>(base?: I): GetCwUserIdByNkUserIdResponse {
    return GetCwUserIdByNkUserIdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCwUserIdByNkUserIdResponse>, I>>(
    object: I,
  ): GetCwUserIdByNkUserIdResponse {
    const message = createBaseGetCwUserIdByNkUserIdResponse();
    message.cwUserId = object.cwUserId ?? "";
    message.nkUserId = object.nkUserId ?? "";
    return message;
  },
};

function createBaseGetGlobalUserRankingRequest(): GetGlobalUserRankingRequest {
  return { page: undefined, userId: undefined };
}

export const GetGlobalUserRankingRequest: MessageFns<GetGlobalUserRankingRequest> = {
  encode(message: GetGlobalUserRankingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== undefined) {
      PageRequest.encode(message.page, writer.uint32(10).fork()).join();
    }
    if (message.userId !== undefined) {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGlobalUserRankingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGlobalUserRankingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.page = PageRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGlobalUserRankingRequest {
    return {
      page: isSet(object.page) ? PageRequest.fromJSON(object.page) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : undefined,
    };
  },

  toJSON(message: GetGlobalUserRankingRequest): unknown {
    const obj: any = {};
    if (message.page !== undefined) {
      obj.page = PageRequest.toJSON(message.page);
    }
    if (message.userId !== undefined) {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGlobalUserRankingRequest>, I>>(base?: I): GetGlobalUserRankingRequest {
    return GetGlobalUserRankingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGlobalUserRankingRequest>, I>>(object: I): GetGlobalUserRankingRequest {
    const message = createBaseGetGlobalUserRankingRequest();
    message.page = (object.page !== undefined && object.page !== null)
      ? PageRequest.fromPartial(object.page)
      : undefined;
    message.userId = object.userId ?? undefined;
    return message;
  },
};

function createBaseGetGlobalUserRankingResponse(): GetGlobalUserRankingResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const GetGlobalUserRankingResponse: MessageFns<GetGlobalUserRankingResponse> = {
  encode(message: GetGlobalUserRankingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      GetGlobalUserRankingData.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGlobalUserRankingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGlobalUserRankingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = GetGlobalUserRankingData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGlobalUserRankingResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? GetGlobalUserRankingData.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: GetGlobalUserRankingResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = GetGlobalUserRankingData.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGlobalUserRankingResponse>, I>>(base?: I): GetGlobalUserRankingResponse {
    return GetGlobalUserRankingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGlobalUserRankingResponse>, I>>(object: I): GetGlobalUserRankingResponse {
    const message = createBaseGetGlobalUserRankingResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? GetGlobalUserRankingData.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseGetGlobalUserRankingData(): GetGlobalUserRankingData {
  return { data: [], pagination: undefined, userRanking: undefined };
}

export const GetGlobalUserRankingData: MessageFns<GetGlobalUserRankingData> = {
  encode(message: GetGlobalUserRankingData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.data) {
      UserRankingData.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    if (message.userRanking !== undefined) {
      UserRankingData.encode(message.userRanking, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGlobalUserRankingData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGlobalUserRankingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data.push(UserRankingData.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userRanking = UserRankingData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGlobalUserRankingData {
    return {
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => UserRankingData.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
      userRanking: isSet(object.userRanking) ? UserRankingData.fromJSON(object.userRanking) : undefined,
    };
  },

  toJSON(message: GetGlobalUserRankingData): unknown {
    const obj: any = {};
    if (message.data?.length) {
      obj.data = message.data.map((e) => UserRankingData.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    if (message.userRanking !== undefined) {
      obj.userRanking = UserRankingData.toJSON(message.userRanking);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGlobalUserRankingData>, I>>(base?: I): GetGlobalUserRankingData {
    return GetGlobalUserRankingData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGlobalUserRankingData>, I>>(object: I): GetGlobalUserRankingData {
    const message = createBaseGetGlobalUserRankingData();
    message.data = object.data?.map((e) => UserRankingData.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    message.userRanking = (object.userRanking !== undefined && object.userRanking !== null)
      ? UserRankingData.fromPartial(object.userRanking)
      : undefined;
    return message;
  },
};

function createBaseUserRankingData(): UserRankingData {
  return {
    userId: "",
    username: "",
    displayName: "",
    avatarUrl: "",
    nkUserId: "",
    rank: 0,
    totalExp: 0,
    totalCharacterExp: 0,
    clanId: "",
    clanName: "",
    clanAvatarUrl: "",
    landId: "",
    landLevel: 0,
    landExp: 0,
    landSeasonType: "",
    characters: [],
    lastUpdatedAt: "",
  };
}

export const UserRankingData: MessageFns<UserRankingData> = {
  encode(message: UserRankingData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.avatarUrl !== "") {
      writer.uint32(34).string(message.avatarUrl);
    }
    if (message.nkUserId !== "") {
      writer.uint32(42).string(message.nkUserId);
    }
    if (message.rank !== 0) {
      writer.uint32(48).uint32(message.rank);
    }
    if (message.totalExp !== 0) {
      writer.uint32(56).uint64(message.totalExp);
    }
    if (message.totalCharacterExp !== 0) {
      writer.uint32(64).uint64(message.totalCharacterExp);
    }
    if (message.clanId !== "") {
      writer.uint32(74).string(message.clanId);
    }
    if (message.clanName !== "") {
      writer.uint32(82).string(message.clanName);
    }
    if (message.clanAvatarUrl !== "") {
      writer.uint32(90).string(message.clanAvatarUrl);
    }
    if (message.landId !== "") {
      writer.uint32(98).string(message.landId);
    }
    if (message.landLevel !== 0) {
      writer.uint32(104).uint32(message.landLevel);
    }
    if (message.landExp !== 0) {
      writer.uint32(112).uint64(message.landExp);
    }
    if (message.landSeasonType !== "") {
      writer.uint32(122).string(message.landSeasonType);
    }
    for (const v of message.characters) {
      CharacterRef.encode(v!, writer.uint32(130).fork()).join();
    }
    if (message.lastUpdatedAt !== "") {
      writer.uint32(138).string(message.lastUpdatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserRankingData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserRankingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nkUserId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalExp = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.totalCharacterExp = longToNumber(reader.uint64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.clanId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.clanName = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.clanAvatarUrl = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.landId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.landLevel = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.landExp = longToNumber(reader.uint64());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.landSeasonType = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.characters.push(CharacterRef.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.lastUpdatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserRankingData {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      avatarUrl: isSet(object.avatarUrl) ? globalThis.String(object.avatarUrl) : "",
      nkUserId: isSet(object.nkUserId) ? globalThis.String(object.nkUserId) : "",
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      totalExp: isSet(object.totalExp) ? globalThis.Number(object.totalExp) : 0,
      totalCharacterExp: isSet(object.totalCharacterExp) ? globalThis.Number(object.totalCharacterExp) : 0,
      clanId: isSet(object.clanId) ? globalThis.String(object.clanId) : "",
      clanName: isSet(object.clanName) ? globalThis.String(object.clanName) : "",
      clanAvatarUrl: isSet(object.clanAvatarUrl) ? globalThis.String(object.clanAvatarUrl) : "",
      landId: isSet(object.landId) ? globalThis.String(object.landId) : "",
      landLevel: isSet(object.landLevel) ? globalThis.Number(object.landLevel) : 0,
      landExp: isSet(object.landExp) ? globalThis.Number(object.landExp) : 0,
      landSeasonType: isSet(object.landSeasonType) ? globalThis.String(object.landSeasonType) : "",
      characters: globalThis.Array.isArray(object?.characters)
        ? object.characters.map((e: any) => CharacterRef.fromJSON(e))
        : [],
      lastUpdatedAt: isSet(object.lastUpdatedAt) ? globalThis.String(object.lastUpdatedAt) : "",
    };
  },

  toJSON(message: UserRankingData): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.avatarUrl !== "") {
      obj.avatarUrl = message.avatarUrl;
    }
    if (message.nkUserId !== "") {
      obj.nkUserId = message.nkUserId;
    }
    if (message.rank !== 0) {
      obj.rank = Math.round(message.rank);
    }
    if (message.totalExp !== 0) {
      obj.totalExp = Math.round(message.totalExp);
    }
    if (message.totalCharacterExp !== 0) {
      obj.totalCharacterExp = Math.round(message.totalCharacterExp);
    }
    if (message.clanId !== "") {
      obj.clanId = message.clanId;
    }
    if (message.clanName !== "") {
      obj.clanName = message.clanName;
    }
    if (message.clanAvatarUrl !== "") {
      obj.clanAvatarUrl = message.clanAvatarUrl;
    }
    if (message.landId !== "") {
      obj.landId = message.landId;
    }
    if (message.landLevel !== 0) {
      obj.landLevel = Math.round(message.landLevel);
    }
    if (message.landExp !== 0) {
      obj.landExp = Math.round(message.landExp);
    }
    if (message.landSeasonType !== "") {
      obj.landSeasonType = message.landSeasonType;
    }
    if (message.characters?.length) {
      obj.characters = message.characters.map((e) => CharacterRef.toJSON(e));
    }
    if (message.lastUpdatedAt !== "") {
      obj.lastUpdatedAt = message.lastUpdatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserRankingData>, I>>(base?: I): UserRankingData {
    return UserRankingData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserRankingData>, I>>(object: I): UserRankingData {
    const message = createBaseUserRankingData();
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.displayName = object.displayName ?? "";
    message.avatarUrl = object.avatarUrl ?? "";
    message.nkUserId = object.nkUserId ?? "";
    message.rank = object.rank ?? 0;
    message.totalExp = object.totalExp ?? 0;
    message.totalCharacterExp = object.totalCharacterExp ?? 0;
    message.clanId = object.clanId ?? "";
    message.clanName = object.clanName ?? "";
    message.clanAvatarUrl = object.clanAvatarUrl ?? "";
    message.landId = object.landId ?? "";
    message.landLevel = object.landLevel ?? 0;
    message.landExp = object.landExp ?? 0;
    message.landSeasonType = object.landSeasonType ?? "";
    message.characters = object.characters?.map((e) => CharacterRef.fromPartial(e)) || [];
    message.lastUpdatedAt = object.lastUpdatedAt ?? "";
    return message;
  },
};

function createBaseGetGlobalLandRankingRequest(): GetGlobalLandRankingRequest {
  return { page: undefined, userId: undefined };
}

export const GetGlobalLandRankingRequest: MessageFns<GetGlobalLandRankingRequest> = {
  encode(message: GetGlobalLandRankingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== undefined) {
      PageRequest.encode(message.page, writer.uint32(10).fork()).join();
    }
    if (message.userId !== undefined) {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGlobalLandRankingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGlobalLandRankingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.page = PageRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGlobalLandRankingRequest {
    return {
      page: isSet(object.page) ? PageRequest.fromJSON(object.page) : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : undefined,
    };
  },

  toJSON(message: GetGlobalLandRankingRequest): unknown {
    const obj: any = {};
    if (message.page !== undefined) {
      obj.page = PageRequest.toJSON(message.page);
    }
    if (message.userId !== undefined) {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGlobalLandRankingRequest>, I>>(base?: I): GetGlobalLandRankingRequest {
    return GetGlobalLandRankingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGlobalLandRankingRequest>, I>>(object: I): GetGlobalLandRankingRequest {
    const message = createBaseGetGlobalLandRankingRequest();
    message.page = (object.page !== undefined && object.page !== null)
      ? PageRequest.fromPartial(object.page)
      : undefined;
    message.userId = object.userId ?? undefined;
    return message;
  },
};

function createBaseGetGlobalLandRankingResponse(): GetGlobalLandRankingResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const GetGlobalLandRankingResponse: MessageFns<GetGlobalLandRankingResponse> = {
  encode(message: GetGlobalLandRankingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      GetGlobalLandRankingData.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGlobalLandRankingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGlobalLandRankingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = GetGlobalLandRankingData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGlobalLandRankingResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? GetGlobalLandRankingData.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: GetGlobalLandRankingResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = GetGlobalLandRankingData.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGlobalLandRankingResponse>, I>>(base?: I): GetGlobalLandRankingResponse {
    return GetGlobalLandRankingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGlobalLandRankingResponse>, I>>(object: I): GetGlobalLandRankingResponse {
    const message = createBaseGetGlobalLandRankingResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? GetGlobalLandRankingData.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseGetGlobalLandRankingData(): GetGlobalLandRankingData {
  return { data: [], pagination: undefined, userRanking: undefined };
}

export const GetGlobalLandRankingData: MessageFns<GetGlobalLandRankingData> = {
  encode(message: GetGlobalLandRankingData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.data) {
      LandRankingData.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    if (message.userRanking !== undefined) {
      LandRankingData.encode(message.userRanking, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGlobalLandRankingData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGlobalLandRankingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data.push(LandRankingData.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userRanking = LandRankingData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGlobalLandRankingData {
    return {
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => LandRankingData.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
      userRanking: isSet(object.userRanking) ? LandRankingData.fromJSON(object.userRanking) : undefined,
    };
  },

  toJSON(message: GetGlobalLandRankingData): unknown {
    const obj: any = {};
    if (message.data?.length) {
      obj.data = message.data.map((e) => LandRankingData.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    if (message.userRanking !== undefined) {
      obj.userRanking = LandRankingData.toJSON(message.userRanking);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGlobalLandRankingData>, I>>(base?: I): GetGlobalLandRankingData {
    return GetGlobalLandRankingData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGlobalLandRankingData>, I>>(object: I): GetGlobalLandRankingData {
    const message = createBaseGetGlobalLandRankingData();
    message.data = object.data?.map((e) => LandRankingData.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    message.userRanking = (object.userRanking !== undefined && object.userRanking !== null)
      ? LandRankingData.fromPartial(object.userRanking)
      : undefined;
    return message;
  },
};

function createBaseLandRankingData(): LandRankingData {
  return {
    userId: "",
    username: "",
    displayName: "",
    avatarUrl: "",
    nkUserId: "",
    rank: 0,
    landId: "",
    landLevel: 0,
    landExp: 0,
    landSeasonType: "",
    lastUpdatedAt: "",
  };
}

export const LandRankingData: MessageFns<LandRankingData> = {
  encode(message: LandRankingData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.avatarUrl !== "") {
      writer.uint32(34).string(message.avatarUrl);
    }
    if (message.nkUserId !== "") {
      writer.uint32(42).string(message.nkUserId);
    }
    if (message.rank !== 0) {
      writer.uint32(48).uint32(message.rank);
    }
    if (message.landId !== "") {
      writer.uint32(58).string(message.landId);
    }
    if (message.landLevel !== 0) {
      writer.uint32(64).uint32(message.landLevel);
    }
    if (message.landExp !== 0) {
      writer.uint32(72).uint64(message.landExp);
    }
    if (message.landSeasonType !== "") {
      writer.uint32(82).string(message.landSeasonType);
    }
    if (message.lastUpdatedAt !== "") {
      writer.uint32(90).string(message.lastUpdatedAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LandRankingData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLandRankingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.nkUserId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.rank = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.landId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.landLevel = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.landExp = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.landSeasonType = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.lastUpdatedAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LandRankingData {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      avatarUrl: isSet(object.avatarUrl) ? globalThis.String(object.avatarUrl) : "",
      nkUserId: isSet(object.nkUserId) ? globalThis.String(object.nkUserId) : "",
      rank: isSet(object.rank) ? globalThis.Number(object.rank) : 0,
      landId: isSet(object.landId) ? globalThis.String(object.landId) : "",
      landLevel: isSet(object.landLevel) ? globalThis.Number(object.landLevel) : 0,
      landExp: isSet(object.landExp) ? globalThis.Number(object.landExp) : 0,
      landSeasonType: isSet(object.landSeasonType) ? globalThis.String(object.landSeasonType) : "",
      lastUpdatedAt: isSet(object.lastUpdatedAt) ? globalThis.String(object.lastUpdatedAt) : "",
    };
  },

  toJSON(message: LandRankingData): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.avatarUrl !== "") {
      obj.avatarUrl = message.avatarUrl;
    }
    if (message.nkUserId !== "") {
      obj.nkUserId = message.nkUserId;
    }
    if (message.rank !== 0) {
      obj.rank = Math.round(message.rank);
    }
    if (message.landId !== "") {
      obj.landId = message.landId;
    }
    if (message.landLevel !== 0) {
      obj.landLevel = Math.round(message.landLevel);
    }
    if (message.landExp !== 0) {
      obj.landExp = Math.round(message.landExp);
    }
    if (message.landSeasonType !== "") {
      obj.landSeasonType = message.landSeasonType;
    }
    if (message.lastUpdatedAt !== "") {
      obj.lastUpdatedAt = message.lastUpdatedAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LandRankingData>, I>>(base?: I): LandRankingData {
    return LandRankingData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LandRankingData>, I>>(object: I): LandRankingData {
    const message = createBaseLandRankingData();
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.displayName = object.displayName ?? "";
    message.avatarUrl = object.avatarUrl ?? "";
    message.nkUserId = object.nkUserId ?? "";
    message.rank = object.rank ?? 0;
    message.landId = object.landId ?? "";
    message.landLevel = object.landLevel ?? 0;
    message.landExp = object.landExp ?? 0;
    message.landSeasonType = object.landSeasonType ?? "";
    message.lastUpdatedAt = object.lastUpdatedAt ?? "";
    return message;
  },
};

function createBaseRequestHello(): RequestHello {
  return { name: "" };
}

export const RequestHello: MessageFns<RequestHello> = {
  encode(message: RequestHello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestHello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestHello {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: RequestHello): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestHello>, I>>(base?: I): RequestHello {
    return RequestHello.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestHello>, I>>(object: I): RequestHello {
    const message = createBaseRequestHello();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseResponseHello(): ResponseHello {
  return { message: "" };
}

export const ResponseHello: MessageFns<ResponseHello> = {
  encode(message: ResponseHello, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseHello {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseHello();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseHello {
    return { message: isSet(object.message) ? globalThis.String(object.message) : "" };
  },

  toJSON(message: ResponseHello): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseHello>, I>>(base?: I): ResponseHello {
    return ResponseHello.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseHello>, I>>(object: I): ResponseHello {
    const message = createBaseResponseHello();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseResponseCommon(): ResponseCommon {
  return { code: 0, message: "" };
}

export const ResponseCommon: MessageFns<ResponseCommon> = {
  encode(message: ResponseCommon, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseCommon {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseCommon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseCommon {
    return {
      code: isSet(object.code) ? globalThis.Number(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ResponseCommon): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = Math.round(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseCommon>, I>>(base?: I): ResponseCommon {
    return ResponseCommon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseCommon>, I>>(object: I): ResponseCommon {
    const message = createBaseResponseCommon();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseRequestSyncAccount(): RequestSyncAccount {
  return {
    accountId: "",
    fullName: "",
    deviceId: "",
    username: "",
    password: "",
    displayName: undefined,
    avatarUrl: undefined,
    langTag: undefined,
    location: undefined,
    timezone: undefined,
  };
}

export const RequestSyncAccount: MessageFns<RequestSyncAccount> = {
  encode(message: RequestSyncAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.fullName !== "") {
      writer.uint32(18).string(message.fullName);
    }
    if (message.deviceId !== "") {
      writer.uint32(26).string(message.deviceId);
    }
    if (message.username !== "") {
      writer.uint32(34).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(42).string(message.password);
    }
    if (message.displayName !== undefined) {
      writer.uint32(50).string(message.displayName);
    }
    if (message.avatarUrl !== undefined) {
      writer.uint32(58).string(message.avatarUrl);
    }
    if (message.langTag !== undefined) {
      writer.uint32(66).string(message.langTag);
    }
    if (message.location !== undefined) {
      writer.uint32(74).string(message.location);
    }
    if (message.timezone !== undefined) {
      writer.uint32(82).string(message.timezone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestSyncAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestSyncAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fullName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.langTag = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.timezone = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestSyncAccount {
    return {
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      fullName: isSet(object.fullName) ? globalThis.String(object.fullName) : "",
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : undefined,
      avatarUrl: isSet(object.avatarUrl) ? globalThis.String(object.avatarUrl) : undefined,
      langTag: isSet(object.langTag) ? globalThis.String(object.langTag) : undefined,
      location: isSet(object.location) ? globalThis.String(object.location) : undefined,
      timezone: isSet(object.timezone) ? globalThis.String(object.timezone) : undefined,
    };
  },

  toJSON(message: RequestSyncAccount): unknown {
    const obj: any = {};
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.fullName !== "") {
      obj.fullName = message.fullName;
    }
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.displayName !== undefined) {
      obj.displayName = message.displayName;
    }
    if (message.avatarUrl !== undefined) {
      obj.avatarUrl = message.avatarUrl;
    }
    if (message.langTag !== undefined) {
      obj.langTag = message.langTag;
    }
    if (message.location !== undefined) {
      obj.location = message.location;
    }
    if (message.timezone !== undefined) {
      obj.timezone = message.timezone;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestSyncAccount>, I>>(base?: I): RequestSyncAccount {
    return RequestSyncAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestSyncAccount>, I>>(object: I): RequestSyncAccount {
    const message = createBaseRequestSyncAccount();
    message.accountId = object.accountId ?? "";
    message.fullName = object.fullName ?? "";
    message.deviceId = object.deviceId ?? "";
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.displayName = object.displayName ?? undefined;
    message.avatarUrl = object.avatarUrl ?? undefined;
    message.langTag = object.langTag ?? undefined;
    message.location = object.location ?? undefined;
    message.timezone = object.timezone ?? undefined;
    return message;
  },
};

function createBaseResponseSyncAccount(): ResponseSyncAccount {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const ResponseSyncAccount: MessageFns<ResponseSyncAccount> = {
  encode(message: ResponseSyncAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseSyncAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseSyncAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseSyncAccount {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isObject(object.data) ? object.data : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ResponseSyncAccount): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseSyncAccount>, I>>(base?: I): ResponseSyncAccount {
    return ResponseSyncAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseSyncAccount>, I>>(object: I): ResponseSyncAccount {
    const message = createBaseResponseSyncAccount();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = object.data ?? undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseGetAccountByUsernameRequest(): GetAccountByUsernameRequest {
  return { username: "" };
}

export const GetAccountByUsernameRequest: MessageFns<GetAccountByUsernameRequest> = {
  encode(message: GetAccountByUsernameRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAccountByUsernameRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAccountByUsernameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAccountByUsernameRequest {
    return { username: isSet(object.username) ? globalThis.String(object.username) : "" };
  },

  toJSON(message: GetAccountByUsernameRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAccountByUsernameRequest>, I>>(base?: I): GetAccountByUsernameRequest {
    return GetAccountByUsernameRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAccountByUsernameRequest>, I>>(object: I): GetAccountByUsernameRequest {
    const message = createBaseGetAccountByUsernameRequest();
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseGetAccountByUsernameResponse(): GetAccountByUsernameResponse {
  return { status: undefined, error: undefined, metadata: undefined, user: undefined };
}

export const GetAccountByUsernameResponse: MessageFns<GetAccountByUsernameResponse> = {
  encode(message: GetAccountByUsernameResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAccountByUsernameResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAccountByUsernameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAccountByUsernameResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: GetAccountByUsernameResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAccountByUsernameResponse>, I>>(base?: I): GetAccountByUsernameResponse {
    return GetAccountByUsernameResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAccountByUsernameResponse>, I>>(object: I): GetAccountByUsernameResponse {
    const message = createBaseGetAccountByUsernameResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseUpdateAccountRequest(): UpdateAccountRequest {
  return { username: "", displayName: "", avatarUrl: "", langTag: "", location: "", timezone: "" };
}

export const UpdateAccountRequest: MessageFns<UpdateAccountRequest> = {
  encode(message: UpdateAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.avatarUrl !== "") {
      writer.uint32(26).string(message.avatarUrl);
    }
    if (message.langTag !== "") {
      writer.uint32(34).string(message.langTag);
    }
    if (message.location !== "") {
      writer.uint32(42).string(message.location);
    }
    if (message.timezone !== "") {
      writer.uint32(50).string(message.timezone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.langTag = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timezone = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAccountRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      avatarUrl: isSet(object.avatarUrl) ? globalThis.String(object.avatarUrl) : "",
      langTag: isSet(object.langTag) ? globalThis.String(object.langTag) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      timezone: isSet(object.timezone) ? globalThis.String(object.timezone) : "",
    };
  },

  toJSON(message: UpdateAccountRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.avatarUrl !== "") {
      obj.avatarUrl = message.avatarUrl;
    }
    if (message.langTag !== "") {
      obj.langTag = message.langTag;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.timezone !== "") {
      obj.timezone = message.timezone;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateAccountRequest>, I>>(base?: I): UpdateAccountRequest {
    return UpdateAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateAccountRequest>, I>>(object: I): UpdateAccountRequest {
    const message = createBaseUpdateAccountRequest();
    message.username = object.username ?? "";
    message.displayName = object.displayName ?? "";
    message.avatarUrl = object.avatarUrl ?? "";
    message.langTag = object.langTag ?? "";
    message.location = object.location ?? "";
    message.timezone = object.timezone ?? "";
    return message;
  },
};

function createBaseUpdateAccountResponse(): UpdateAccountResponse {
  return { response: undefined };
}

export const UpdateAccountResponse: MessageFns<UpdateAccountResponse> = {
  encode(message: UpdateAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      CommonResponse.encode(message.response, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = CommonResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAccountResponse {
    return { response: isSet(object.response) ? CommonResponse.fromJSON(object.response) : undefined };
  },

  toJSON(message: UpdateAccountResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = CommonResponse.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateAccountResponse>, I>>(base?: I): UpdateAccountResponse {
    return UpdateAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateAccountResponse>, I>>(object: I): UpdateAccountResponse {
    const message = createBaseUpdateAccountResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? CommonResponse.fromPartial(object.response)
      : undefined;
    return message;
  },
};

function createBaseRegisterAccountRequest(): RegisterAccountRequest {
  return {
    username: "",
    password: "",
    nkAccountId: undefined,
    displayName: undefined,
    email: undefined,
    phoneNumber: undefined,
  };
}

export const RegisterAccountRequest: MessageFns<RegisterAccountRequest> = {
  encode(message: RegisterAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.nkAccountId !== undefined) {
      writer.uint32(26).string(message.nkAccountId);
    }
    if (message.displayName !== undefined) {
      writer.uint32(34).string(message.displayName);
    }
    if (message.email !== undefined) {
      writer.uint32(42).string(message.email);
    }
    if (message.phoneNumber !== undefined) {
      writer.uint32(50).string(message.phoneNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nkAccountId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterAccountRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      nkAccountId: isSet(object.nkAccountId) ? globalThis.String(object.nkAccountId) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : undefined,
    };
  },

  toJSON(message: RegisterAccountRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.nkAccountId !== undefined) {
      obj.nkAccountId = message.nkAccountId;
    }
    if (message.displayName !== undefined) {
      obj.displayName = message.displayName;
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.phoneNumber !== undefined) {
      obj.phoneNumber = message.phoneNumber;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterAccountRequest>, I>>(base?: I): RegisterAccountRequest {
    return RegisterAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterAccountRequest>, I>>(object: I): RegisterAccountRequest {
    const message = createBaseRegisterAccountRequest();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.nkAccountId = object.nkAccountId ?? undefined;
    message.displayName = object.displayName ?? undefined;
    message.email = object.email ?? undefined;
    message.phoneNumber = object.phoneNumber ?? undefined;
    return message;
  },
};

function createBaseAuthenticateAccountRequest(): AuthenticateAccountRequest {
  return { username: "", password: "", nkAccountId: undefined };
}

export const AuthenticateAccountRequest: MessageFns<AuthenticateAccountRequest> = {
  encode(message: AuthenticateAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.nkAccountId !== undefined) {
      writer.uint32(26).string(message.nkAccountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticateAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nkAccountId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateAccountRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      nkAccountId: isSet(object.nkAccountId) ? globalThis.String(object.nkAccountId) : undefined,
    };
  },

  toJSON(message: AuthenticateAccountRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.nkAccountId !== undefined) {
      obj.nkAccountId = message.nkAccountId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateAccountRequest>, I>>(base?: I): AuthenticateAccountRequest {
    return AuthenticateAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateAccountRequest>, I>>(object: I): AuthenticateAccountRequest {
    const message = createBaseAuthenticateAccountRequest();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.nkAccountId = object.nkAccountId ?? undefined;
    return message;
  },
};

function createBaseAuthenticateAccountData(): AuthenticateAccountData {
  return { user: undefined, accessToken: "", refreshToken: "", expiresIn: "" };
}

export const AuthenticateAccountData: MessageFns<AuthenticateAccountData> = {
  encode(message: AuthenticateAccountData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(26).string(message.refreshToken);
    }
    if (message.expiresIn !== "") {
      writer.uint32(34).string(message.expiresIn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticateAccountData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateAccountData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.expiresIn = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateAccountData {
    return {
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      expiresIn: isSet(object.expiresIn) ? globalThis.String(object.expiresIn) : "",
    };
  },

  toJSON(message: AuthenticateAccountData): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.expiresIn !== "") {
      obj.expiresIn = message.expiresIn;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateAccountData>, I>>(base?: I): AuthenticateAccountData {
    return AuthenticateAccountData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateAccountData>, I>>(object: I): AuthenticateAccountData {
    const message = createBaseAuthenticateAccountData();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.expiresIn = object.expiresIn ?? "";
    return message;
  },
};

function createBaseAuthenticateAccountResponse(): AuthenticateAccountResponse {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const AuthenticateAccountResponse: MessageFns<AuthenticateAccountResponse> = {
  encode(message: AuthenticateAccountResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      AuthenticateAccountData.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticateAccountResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticateAccountResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = AuthenticateAccountData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticateAccountResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? AuthenticateAccountData.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: AuthenticateAccountResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = AuthenticateAccountData.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticateAccountResponse>, I>>(base?: I): AuthenticateAccountResponse {
    return AuthenticateAccountResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticateAccountResponse>, I>>(object: I): AuthenticateAccountResponse {
    const message = createBaseAuthenticateAccountResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? AuthenticateAccountData.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseGetProfileRequest(): GetProfileRequest {
  return { userId: "" };
}

export const GetProfileRequest: MessageFns<GetProfileRequest> = {
  encode(message: GetProfileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProfileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProfileRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetProfileRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProfileRequest>, I>>(base?: I): GetProfileRequest {
    return GetProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProfileRequest>, I>>(object: I): GetProfileRequest {
    const message = createBaseGetProfileRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetProfileResponse(): GetProfileResponse {
  return { status: undefined, error: undefined, metadata: undefined, data: undefined };
}

export const GetProfileResponse: MessageFns<GetProfileResponse> = {
  encode(message: GetProfileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.data !== undefined) {
      UserProfile.encode(message.data, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProfileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProfileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = UserProfile.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProfileResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
      data: isSet(object.data) ? UserProfile.fromJSON(object.data) : undefined,
    };
  },

  toJSON(message: GetProfileResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    if (message.data !== undefined) {
      obj.data = UserProfile.toJSON(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProfileResponse>, I>>(base?: I): GetProfileResponse {
    return GetProfileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProfileResponse>, I>>(object: I): GetProfileResponse {
    const message = createBaseGetProfileResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? UserProfile.fromPartial(object.data)
      : undefined;
    return message;
  },
};

function createBaseGetChestInfoRequest(): GetChestInfoRequest {
  return {};
}

export const GetChestInfoRequest: MessageFns<GetChestInfoRequest> = {
  encode(_: GetChestInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChestInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChestInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetChestInfoRequest {
    return {};
  },

  toJSON(_: GetChestInfoRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChestInfoRequest>, I>>(base?: I): GetChestInfoRequest {
    return GetChestInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChestInfoRequest>, I>>(_: I): GetChestInfoRequest {
    const message = createBaseGetChestInfoRequest();
    return message;
  },
};

function createBaseChestInfo(): ChestInfo {
  return {
    id: "",
    type: 0,
    name: "",
    description: "",
    iconUrl: "",
    requiredItems: [],
    rewardItems: [],
    rewardCharacters: [],
    price: 0,
    currencyType: 0,
    discountPrice: 0,
  };
}

export const ChestInfo: MessageFns<ChestInfo> = {
  encode(message: ChestInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.iconUrl !== "") {
      writer.uint32(42).string(message.iconUrl);
    }
    for (const v of message.requiredItems) {
      ItemRef.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.rewardItems) {
      ItemRef.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.rewardCharacters) {
      CharacterRef.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.price !== 0) {
      writer.uint32(72).int64(message.price);
    }
    if (message.currencyType !== 0) {
      writer.uint32(80).int32(message.currencyType);
    }
    if (message.discountPrice !== 0) {
      writer.uint32(88).int64(message.discountPrice);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChestInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChestInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.iconUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.requiredItems.push(ItemRef.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rewardItems.push(ItemRef.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.rewardCharacters.push(CharacterRef.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.price = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.currencyType = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.discountPrice = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChestInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? chestTypeFromJSON(object.type) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      iconUrl: isSet(object.iconUrl) ? globalThis.String(object.iconUrl) : "",
      requiredItems: globalThis.Array.isArray(object?.requiredItems)
        ? object.requiredItems.map((e: any) => ItemRef.fromJSON(e))
        : [],
      rewardItems: globalThis.Array.isArray(object?.rewardItems)
        ? object.rewardItems.map((e: any) => ItemRef.fromJSON(e))
        : [],
      rewardCharacters: globalThis.Array.isArray(object?.rewardCharacters)
        ? object.rewardCharacters.map((e: any) => CharacterRef.fromJSON(e))
        : [],
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      currencyType: isSet(object.currencyType) ? currencyTypeFromJSON(object.currencyType) : 0,
      discountPrice: isSet(object.discountPrice) ? globalThis.Number(object.discountPrice) : 0,
    };
  },

  toJSON(message: ChestInfo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== 0) {
      obj.type = chestTypeToJSON(message.type);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.iconUrl !== "") {
      obj.iconUrl = message.iconUrl;
    }
    if (message.requiredItems?.length) {
      obj.requiredItems = message.requiredItems.map((e) => ItemRef.toJSON(e));
    }
    if (message.rewardItems?.length) {
      obj.rewardItems = message.rewardItems.map((e) => ItemRef.toJSON(e));
    }
    if (message.rewardCharacters?.length) {
      obj.rewardCharacters = message.rewardCharacters.map((e) => CharacterRef.toJSON(e));
    }
    if (message.price !== 0) {
      obj.price = Math.round(message.price);
    }
    if (message.currencyType !== 0) {
      obj.currencyType = currencyTypeToJSON(message.currencyType);
    }
    if (message.discountPrice !== 0) {
      obj.discountPrice = Math.round(message.discountPrice);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChestInfo>, I>>(base?: I): ChestInfo {
    return ChestInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChestInfo>, I>>(object: I): ChestInfo {
    const message = createBaseChestInfo();
    message.id = object.id ?? "";
    message.type = object.type ?? 0;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.iconUrl = object.iconUrl ?? "";
    message.requiredItems = object.requiredItems?.map((e) => ItemRef.fromPartial(e)) || [];
    message.rewardItems = object.rewardItems?.map((e) => ItemRef.fromPartial(e)) || [];
    message.rewardCharacters = object.rewardCharacters?.map((e) => CharacterRef.fromPartial(e)) || [];
    message.price = object.price ?? 0;
    message.currencyType = object.currencyType ?? 0;
    message.discountPrice = object.discountPrice ?? 0;
    return message;
  },
};

function createBaseGetChestInfoResponse(): GetChestInfoResponse {
  return { status: undefined, error: undefined, metadata: undefined, data: [] };
}

export const GetChestInfoResponse: MessageFns<GetChestInfoResponse> = {
  encode(message: GetChestInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    for (const v of message.data) {
      ChestInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChestInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChestInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data.push(ChestInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChestInfoResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => ChestInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetChestInfoResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => ChestInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChestInfoResponse>, I>>(base?: I): GetChestInfoResponse {
    return GetChestInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChestInfoResponse>, I>>(object: I): GetChestInfoResponse {
    const message = createBaseGetChestInfoResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    message.data = object.data?.map((e) => ChestInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLandCellInfo(): LandCellInfo {
  return {
    cellId: "",
    timePlanted: undefined,
    state: 0,
    numberOfPlantedSeeds: 0,
    cellStatus: 0,
    cellNumber: 0,
    plantDurationS: 0,
    gainedExp: 0,
    stolenAmount: undefined,
    lastStolenAt: undefined,
  };
}

export const LandCellInfo: MessageFns<LandCellInfo> = {
  encode(message: LandCellInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cellId !== "") {
      writer.uint32(10).string(message.cellId);
    }
    if (message.timePlanted !== undefined) {
      writer.uint32(18).string(message.timePlanted);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.numberOfPlantedSeeds !== 0) {
      writer.uint32(32).uint32(message.numberOfPlantedSeeds);
    }
    if (message.cellStatus !== 0) {
      writer.uint32(40).int32(message.cellStatus);
    }
    if (message.cellNumber !== 0) {
      writer.uint32(48).uint32(message.cellNumber);
    }
    if (message.plantDurationS !== 0) {
      writer.uint32(56).uint32(message.plantDurationS);
    }
    if (message.gainedExp !== 0) {
      writer.uint32(64).uint32(message.gainedExp);
    }
    if (message.stolenAmount !== undefined) {
      writer.uint32(72).uint32(message.stolenAmount);
    }
    if (message.lastStolenAt !== undefined) {
      writer.uint32(82).string(message.lastStolenAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LandCellInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLandCellInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cellId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timePlanted = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.numberOfPlantedSeeds = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.cellStatus = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.cellNumber = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.plantDurationS = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.gainedExp = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.stolenAmount = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.lastStolenAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LandCellInfo {
    return {
      cellId: isSet(object.cellId) ? globalThis.String(object.cellId) : "",
      timePlanted: isSet(object.timePlanted) ? globalThis.String(object.timePlanted) : undefined,
      state: isSet(object.state) ? landCellStateFromJSON(object.state) : 0,
      numberOfPlantedSeeds: isSet(object.numberOfPlantedSeeds) ? globalThis.Number(object.numberOfPlantedSeeds) : 0,
      cellStatus: isSet(object.cellStatus) ? landCellStatusFromJSON(object.cellStatus) : 0,
      cellNumber: isSet(object.cellNumber) ? globalThis.Number(object.cellNumber) : 0,
      plantDurationS: isSet(object.plantDurationS) ? globalThis.Number(object.plantDurationS) : 0,
      gainedExp: isSet(object.gainedExp) ? globalThis.Number(object.gainedExp) : 0,
      stolenAmount: isSet(object.stolenAmount) ? globalThis.Number(object.stolenAmount) : undefined,
      lastStolenAt: isSet(object.lastStolenAt) ? globalThis.String(object.lastStolenAt) : undefined,
    };
  },

  toJSON(message: LandCellInfo): unknown {
    const obj: any = {};
    if (message.cellId !== "") {
      obj.cellId = message.cellId;
    }
    if (message.timePlanted !== undefined) {
      obj.timePlanted = message.timePlanted;
    }
    if (message.state !== 0) {
      obj.state = landCellStateToJSON(message.state);
    }
    if (message.numberOfPlantedSeeds !== 0) {
      obj.numberOfPlantedSeeds = Math.round(message.numberOfPlantedSeeds);
    }
    if (message.cellStatus !== 0) {
      obj.cellStatus = landCellStatusToJSON(message.cellStatus);
    }
    if (message.cellNumber !== 0) {
      obj.cellNumber = Math.round(message.cellNumber);
    }
    if (message.plantDurationS !== 0) {
      obj.plantDurationS = Math.round(message.plantDurationS);
    }
    if (message.gainedExp !== 0) {
      obj.gainedExp = Math.round(message.gainedExp);
    }
    if (message.stolenAmount !== undefined) {
      obj.stolenAmount = Math.round(message.stolenAmount);
    }
    if (message.lastStolenAt !== undefined) {
      obj.lastStolenAt = message.lastStolenAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LandCellInfo>, I>>(base?: I): LandCellInfo {
    return LandCellInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LandCellInfo>, I>>(object: I): LandCellInfo {
    const message = createBaseLandCellInfo();
    message.cellId = object.cellId ?? "";
    message.timePlanted = object.timePlanted ?? undefined;
    message.state = object.state ?? 0;
    message.numberOfPlantedSeeds = object.numberOfPlantedSeeds ?? 0;
    message.cellStatus = object.cellStatus ?? 0;
    message.cellNumber = object.cellNumber ?? 0;
    message.plantDurationS = object.plantDurationS ?? 0;
    message.gainedExp = object.gainedExp ?? 0;
    message.stolenAmount = object.stolenAmount ?? undefined;
    message.lastStolenAt = object.lastStolenAt ?? undefined;
    return message;
  },
};

function createBaseLandInfo(): LandInfo {
  return {
    landCells: [],
    landLevel: 0,
    eXP: 0,
    eXPToNextLevel: 0,
    coinFeeToNextLevel: 0,
    weatherType: 0,
    seasonType: 0,
    numberOfSeedPerCell: 0,
    grassAmount: 0,
    seedAmount: 0,
  };
}

export const LandInfo: MessageFns<LandInfo> = {
  encode(message: LandInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.landCells) {
      LandCellInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.landLevel !== 0) {
      writer.uint32(16).uint32(message.landLevel);
    }
    if (message.eXP !== 0) {
      writer.uint32(24).uint32(message.eXP);
    }
    if (message.eXPToNextLevel !== 0) {
      writer.uint32(32).uint32(message.eXPToNextLevel);
    }
    if (message.coinFeeToNextLevel !== 0) {
      writer.uint32(40).uint32(message.coinFeeToNextLevel);
    }
    if (message.weatherType !== 0) {
      writer.uint32(48).int32(message.weatherType);
    }
    if (message.seasonType !== 0) {
      writer.uint32(56).int32(message.seasonType);
    }
    if (message.numberOfSeedPerCell !== 0) {
      writer.uint32(64).uint32(message.numberOfSeedPerCell);
    }
    if (message.grassAmount !== 0) {
      writer.uint32(72).uint32(message.grassAmount);
    }
    if (message.seedAmount !== 0) {
      writer.uint32(80).uint32(message.seedAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LandInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLandInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.landCells.push(LandCellInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.landLevel = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.eXP = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.eXPToNextLevel = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.coinFeeToNextLevel = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.weatherType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.seasonType = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.numberOfSeedPerCell = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.grassAmount = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.seedAmount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LandInfo {
    return {
      landCells: globalThis.Array.isArray(object?.landCells)
        ? object.landCells.map((e: any) => LandCellInfo.fromJSON(e))
        : [],
      landLevel: isSet(object.landLevel) ? globalThis.Number(object.landLevel) : 0,
      eXP: isSet(object.eXP) ? globalThis.Number(object.eXP) : 0,
      eXPToNextLevel: isSet(object.eXPToNextLevel) ? globalThis.Number(object.eXPToNextLevel) : 0,
      coinFeeToNextLevel: isSet(object.coinFeeToNextLevel) ? globalThis.Number(object.coinFeeToNextLevel) : 0,
      weatherType: isSet(object.weatherType) ? landWeatherTypeFromJSON(object.weatherType) : 0,
      seasonType: isSet(object.seasonType) ? landSeasonTypeFromJSON(object.seasonType) : 0,
      numberOfSeedPerCell: isSet(object.numberOfSeedPerCell) ? globalThis.Number(object.numberOfSeedPerCell) : 0,
      grassAmount: isSet(object.grassAmount) ? globalThis.Number(object.grassAmount) : 0,
      seedAmount: isSet(object.seedAmount) ? globalThis.Number(object.seedAmount) : 0,
    };
  },

  toJSON(message: LandInfo): unknown {
    const obj: any = {};
    if (message.landCells?.length) {
      obj.landCells = message.landCells.map((e) => LandCellInfo.toJSON(e));
    }
    if (message.landLevel !== 0) {
      obj.landLevel = Math.round(message.landLevel);
    }
    if (message.eXP !== 0) {
      obj.eXP = Math.round(message.eXP);
    }
    if (message.eXPToNextLevel !== 0) {
      obj.eXPToNextLevel = Math.round(message.eXPToNextLevel);
    }
    if (message.coinFeeToNextLevel !== 0) {
      obj.coinFeeToNextLevel = Math.round(message.coinFeeToNextLevel);
    }
    if (message.weatherType !== 0) {
      obj.weatherType = landWeatherTypeToJSON(message.weatherType);
    }
    if (message.seasonType !== 0) {
      obj.seasonType = landSeasonTypeToJSON(message.seasonType);
    }
    if (message.numberOfSeedPerCell !== 0) {
      obj.numberOfSeedPerCell = Math.round(message.numberOfSeedPerCell);
    }
    if (message.grassAmount !== 0) {
      obj.grassAmount = Math.round(message.grassAmount);
    }
    if (message.seedAmount !== 0) {
      obj.seedAmount = Math.round(message.seedAmount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LandInfo>, I>>(base?: I): LandInfo {
    return LandInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LandInfo>, I>>(object: I): LandInfo {
    const message = createBaseLandInfo();
    message.landCells = object.landCells?.map((e) => LandCellInfo.fromPartial(e)) || [];
    message.landLevel = object.landLevel ?? 0;
    message.eXP = object.eXP ?? 0;
    message.eXPToNextLevel = object.eXPToNextLevel ?? 0;
    message.coinFeeToNextLevel = object.coinFeeToNextLevel ?? 0;
    message.weatherType = object.weatherType ?? 0;
    message.seasonType = object.seasonType ?? 0;
    message.numberOfSeedPerCell = object.numberOfSeedPerCell ?? 0;
    message.grassAmount = object.grassAmount ?? 0;
    message.seedAmount = object.seedAmount ?? 0;
    return message;
  },
};

function createBaseLandRef(): LandRef {
  return { id: "", userId: "", level: 0, exp: 0, seasonType: 0 };
}

export const LandRef: MessageFns<LandRef> = {
  encode(message: LandRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.level !== 0) {
      writer.uint32(24).uint32(message.level);
    }
    if (message.exp !== 0) {
      writer.uint32(32).uint32(message.exp);
    }
    if (message.seasonType !== 0) {
      writer.uint32(40).int32(message.seasonType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LandRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLandRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.level = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.exp = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.seasonType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LandRef {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      exp: isSet(object.exp) ? globalThis.Number(object.exp) : 0,
      seasonType: isSet(object.seasonType) ? landSeasonTypeFromJSON(object.seasonType) : 0,
    };
  },

  toJSON(message: LandRef): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.exp !== 0) {
      obj.exp = Math.round(message.exp);
    }
    if (message.seasonType !== 0) {
      obj.seasonType = landSeasonTypeToJSON(message.seasonType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LandRef>, I>>(base?: I): LandRef {
    return LandRef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LandRef>, I>>(object: I): LandRef {
    const message = createBaseLandRef();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.level = object.level ?? 0;
    message.exp = object.exp ?? 0;
    message.seasonType = object.seasonType ?? 0;
    return message;
  },
};

function createBaseRequestLandInteraction(): RequestLandInteraction {
  return { landCellNumber: 0, interactionType: 0, userId: "" };
}

export const RequestLandInteraction: MessageFns<RequestLandInteraction> = {
  encode(message: RequestLandInteraction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.landCellNumber !== 0) {
      writer.uint32(8).uint32(message.landCellNumber);
    }
    if (message.interactionType !== 0) {
      writer.uint32(16).int32(message.interactionType);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestLandInteraction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestLandInteraction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.landCellNumber = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.interactionType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestLandInteraction {
    return {
      landCellNumber: isSet(object.landCellNumber) ? globalThis.Number(object.landCellNumber) : 0,
      interactionType: isSet(object.interactionType) ? landInteractionTypeFromJSON(object.interactionType) : 0,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: RequestLandInteraction): unknown {
    const obj: any = {};
    if (message.landCellNumber !== 0) {
      obj.landCellNumber = Math.round(message.landCellNumber);
    }
    if (message.interactionType !== 0) {
      obj.interactionType = landInteractionTypeToJSON(message.interactionType);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestLandInteraction>, I>>(base?: I): RequestLandInteraction {
    return RequestLandInteraction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestLandInteraction>, I>>(object: I): RequestLandInteraction {
    const message = createBaseRequestLandInteraction();
    message.landCellNumber = object.landCellNumber ?? 0;
    message.interactionType = object.interactionType ?? 0;
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseLandInteractionData(): LandInteractionData {
  return { interactionType: 0, eXPUpdated: 0, updatedLandCellInfo: undefined, seedAmountUpdated: 0 };
}

export const LandInteractionData: MessageFns<LandInteractionData> = {
  encode(message: LandInteractionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.interactionType !== 0) {
      writer.uint32(8).int32(message.interactionType);
    }
    if (message.eXPUpdated !== 0) {
      writer.uint32(16).uint32(message.eXPUpdated);
    }
    if (message.updatedLandCellInfo !== undefined) {
      LandCellInfo.encode(message.updatedLandCellInfo, writer.uint32(26).fork()).join();
    }
    if (message.seedAmountUpdated !== 0) {
      writer.uint32(32).uint32(message.seedAmountUpdated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LandInteractionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLandInteractionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.interactionType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.eXPUpdated = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.updatedLandCellInfo = LandCellInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.seedAmountUpdated = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LandInteractionData {
    return {
      interactionType: isSet(object.interactionType) ? landInteractionTypeFromJSON(object.interactionType) : 0,
      eXPUpdated: isSet(object.eXPUpdated) ? globalThis.Number(object.eXPUpdated) : 0,
      updatedLandCellInfo: isSet(object.updatedLandCellInfo)
        ? LandCellInfo.fromJSON(object.updatedLandCellInfo)
        : undefined,
      seedAmountUpdated: isSet(object.seedAmountUpdated) ? globalThis.Number(object.seedAmountUpdated) : 0,
    };
  },

  toJSON(message: LandInteractionData): unknown {
    const obj: any = {};
    if (message.interactionType !== 0) {
      obj.interactionType = landInteractionTypeToJSON(message.interactionType);
    }
    if (message.eXPUpdated !== 0) {
      obj.eXPUpdated = Math.round(message.eXPUpdated);
    }
    if (message.updatedLandCellInfo !== undefined) {
      obj.updatedLandCellInfo = LandCellInfo.toJSON(message.updatedLandCellInfo);
    }
    if (message.seedAmountUpdated !== 0) {
      obj.seedAmountUpdated = Math.round(message.seedAmountUpdated);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LandInteractionData>, I>>(base?: I): LandInteractionData {
    return LandInteractionData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LandInteractionData>, I>>(object: I): LandInteractionData {
    const message = createBaseLandInteractionData();
    message.interactionType = object.interactionType ?? 0;
    message.eXPUpdated = object.eXPUpdated ?? 0;
    message.updatedLandCellInfo = (object.updatedLandCellInfo !== undefined && object.updatedLandCellInfo !== null)
      ? LandCellInfo.fromPartial(object.updatedLandCellInfo)
      : undefined;
    message.seedAmountUpdated = object.seedAmountUpdated ?? 0;
    return message;
  },
};

function createBaseResponseLandInteraction(): ResponseLandInteraction {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const ResponseLandInteraction: MessageFns<ResponseLandInteraction> = {
  encode(message: ResponseLandInteraction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      LandInteractionData.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseLandInteraction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseLandInteraction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = LandInteractionData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseLandInteraction {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? LandInteractionData.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ResponseLandInteraction): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = LandInteractionData.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseLandInteraction>, I>>(base?: I): ResponseLandInteraction {
    return ResponseLandInteraction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseLandInteraction>, I>>(object: I): ResponseLandInteraction {
    const message = createBaseResponseLandInteraction();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? LandInteractionData.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseRequestLandLevelUp(): RequestLandLevelUp {
  return {};
}

export const RequestLandLevelUp: MessageFns<RequestLandLevelUp> = {
  encode(_: RequestLandLevelUp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestLandLevelUp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestLandLevelUp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RequestLandLevelUp {
    return {};
  },

  toJSON(_: RequestLandLevelUp): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestLandLevelUp>, I>>(base?: I): RequestLandLevelUp {
    return RequestLandLevelUp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestLandLevelUp>, I>>(_: I): RequestLandLevelUp {
    const message = createBaseRequestLandLevelUp();
    return message;
  },
};

function createBaseLandLevelUpData(): LandLevelUpData {
  return { landLevelUpdated: 0, eXPUpdated: 0, eXPToNextLevelUpdated: 0 };
}

export const LandLevelUpData: MessageFns<LandLevelUpData> = {
  encode(message: LandLevelUpData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.landLevelUpdated !== 0) {
      writer.uint32(8).uint32(message.landLevelUpdated);
    }
    if (message.eXPUpdated !== 0) {
      writer.uint32(16).uint32(message.eXPUpdated);
    }
    if (message.eXPToNextLevelUpdated !== 0) {
      writer.uint32(24).uint32(message.eXPToNextLevelUpdated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LandLevelUpData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLandLevelUpData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.landLevelUpdated = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.eXPUpdated = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.eXPToNextLevelUpdated = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LandLevelUpData {
    return {
      landLevelUpdated: isSet(object.landLevelUpdated) ? globalThis.Number(object.landLevelUpdated) : 0,
      eXPUpdated: isSet(object.eXPUpdated) ? globalThis.Number(object.eXPUpdated) : 0,
      eXPToNextLevelUpdated: isSet(object.eXPToNextLevelUpdated) ? globalThis.Number(object.eXPToNextLevelUpdated) : 0,
    };
  },

  toJSON(message: LandLevelUpData): unknown {
    const obj: any = {};
    if (message.landLevelUpdated !== 0) {
      obj.landLevelUpdated = Math.round(message.landLevelUpdated);
    }
    if (message.eXPUpdated !== 0) {
      obj.eXPUpdated = Math.round(message.eXPUpdated);
    }
    if (message.eXPToNextLevelUpdated !== 0) {
      obj.eXPToNextLevelUpdated = Math.round(message.eXPToNextLevelUpdated);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LandLevelUpData>, I>>(base?: I): LandLevelUpData {
    return LandLevelUpData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LandLevelUpData>, I>>(object: I): LandLevelUpData {
    const message = createBaseLandLevelUpData();
    message.landLevelUpdated = object.landLevelUpdated ?? 0;
    message.eXPUpdated = object.eXPUpdated ?? 0;
    message.eXPToNextLevelUpdated = object.eXPToNextLevelUpdated ?? 0;
    return message;
  },
};

function createBaseResponseLandLevelUp(): ResponseLandLevelUp {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const ResponseLandLevelUp: MessageFns<ResponseLandLevelUp> = {
  encode(message: ResponseLandLevelUp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      LandLevelUpData.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseLandLevelUp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseLandLevelUp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = LandLevelUpData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseLandLevelUp {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? LandLevelUpData.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ResponseLandLevelUp): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = LandLevelUpData.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseLandLevelUp>, I>>(base?: I): ResponseLandLevelUp {
    return ResponseLandLevelUp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseLandLevelUp>, I>>(object: I): ResponseLandLevelUp {
    const message = createBaseResponseLandLevelUp();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? LandLevelUpData.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseRequestLandHarvest(): RequestLandHarvest {
  return { landCellNumber: undefined, isAutoHarvest: false, userId: "" };
}

export const RequestLandHarvest: MessageFns<RequestLandHarvest> = {
  encode(message: RequestLandHarvest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.landCellNumber !== undefined) {
      writer.uint32(8).uint32(message.landCellNumber);
    }
    if (message.isAutoHarvest !== false) {
      writer.uint32(16).bool(message.isAutoHarvest);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestLandHarvest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestLandHarvest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.landCellNumber = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isAutoHarvest = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestLandHarvest {
    return {
      landCellNumber: isSet(object.landCellNumber) ? globalThis.Number(object.landCellNumber) : undefined,
      isAutoHarvest: isSet(object.isAutoHarvest) ? globalThis.Boolean(object.isAutoHarvest) : false,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: RequestLandHarvest): unknown {
    const obj: any = {};
    if (message.landCellNumber !== undefined) {
      obj.landCellNumber = Math.round(message.landCellNumber);
    }
    if (message.isAutoHarvest !== false) {
      obj.isAutoHarvest = message.isAutoHarvest;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestLandHarvest>, I>>(base?: I): RequestLandHarvest {
    return RequestLandHarvest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestLandHarvest>, I>>(object: I): RequestLandHarvest {
    const message = createBaseRequestLandHarvest();
    message.landCellNumber = object.landCellNumber ?? undefined;
    message.isAutoHarvest = object.isAutoHarvest ?? false;
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseHarvestedLandCellInfo(): HarvestedLandCellInfo {
  return { landCell: undefined, droppedItems: [] };
}

export const HarvestedLandCellInfo: MessageFns<HarvestedLandCellInfo> = {
  encode(message: HarvestedLandCellInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.landCell !== undefined) {
      LandCellInfo.encode(message.landCell, writer.uint32(10).fork()).join();
    }
    for (const v of message.droppedItems) {
      ItemRef.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HarvestedLandCellInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHarvestedLandCellInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.landCell = LandCellInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.droppedItems.push(ItemRef.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HarvestedLandCellInfo {
    return {
      landCell: isSet(object.landCell) ? LandCellInfo.fromJSON(object.landCell) : undefined,
      droppedItems: globalThis.Array.isArray(object?.droppedItems)
        ? object.droppedItems.map((e: any) => ItemRef.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HarvestedLandCellInfo): unknown {
    const obj: any = {};
    if (message.landCell !== undefined) {
      obj.landCell = LandCellInfo.toJSON(message.landCell);
    }
    if (message.droppedItems?.length) {
      obj.droppedItems = message.droppedItems.map((e) => ItemRef.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HarvestedLandCellInfo>, I>>(base?: I): HarvestedLandCellInfo {
    return HarvestedLandCellInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HarvestedLandCellInfo>, I>>(object: I): HarvestedLandCellInfo {
    const message = createBaseHarvestedLandCellInfo();
    message.landCell = (object.landCell !== undefined && object.landCell !== null)
      ? LandCellInfo.fromPartial(object.landCell)
      : undefined;
    message.droppedItems = object.droppedItems?.map((e) => ItemRef.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLandHarvestData(): LandHarvestData {
  return { eXPUpdated: 0, isSeasonBoost: false, grassAmountUpdated: 0, harvestedLandCells: [] };
}

export const LandHarvestData: MessageFns<LandHarvestData> = {
  encode(message: LandHarvestData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eXPUpdated !== 0) {
      writer.uint32(8).uint32(message.eXPUpdated);
    }
    if (message.isSeasonBoost !== false) {
      writer.uint32(16).bool(message.isSeasonBoost);
    }
    if (message.grassAmountUpdated !== 0) {
      writer.uint32(24).uint32(message.grassAmountUpdated);
    }
    for (const v of message.harvestedLandCells) {
      HarvestedLandCellInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LandHarvestData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLandHarvestData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.eXPUpdated = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSeasonBoost = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.grassAmountUpdated = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.harvestedLandCells.push(HarvestedLandCellInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LandHarvestData {
    return {
      eXPUpdated: isSet(object.eXPUpdated) ? globalThis.Number(object.eXPUpdated) : 0,
      isSeasonBoost: isSet(object.isSeasonBoost) ? globalThis.Boolean(object.isSeasonBoost) : false,
      grassAmountUpdated: isSet(object.grassAmountUpdated) ? globalThis.Number(object.grassAmountUpdated) : 0,
      harvestedLandCells: globalThis.Array.isArray(object?.harvestedLandCells)
        ? object.harvestedLandCells.map((e: any) => HarvestedLandCellInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LandHarvestData): unknown {
    const obj: any = {};
    if (message.eXPUpdated !== 0) {
      obj.eXPUpdated = Math.round(message.eXPUpdated);
    }
    if (message.isSeasonBoost !== false) {
      obj.isSeasonBoost = message.isSeasonBoost;
    }
    if (message.grassAmountUpdated !== 0) {
      obj.grassAmountUpdated = Math.round(message.grassAmountUpdated);
    }
    if (message.harvestedLandCells?.length) {
      obj.harvestedLandCells = message.harvestedLandCells.map((e) => HarvestedLandCellInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LandHarvestData>, I>>(base?: I): LandHarvestData {
    return LandHarvestData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LandHarvestData>, I>>(object: I): LandHarvestData {
    const message = createBaseLandHarvestData();
    message.eXPUpdated = object.eXPUpdated ?? 0;
    message.isSeasonBoost = object.isSeasonBoost ?? false;
    message.grassAmountUpdated = object.grassAmountUpdated ?? 0;
    message.harvestedLandCells = object.harvestedLandCells?.map((e) => HarvestedLandCellInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResponseLandHarvest(): ResponseLandHarvest {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const ResponseLandHarvest: MessageFns<ResponseLandHarvest> = {
  encode(message: ResponseLandHarvest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      LandHarvestData.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseLandHarvest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseLandHarvest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = LandHarvestData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseLandHarvest {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? LandHarvestData.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ResponseLandHarvest): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = LandHarvestData.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseLandHarvest>, I>>(base?: I): ResponseLandHarvest {
    return ResponseLandHarvest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseLandHarvest>, I>>(object: I): ResponseLandHarvest {
    const message = createBaseResponseLandHarvest();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? LandHarvestData.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseRequestGetLandInfo(): RequestGetLandInfo {
  return { userId: "" };
}

export const RequestGetLandInfo: MessageFns<RequestGetLandInfo> = {
  encode(message: RequestGetLandInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestGetLandInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestGetLandInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestGetLandInfo {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: RequestGetLandInfo): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestGetLandInfo>, I>>(base?: I): RequestGetLandInfo {
    return RequestGetLandInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestGetLandInfo>, I>>(object: I): RequestGetLandInfo {
    const message = createBaseRequestGetLandInfo();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseResponseGetLandInfo(): ResponseGetLandInfo {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const ResponseGetLandInfo: MessageFns<ResponseGetLandInfo> = {
  encode(message: ResponseGetLandInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      LandInfo.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseGetLandInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseGetLandInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = LandInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseGetLandInfo {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? LandInfo.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ResponseGetLandInfo): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = LandInfo.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseGetLandInfo>, I>>(base?: I): ResponseGetLandInfo {
    return ResponseGetLandInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseGetLandInfo>, I>>(object: I): ResponseGetLandInfo {
    const message = createBaseResponseGetLandInfo();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null) ? LandInfo.fromPartial(object.data) : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseCharacterLevelRequirement(): CharacterLevelRequirement {
  return { minLevel: 0, maxLevel: 0 };
}

export const CharacterLevelRequirement: MessageFns<CharacterLevelRequirement> = {
  encode(message: CharacterLevelRequirement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minLevel !== 0) {
      writer.uint32(8).int32(message.minLevel);
    }
    if (message.maxLevel !== 0) {
      writer.uint32(16).int32(message.maxLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterLevelRequirement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterLevelRequirement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.minLevel = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxLevel = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterLevelRequirement {
    return {
      minLevel: isSet(object.minLevel) ? globalThis.Number(object.minLevel) : 0,
      maxLevel: isSet(object.maxLevel) ? globalThis.Number(object.maxLevel) : 0,
    };
  },

  toJSON(message: CharacterLevelRequirement): unknown {
    const obj: any = {};
    if (message.minLevel !== 0) {
      obj.minLevel = Math.round(message.minLevel);
    }
    if (message.maxLevel !== 0) {
      obj.maxLevel = Math.round(message.maxLevel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterLevelRequirement>, I>>(base?: I): CharacterLevelRequirement {
    return CharacterLevelRequirement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterLevelRequirement>, I>>(object: I): CharacterLevelRequirement {
    const message = createBaseCharacterLevelRequirement();
    message.minLevel = object.minLevel ?? 0;
    message.maxLevel = object.maxLevel ?? 0;
    return message;
  },
};

function createBaseExperienceReward(): ExperienceReward {
  return { characterMinExp: 0, characterMaxExp: 0, userMinExp: 0, userMaxExp: 0 };
}

export const ExperienceReward: MessageFns<ExperienceReward> = {
  encode(message: ExperienceReward, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.characterMinExp !== 0) {
      writer.uint32(8).int64(message.characterMinExp);
    }
    if (message.characterMaxExp !== 0) {
      writer.uint32(16).int64(message.characterMaxExp);
    }
    if (message.userMinExp !== 0) {
      writer.uint32(24).int64(message.userMinExp);
    }
    if (message.userMaxExp !== 0) {
      writer.uint32(32).int64(message.userMaxExp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExperienceReward {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExperienceReward();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.characterMinExp = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.characterMaxExp = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.userMinExp = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.userMaxExp = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExperienceReward {
    return {
      characterMinExp: isSet(object.characterMinExp) ? globalThis.Number(object.characterMinExp) : 0,
      characterMaxExp: isSet(object.characterMaxExp) ? globalThis.Number(object.characterMaxExp) : 0,
      userMinExp: isSet(object.userMinExp) ? globalThis.Number(object.userMinExp) : 0,
      userMaxExp: isSet(object.userMaxExp) ? globalThis.Number(object.userMaxExp) : 0,
    };
  },

  toJSON(message: ExperienceReward): unknown {
    const obj: any = {};
    if (message.characterMinExp !== 0) {
      obj.characterMinExp = Math.round(message.characterMinExp);
    }
    if (message.characterMaxExp !== 0) {
      obj.characterMaxExp = Math.round(message.characterMaxExp);
    }
    if (message.userMinExp !== 0) {
      obj.userMinExp = Math.round(message.userMinExp);
    }
    if (message.userMaxExp !== 0) {
      obj.userMaxExp = Math.round(message.userMaxExp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExperienceReward>, I>>(base?: I): ExperienceReward {
    return ExperienceReward.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExperienceReward>, I>>(object: I): ExperienceReward {
    const message = createBaseExperienceReward();
    message.characterMinExp = object.characterMinExp ?? 0;
    message.characterMaxExp = object.characterMaxExp ?? 0;
    message.userMinExp = object.userMinExp ?? 0;
    message.userMaxExp = object.userMaxExp ?? 0;
    return message;
  },
};

function createBaseCurrencyReward(): CurrencyReward {
  return { currency: 0, amount: 0 };
}

export const CurrencyReward: MessageFns<CurrencyReward> = {
  encode(message: CurrencyReward, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currency !== 0) {
      writer.uint32(8).int32(message.currency);
    }
    if (message.amount !== 0) {
      writer.uint32(16).int64(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CurrencyReward {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCurrencyReward();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.currency = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CurrencyReward {
    return {
      currency: isSet(object.currency) ? currencyTypeFromJSON(object.currency) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: CurrencyReward): unknown {
    const obj: any = {};
    if (message.currency !== 0) {
      obj.currency = currencyTypeToJSON(message.currency);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CurrencyReward>, I>>(base?: I): CurrencyReward {
    return CurrencyReward.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CurrencyReward>, I>>(object: I): CurrencyReward {
    const message = createBaseCurrencyReward();
    message.currency = object.currency ?? 0;
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseBattlePvELevelConfig(): BattlePvELevelConfig {
  return {
    level: 0,
    energyLose: 0,
    characterLevel: undefined,
    receiveExp: undefined,
    reward: undefined,
    probabilityWin: 0,
    dropItems: [],
  };
}

export const BattlePvELevelConfig: MessageFns<BattlePvELevelConfig> = {
  encode(message: BattlePvELevelConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.level !== 0) {
      writer.uint32(8).int32(message.level);
    }
    if (message.energyLose !== 0) {
      writer.uint32(16).int32(message.energyLose);
    }
    if (message.characterLevel !== undefined) {
      CharacterLevelRequirement.encode(message.characterLevel, writer.uint32(26).fork()).join();
    }
    if (message.receiveExp !== undefined) {
      ExperienceReward.encode(message.receiveExp, writer.uint32(34).fork()).join();
    }
    if (message.reward !== undefined) {
      CurrencyReward.encode(message.reward, writer.uint32(42).fork()).join();
    }
    if (message.probabilityWin !== 0) {
      writer.uint32(49).double(message.probabilityWin);
    }
    for (const v of message.dropItems) {
      ItemRef.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BattlePvELevelConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattlePvELevelConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.level = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.energyLose = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.characterLevel = CharacterLevelRequirement.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.receiveExp = ExperienceReward.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reward = CurrencyReward.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.probabilityWin = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.dropItems.push(ItemRef.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BattlePvELevelConfig {
    return {
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      energyLose: isSet(object.energyLose) ? globalThis.Number(object.energyLose) : 0,
      characterLevel: isSet(object.characterLevel)
        ? CharacterLevelRequirement.fromJSON(object.characterLevel)
        : undefined,
      receiveExp: isSet(object.receiveExp) ? ExperienceReward.fromJSON(object.receiveExp) : undefined,
      reward: isSet(object.reward) ? CurrencyReward.fromJSON(object.reward) : undefined,
      probabilityWin: isSet(object.probabilityWin) ? globalThis.Number(object.probabilityWin) : 0,
      dropItems: globalThis.Array.isArray(object?.dropItems)
        ? object.dropItems.map((e: any) => ItemRef.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BattlePvELevelConfig): unknown {
    const obj: any = {};
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.energyLose !== 0) {
      obj.energyLose = Math.round(message.energyLose);
    }
    if (message.characterLevel !== undefined) {
      obj.characterLevel = CharacterLevelRequirement.toJSON(message.characterLevel);
    }
    if (message.receiveExp !== undefined) {
      obj.receiveExp = ExperienceReward.toJSON(message.receiveExp);
    }
    if (message.reward !== undefined) {
      obj.reward = CurrencyReward.toJSON(message.reward);
    }
    if (message.probabilityWin !== 0) {
      obj.probabilityWin = message.probabilityWin;
    }
    if (message.dropItems?.length) {
      obj.dropItems = message.dropItems.map((e) => ItemRef.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BattlePvELevelConfig>, I>>(base?: I): BattlePvELevelConfig {
    return BattlePvELevelConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BattlePvELevelConfig>, I>>(object: I): BattlePvELevelConfig {
    const message = createBaseBattlePvELevelConfig();
    message.level = object.level ?? 0;
    message.energyLose = object.energyLose ?? 0;
    message.characterLevel = (object.characterLevel !== undefined && object.characterLevel !== null)
      ? CharacterLevelRequirement.fromPartial(object.characterLevel)
      : undefined;
    message.receiveExp = (object.receiveExp !== undefined && object.receiveExp !== null)
      ? ExperienceReward.fromPartial(object.receiveExp)
      : undefined;
    message.reward = (object.reward !== undefined && object.reward !== null)
      ? CurrencyReward.fromPartial(object.reward)
      : undefined;
    message.probabilityWin = object.probabilityWin ?? 0;
    message.dropItems = object.dropItems?.map((e) => ItemRef.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBattlePvEMapInfo(): BattlePvEMapInfo {
  return { totalLevel: 0, levelConfigs: [] };
}

export const BattlePvEMapInfo: MessageFns<BattlePvEMapInfo> = {
  encode(message: BattlePvEMapInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalLevel !== 0) {
      writer.uint32(8).int32(message.totalLevel);
    }
    for (const v of message.levelConfigs) {
      BattlePvELevelConfig.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BattlePvEMapInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattlePvEMapInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalLevel = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.levelConfigs.push(BattlePvELevelConfig.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BattlePvEMapInfo {
    return {
      totalLevel: isSet(object.totalLevel) ? globalThis.Number(object.totalLevel) : 0,
      levelConfigs: globalThis.Array.isArray(object?.levelConfigs)
        ? object.levelConfigs.map((e: any) => BattlePvELevelConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BattlePvEMapInfo): unknown {
    const obj: any = {};
    if (message.totalLevel !== 0) {
      obj.totalLevel = Math.round(message.totalLevel);
    }
    if (message.levelConfigs?.length) {
      obj.levelConfigs = message.levelConfigs.map((e) => BattlePvELevelConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BattlePvEMapInfo>, I>>(base?: I): BattlePvEMapInfo {
    return BattlePvEMapInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BattlePvEMapInfo>, I>>(object: I): BattlePvEMapInfo {
    const message = createBaseBattlePvEMapInfo();
    message.totalLevel = object.totalLevel ?? 0;
    message.levelConfigs = object.levelConfigs?.map((e) => BattlePvELevelConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRequestGetBattlePvEInfo(): RequestGetBattlePvEInfo {
  return {};
}

export const RequestGetBattlePvEInfo: MessageFns<RequestGetBattlePvEInfo> = {
  encode(_: RequestGetBattlePvEInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestGetBattlePvEInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestGetBattlePvEInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RequestGetBattlePvEInfo {
    return {};
  },

  toJSON(_: RequestGetBattlePvEInfo): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestGetBattlePvEInfo>, I>>(base?: I): RequestGetBattlePvEInfo {
    return RequestGetBattlePvEInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestGetBattlePvEInfo>, I>>(_: I): RequestGetBattlePvEInfo {
    const message = createBaseRequestGetBattlePvEInfo();
    return message;
  },
};

function createBaseResponseGetBattlePvEInfo(): ResponseGetBattlePvEInfo {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const ResponseGetBattlePvEInfo: MessageFns<ResponseGetBattlePvEInfo> = {
  encode(message: ResponseGetBattlePvEInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      BattlePvEMapInfo.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseGetBattlePvEInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseGetBattlePvEInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = BattlePvEMapInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseGetBattlePvEInfo {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? BattlePvEMapInfo.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ResponseGetBattlePvEInfo): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = BattlePvEMapInfo.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseGetBattlePvEInfo>, I>>(base?: I): ResponseGetBattlePvEInfo {
    return ResponseGetBattlePvEInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseGetBattlePvEInfo>, I>>(object: I): ResponseGetBattlePvEInfo {
    const message = createBaseResponseGetBattlePvEInfo();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? BattlePvEMapInfo.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseRequestGetBattlePvpInfo(): RequestGetBattlePvpInfo {
  return {};
}

export const RequestGetBattlePvpInfo: MessageFns<RequestGetBattlePvpInfo> = {
  encode(_: RequestGetBattlePvpInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestGetBattlePvpInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestGetBattlePvpInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RequestGetBattlePvpInfo {
    return {};
  },

  toJSON(_: RequestGetBattlePvpInfo): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestGetBattlePvpInfo>, I>>(base?: I): RequestGetBattlePvpInfo {
    return RequestGetBattlePvpInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestGetBattlePvpInfo>, I>>(_: I): RequestGetBattlePvpInfo {
    const message = createBaseRequestGetBattlePvpInfo();
    return message;
  },
};

function createBaseResponseGetBattlePvpInfo(): ResponseGetBattlePvpInfo {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const ResponseGetBattlePvpInfo: MessageFns<ResponseGetBattlePvpInfo> = {
  encode(message: ResponseGetBattlePvpInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      BattlePvpInfo.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseGetBattlePvpInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseGetBattlePvpInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = BattlePvpInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseGetBattlePvpInfo {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? BattlePvpInfo.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ResponseGetBattlePvpInfo): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = BattlePvpInfo.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseGetBattlePvpInfo>, I>>(base?: I): ResponseGetBattlePvpInfo {
    return ResponseGetBattlePvpInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseGetBattlePvpInfo>, I>>(object: I): ResponseGetBattlePvpInfo {
    const message = createBaseResponseGetBattlePvpInfo();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? BattlePvpInfo.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseRequestBattlePvE(): RequestBattlePvE {
  return { isAutoBattle: false, characterId: "" };
}

export const RequestBattlePvE: MessageFns<RequestBattlePvE> = {
  encode(message: RequestBattlePvE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isAutoBattle !== false) {
      writer.uint32(8).bool(message.isAutoBattle);
    }
    if (message.characterId !== "") {
      writer.uint32(18).string(message.characterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestBattlePvE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestBattlePvE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isAutoBattle = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.characterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestBattlePvE {
    return {
      isAutoBattle: isSet(object.isAutoBattle) ? globalThis.Boolean(object.isAutoBattle) : false,
      characterId: isSet(object.characterId) ? globalThis.String(object.characterId) : "",
    };
  },

  toJSON(message: RequestBattlePvE): unknown {
    const obj: any = {};
    if (message.isAutoBattle !== false) {
      obj.isAutoBattle = message.isAutoBattle;
    }
    if (message.characterId !== "") {
      obj.characterId = message.characterId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestBattlePvE>, I>>(base?: I): RequestBattlePvE {
    return RequestBattlePvE.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestBattlePvE>, I>>(object: I): RequestBattlePvE {
    const message = createBaseRequestBattlePvE();
    message.isAutoBattle = object.isAutoBattle ?? false;
    message.characterId = object.characterId ?? "";
    return message;
  },
};

function createBaseResponseBattlePvE(): ResponseBattlePvE {
  return { status: undefined, data: [], error: undefined, metadata: undefined };
}

export const ResponseBattlePvE: MessageFns<ResponseBattlePvE> = {
  encode(message: ResponseBattlePvE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    for (const v of message.data) {
      BattlePvEData.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseBattlePvE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseBattlePvE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data.push(BattlePvEData.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseBattlePvE {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => BattlePvEData.fromJSON(e)) : [],
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ResponseBattlePvE): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => BattlePvEData.toJSON(e));
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseBattlePvE>, I>>(base?: I): ResponseBattlePvE {
    return ResponseBattlePvE.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseBattlePvE>, I>>(object: I): ResponseBattlePvE {
    const message = createBaseResponseBattlePvE();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = object.data?.map((e) => BattlePvEData.fromPartial(e)) || [];
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseBattlePvEData(): BattlePvEData {
  return {
    isWin: false,
    characterExp: 0,
    userExp: 0,
    currencyReward: undefined,
    droppedItems: [],
    damageDealt: 0,
    damageTaken: 0,
    maxDamageDealt: 0,
    dodges: 0,
  };
}

export const BattlePvEData: MessageFns<BattlePvEData> = {
  encode(message: BattlePvEData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isWin !== false) {
      writer.uint32(8).bool(message.isWin);
    }
    if (message.characterExp !== 0) {
      writer.uint32(16).int64(message.characterExp);
    }
    if (message.userExp !== 0) {
      writer.uint32(24).int64(message.userExp);
    }
    if (message.currencyReward !== undefined) {
      CurrencyReward.encode(message.currencyReward, writer.uint32(34).fork()).join();
    }
    for (const v of message.droppedItems) {
      ItemRef.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.damageDealt !== 0) {
      writer.uint32(48).uint32(message.damageDealt);
    }
    if (message.damageTaken !== 0) {
      writer.uint32(56).uint32(message.damageTaken);
    }
    if (message.maxDamageDealt !== 0) {
      writer.uint32(64).uint32(message.maxDamageDealt);
    }
    if (message.dodges !== 0) {
      writer.uint32(72).uint32(message.dodges);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BattlePvEData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattlePvEData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isWin = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.characterExp = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.userExp = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.currencyReward = CurrencyReward.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.droppedItems.push(ItemRef.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.damageDealt = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.damageTaken = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.maxDamageDealt = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.dodges = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BattlePvEData {
    return {
      isWin: isSet(object.isWin) ? globalThis.Boolean(object.isWin) : false,
      characterExp: isSet(object.characterExp) ? globalThis.Number(object.characterExp) : 0,
      userExp: isSet(object.userExp) ? globalThis.Number(object.userExp) : 0,
      currencyReward: isSet(object.currencyReward) ? CurrencyReward.fromJSON(object.currencyReward) : undefined,
      droppedItems: globalThis.Array.isArray(object?.droppedItems)
        ? object.droppedItems.map((e: any) => ItemRef.fromJSON(e))
        : [],
      damageDealt: isSet(object.damageDealt) ? globalThis.Number(object.damageDealt) : 0,
      damageTaken: isSet(object.damageTaken) ? globalThis.Number(object.damageTaken) : 0,
      maxDamageDealt: isSet(object.maxDamageDealt) ? globalThis.Number(object.maxDamageDealt) : 0,
      dodges: isSet(object.dodges) ? globalThis.Number(object.dodges) : 0,
    };
  },

  toJSON(message: BattlePvEData): unknown {
    const obj: any = {};
    if (message.isWin !== false) {
      obj.isWin = message.isWin;
    }
    if (message.characterExp !== 0) {
      obj.characterExp = Math.round(message.characterExp);
    }
    if (message.userExp !== 0) {
      obj.userExp = Math.round(message.userExp);
    }
    if (message.currencyReward !== undefined) {
      obj.currencyReward = CurrencyReward.toJSON(message.currencyReward);
    }
    if (message.droppedItems?.length) {
      obj.droppedItems = message.droppedItems.map((e) => ItemRef.toJSON(e));
    }
    if (message.damageDealt !== 0) {
      obj.damageDealt = Math.round(message.damageDealt);
    }
    if (message.damageTaken !== 0) {
      obj.damageTaken = Math.round(message.damageTaken);
    }
    if (message.maxDamageDealt !== 0) {
      obj.maxDamageDealt = Math.round(message.maxDamageDealt);
    }
    if (message.dodges !== 0) {
      obj.dodges = Math.round(message.dodges);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BattlePvEData>, I>>(base?: I): BattlePvEData {
    return BattlePvEData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BattlePvEData>, I>>(object: I): BattlePvEData {
    const message = createBaseBattlePvEData();
    message.isWin = object.isWin ?? false;
    message.characterExp = object.characterExp ?? 0;
    message.userExp = object.userExp ?? 0;
    message.currencyReward = (object.currencyReward !== undefined && object.currencyReward !== null)
      ? CurrencyReward.fromPartial(object.currencyReward)
      : undefined;
    message.droppedItems = object.droppedItems?.map((e) => ItemRef.fromPartial(e)) || [];
    message.damageDealt = object.damageDealt ?? 0;
    message.damageTaken = object.damageTaken ?? 0;
    message.maxDamageDealt = object.maxDamageDealt ?? 0;
    message.dodges = object.dodges ?? 0;
    return message;
  },
};

function createBaseRequestBattlePvp(): RequestBattlePvp {
  return { userId: "", characterId: "", opponentCharacterId: "" };
}

export const RequestBattlePvp: MessageFns<RequestBattlePvp> = {
  encode(message: RequestBattlePvp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.characterId !== "") {
      writer.uint32(18).string(message.characterId);
    }
    if (message.opponentCharacterId !== "") {
      writer.uint32(26).string(message.opponentCharacterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestBattlePvp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestBattlePvp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.characterId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.opponentCharacterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestBattlePvp {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      characterId: isSet(object.characterId) ? globalThis.String(object.characterId) : "",
      opponentCharacterId: isSet(object.opponentCharacterId) ? globalThis.String(object.opponentCharacterId) : "",
    };
  },

  toJSON(message: RequestBattlePvp): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.characterId !== "") {
      obj.characterId = message.characterId;
    }
    if (message.opponentCharacterId !== "") {
      obj.opponentCharacterId = message.opponentCharacterId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestBattlePvp>, I>>(base?: I): RequestBattlePvp {
    return RequestBattlePvp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestBattlePvp>, I>>(object: I): RequestBattlePvp {
    const message = createBaseRequestBattlePvp();
    message.userId = object.userId ?? "";
    message.characterId = object.characterId ?? "";
    message.opponentCharacterId = object.opponentCharacterId ?? "";
    return message;
  },
};

function createBaseResponseBattlePvp(): ResponseBattlePvp {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const ResponseBattlePvp: MessageFns<ResponseBattlePvp> = {
  encode(message: ResponseBattlePvp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      BattlePvpInfo.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseBattlePvp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseBattlePvp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = BattlePvpInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseBattlePvp {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? BattlePvpInfo.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ResponseBattlePvp): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = BattlePvpInfo.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseBattlePvp>, I>>(base?: I): ResponseBattlePvp {
    return ResponseBattlePvp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseBattlePvp>, I>>(object: I): ResponseBattlePvp {
    const message = createBaseResponseBattlePvp();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? BattlePvpInfo.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseBattlePvpInfo(): BattlePvpInfo {
  return { userId: "", characterId: "", opponentCharacterId: "" };
}

export const BattlePvpInfo: MessageFns<BattlePvpInfo> = {
  encode(message: BattlePvpInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.characterId !== "") {
      writer.uint32(18).string(message.characterId);
    }
    if (message.opponentCharacterId !== "") {
      writer.uint32(26).string(message.opponentCharacterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BattlePvpInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattlePvpInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.characterId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.opponentCharacterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BattlePvpInfo {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      characterId: isSet(object.characterId) ? globalThis.String(object.characterId) : "",
      opponentCharacterId: isSet(object.opponentCharacterId) ? globalThis.String(object.opponentCharacterId) : "",
    };
  },

  toJSON(message: BattlePvpInfo): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.characterId !== "") {
      obj.characterId = message.characterId;
    }
    if (message.opponentCharacterId !== "") {
      obj.opponentCharacterId = message.opponentCharacterId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BattlePvpInfo>, I>>(base?: I): BattlePvpInfo {
    return BattlePvpInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BattlePvpInfo>, I>>(object: I): BattlePvpInfo {
    const message = createBaseBattlePvpInfo();
    message.userId = object.userId ?? "";
    message.characterId = object.characterId ?? "";
    message.opponentCharacterId = object.opponentCharacterId ?? "";
    return message;
  },
};

function createBaseRequestGetBattleHistory(): RequestGetBattleHistory {
  return { characterId: "", battleType: 0, fromDate: undefined, toDate: undefined, page: undefined };
}

export const RequestGetBattleHistory: MessageFns<RequestGetBattleHistory> = {
  encode(message: RequestGetBattleHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.characterId !== "") {
      writer.uint32(10).string(message.characterId);
    }
    if (message.battleType !== 0) {
      writer.uint32(16).int32(message.battleType);
    }
    if (message.fromDate !== undefined) {
      writer.uint32(26).string(message.fromDate);
    }
    if (message.toDate !== undefined) {
      writer.uint32(34).string(message.toDate);
    }
    if (message.page !== undefined) {
      PageRequest.encode(message.page, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestGetBattleHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestGetBattleHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characterId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.battleType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromDate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toDate = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.page = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestGetBattleHistory {
    return {
      characterId: isSet(object.characterId) ? globalThis.String(object.characterId) : "",
      battleType: isSet(object.battleType) ? battleTypeFromJSON(object.battleType) : 0,
      fromDate: isSet(object.fromDate) ? globalThis.String(object.fromDate) : undefined,
      toDate: isSet(object.toDate) ? globalThis.String(object.toDate) : undefined,
      page: isSet(object.page) ? PageRequest.fromJSON(object.page) : undefined,
    };
  },

  toJSON(message: RequestGetBattleHistory): unknown {
    const obj: any = {};
    if (message.characterId !== "") {
      obj.characterId = message.characterId;
    }
    if (message.battleType !== 0) {
      obj.battleType = battleTypeToJSON(message.battleType);
    }
    if (message.fromDate !== undefined) {
      obj.fromDate = message.fromDate;
    }
    if (message.toDate !== undefined) {
      obj.toDate = message.toDate;
    }
    if (message.page !== undefined) {
      obj.page = PageRequest.toJSON(message.page);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RequestGetBattleHistory>, I>>(base?: I): RequestGetBattleHistory {
    return RequestGetBattleHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RequestGetBattleHistory>, I>>(object: I): RequestGetBattleHistory {
    const message = createBaseRequestGetBattleHistory();
    message.characterId = object.characterId ?? "";
    message.battleType = object.battleType ?? 0;
    message.fromDate = object.fromDate ?? undefined;
    message.toDate = object.toDate ?? undefined;
    message.page = (object.page !== undefined && object.page !== null)
      ? PageRequest.fromPartial(object.page)
      : undefined;
    return message;
  },
};

function createBaseResponseGetBattleHistory(): ResponseGetBattleHistory {
  return { status: undefined, data: undefined, error: undefined, metadata: undefined };
}

export const ResponseGetBattleHistory: MessageFns<ResponseGetBattleHistory> = {
  encode(message: ResponseGetBattleHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.data !== undefined) {
      BattleHistoryData.encode(message.data, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseGetBattleHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseGetBattleHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = BattleHistoryData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseGetBattleHistory {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      data: isSet(object.data) ? BattleHistoryData.fromJSON(object.data) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      metadata: isSet(object.metadata) ? ResponseMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: ResponseGetBattleHistory): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.data !== undefined) {
      obj.data = BattleHistoryData.toJSON(message.data);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseGetBattleHistory>, I>>(base?: I): ResponseGetBattleHistory {
    return ResponseGetBattleHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseGetBattleHistory>, I>>(object: I): ResponseGetBattleHistory {
    const message = createBaseResponseGetBattleHistory();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? BattleHistoryData.fromPartial(object.data)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseBattleHistoryData(): BattleHistoryData {
  return { data: [], pagination: undefined };
}

export const BattleHistoryData: MessageFns<BattleHistoryData> = {
  encode(message: BattleHistoryData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.data) {
      BattleHistory.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BattleHistoryData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleHistoryData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data.push(BattleHistory.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BattleHistoryData {
    return {
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => BattleHistory.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: BattleHistoryData): unknown {
    const obj: any = {};
    if (message.data?.length) {
      obj.data = message.data.map((e) => BattleHistory.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BattleHistoryData>, I>>(base?: I): BattleHistoryData {
    return BattleHistoryData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BattleHistoryData>, I>>(object: I): BattleHistoryData {
    const message = createBaseBattleHistoryData();
    message.data = object.data?.map((e) => BattleHistory.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseBattleHistory(): BattleHistory {
  return {
    id: "",
    userId: "",
    characterId: "",
    opponentCharacterId: undefined,
    battleType: 0,
    battleAt: "",
    isWin: false,
    characterExp: 0,
    userExp: 0,
    currencyReward: undefined,
    droppedItems: [],
    damageDealt: 0,
    damageTaken: 0,
    maxDamageDealt: 0,
    dodges: 0,
  };
}

export const BattleHistory: MessageFns<BattleHistory> = {
  encode(message: BattleHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.characterId !== "") {
      writer.uint32(26).string(message.characterId);
    }
    if (message.opponentCharacterId !== undefined) {
      writer.uint32(34).string(message.opponentCharacterId);
    }
    if (message.battleType !== 0) {
      writer.uint32(40).int32(message.battleType);
    }
    if (message.battleAt !== "") {
      writer.uint32(50).string(message.battleAt);
    }
    if (message.isWin !== false) {
      writer.uint32(56).bool(message.isWin);
    }
    if (message.characterExp !== 0) {
      writer.uint32(64).int64(message.characterExp);
    }
    if (message.userExp !== 0) {
      writer.uint32(72).int64(message.userExp);
    }
    if (message.currencyReward !== undefined) {
      CurrencyReward.encode(message.currencyReward, writer.uint32(82).fork()).join();
    }
    for (const v of message.droppedItems) {
      ItemRef.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.damageDealt !== 0) {
      writer.uint32(96).uint32(message.damageDealt);
    }
    if (message.damageTaken !== 0) {
      writer.uint32(104).uint32(message.damageTaken);
    }
    if (message.maxDamageDealt !== 0) {
      writer.uint32(112).uint32(message.maxDamageDealt);
    }
    if (message.dodges !== 0) {
      writer.uint32(120).uint32(message.dodges);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BattleHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBattleHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.characterId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.opponentCharacterId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.battleType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.battleAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isWin = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.characterExp = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.userExp = longToNumber(reader.int64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.currencyReward = CurrencyReward.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.droppedItems.push(ItemRef.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.damageDealt = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.damageTaken = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.maxDamageDealt = reader.uint32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.dodges = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BattleHistory {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      characterId: isSet(object.characterId) ? globalThis.String(object.characterId) : "",
      opponentCharacterId: isSet(object.opponentCharacterId)
        ? globalThis.String(object.opponentCharacterId)
        : undefined,
      battleType: isSet(object.battleType) ? battleTypeFromJSON(object.battleType) : 0,
      battleAt: isSet(object.battleAt) ? globalThis.String(object.battleAt) : "",
      isWin: isSet(object.isWin) ? globalThis.Boolean(object.isWin) : false,
      characterExp: isSet(object.characterExp) ? globalThis.Number(object.characterExp) : 0,
      userExp: isSet(object.userExp) ? globalThis.Number(object.userExp) : 0,
      currencyReward: isSet(object.currencyReward) ? CurrencyReward.fromJSON(object.currencyReward) : undefined,
      droppedItems: globalThis.Array.isArray(object?.droppedItems)
        ? object.droppedItems.map((e: any) => ItemRef.fromJSON(e))
        : [],
      damageDealt: isSet(object.damageDealt) ? globalThis.Number(object.damageDealt) : 0,
      damageTaken: isSet(object.damageTaken) ? globalThis.Number(object.damageTaken) : 0,
      maxDamageDealt: isSet(object.maxDamageDealt) ? globalThis.Number(object.maxDamageDealt) : 0,
      dodges: isSet(object.dodges) ? globalThis.Number(object.dodges) : 0,
    };
  },

  toJSON(message: BattleHistory): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.characterId !== "") {
      obj.characterId = message.characterId;
    }
    if (message.opponentCharacterId !== undefined) {
      obj.opponentCharacterId = message.opponentCharacterId;
    }
    if (message.battleType !== 0) {
      obj.battleType = battleTypeToJSON(message.battleType);
    }
    if (message.battleAt !== "") {
      obj.battleAt = message.battleAt;
    }
    if (message.isWin !== false) {
      obj.isWin = message.isWin;
    }
    if (message.characterExp !== 0) {
      obj.characterExp = Math.round(message.characterExp);
    }
    if (message.userExp !== 0) {
      obj.userExp = Math.round(message.userExp);
    }
    if (message.currencyReward !== undefined) {
      obj.currencyReward = CurrencyReward.toJSON(message.currencyReward);
    }
    if (message.droppedItems?.length) {
      obj.droppedItems = message.droppedItems.map((e) => ItemRef.toJSON(e));
    }
    if (message.damageDealt !== 0) {
      obj.damageDealt = Math.round(message.damageDealt);
    }
    if (message.damageTaken !== 0) {
      obj.damageTaken = Math.round(message.damageTaken);
    }
    if (message.maxDamageDealt !== 0) {
      obj.maxDamageDealt = Math.round(message.maxDamageDealt);
    }
    if (message.dodges !== 0) {
      obj.dodges = Math.round(message.dodges);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BattleHistory>, I>>(base?: I): BattleHistory {
    return BattleHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BattleHistory>, I>>(object: I): BattleHistory {
    const message = createBaseBattleHistory();
    message.id = object.id ?? "";
    message.userId = object.userId ?? "";
    message.characterId = object.characterId ?? "";
    message.opponentCharacterId = object.opponentCharacterId ?? undefined;
    message.battleType = object.battleType ?? 0;
    message.battleAt = object.battleAt ?? "";
    message.isWin = object.isWin ?? false;
    message.characterExp = object.characterExp ?? 0;
    message.userExp = object.userExp ?? 0;
    message.currencyReward = (object.currencyReward !== undefined && object.currencyReward !== null)
      ? CurrencyReward.fromPartial(object.currencyReward)
      : undefined;
    message.droppedItems = object.droppedItems?.map((e) => ItemRef.fromPartial(e)) || [];
    message.damageDealt = object.damageDealt ?? 0;
    message.damageTaken = object.damageTaken ?? 0;
    message.maxDamageDealt = object.maxDamageDealt ?? 0;
    message.dodges = object.dodges ?? 0;
    return message;
  },
};

/** Character service */
export interface CharacterService {
  /** List user's characters */
  ListCharacters(request: ListCharactersRequest): Promise<ListCharactersResponse>;
  /** Get character by ID */
  GetCharacter(request: GetCharacterRequest): Promise<GetCharacterResponse>;
  /** Update character */
  UpdateCharacter(request: UpdateCharacterRequest): Promise<UpdateCharacterResponse>;
  /** Equip item on character */
  EquipItem(request: EquipItemRequest): Promise<EquipItemResponse>;
  /** Unequip item from character */
  UnequipItem(request: UnequipItemRequest): Promise<UnequipItemResponse>;
  /** Set default character */
  SetDefaultCharacter(request: SetDefaultCharacterRequest): Promise<SetDefaultCharacterResponse>;
  /** Level up character */
  LevelUpCharacter(request: LevelUpCharacterRequest): Promise<LevelUpCharacterResponse>;
  /** Upgrade character stats */
  UpgradeCharacterStats(request: UpgradeCharacterStatsRequest): Promise<UpgradeCharacterStatsResponse>;
  /** Feed character */
  FeedCharacter(request: FeedCharacterRequest): Promise<FeedCharacterResponse>;
  /** Skill slot management */
  UnlockSkillSlot(request: RequestUnlockSkillSlot): Promise<ResponseUnlockSkillSlot>;
}

export const CharacterServiceServiceName = "cwgame_api.CharacterService";
export class CharacterServiceClientImpl implements CharacterService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || CharacterServiceServiceName;
    this.rpc = rpc;
    this.ListCharacters = this.ListCharacters.bind(this);
    this.GetCharacter = this.GetCharacter.bind(this);
    this.UpdateCharacter = this.UpdateCharacter.bind(this);
    this.EquipItem = this.EquipItem.bind(this);
    this.UnequipItem = this.UnequipItem.bind(this);
    this.SetDefaultCharacter = this.SetDefaultCharacter.bind(this);
    this.LevelUpCharacter = this.LevelUpCharacter.bind(this);
    this.UpgradeCharacterStats = this.UpgradeCharacterStats.bind(this);
    this.FeedCharacter = this.FeedCharacter.bind(this);
    this.UnlockSkillSlot = this.UnlockSkillSlot.bind(this);
  }
  ListCharacters(request: ListCharactersRequest): Promise<ListCharactersResponse> {
    const data = ListCharactersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListCharacters", data);
    return promise.then((data) => ListCharactersResponse.decode(new BinaryReader(data)));
  }

  GetCharacter(request: GetCharacterRequest): Promise<GetCharacterResponse> {
    const data = GetCharacterRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetCharacter", data);
    return promise.then((data) => GetCharacterResponse.decode(new BinaryReader(data)));
  }

  UpdateCharacter(request: UpdateCharacterRequest): Promise<UpdateCharacterResponse> {
    const data = UpdateCharacterRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateCharacter", data);
    return promise.then((data) => UpdateCharacterResponse.decode(new BinaryReader(data)));
  }

  EquipItem(request: EquipItemRequest): Promise<EquipItemResponse> {
    const data = EquipItemRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EquipItem", data);
    return promise.then((data) => EquipItemResponse.decode(new BinaryReader(data)));
  }

  UnequipItem(request: UnequipItemRequest): Promise<UnequipItemResponse> {
    const data = UnequipItemRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UnequipItem", data);
    return promise.then((data) => UnequipItemResponse.decode(new BinaryReader(data)));
  }

  SetDefaultCharacter(request: SetDefaultCharacterRequest): Promise<SetDefaultCharacterResponse> {
    const data = SetDefaultCharacterRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetDefaultCharacter", data);
    return promise.then((data) => SetDefaultCharacterResponse.decode(new BinaryReader(data)));
  }

  LevelUpCharacter(request: LevelUpCharacterRequest): Promise<LevelUpCharacterResponse> {
    const data = LevelUpCharacterRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "LevelUpCharacter", data);
    return promise.then((data) => LevelUpCharacterResponse.decode(new BinaryReader(data)));
  }

  UpgradeCharacterStats(request: UpgradeCharacterStatsRequest): Promise<UpgradeCharacterStatsResponse> {
    const data = UpgradeCharacterStatsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpgradeCharacterStats", data);
    return promise.then((data) => UpgradeCharacterStatsResponse.decode(new BinaryReader(data)));
  }

  FeedCharacter(request: FeedCharacterRequest): Promise<FeedCharacterResponse> {
    const data = FeedCharacterRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FeedCharacter", data);
    return promise.then((data) => FeedCharacterResponse.decode(new BinaryReader(data)));
  }

  UnlockSkillSlot(request: RequestUnlockSkillSlot): Promise<ResponseUnlockSkillSlot> {
    const data = RequestUnlockSkillSlot.encode(request).finish();
    const promise = this.rpc.request(this.service, "UnlockSkillSlot", data);
    return promise.then((data) => ResponseUnlockSkillSlot.decode(new BinaryReader(data)));
  }
}

/** Shop service */
export interface ShopService {
  /** List shop items (catalog) */
  ListShopItems(request: ListShopItemsRequest): Promise<ListShopItemsResponse>;
  /** Buy item */
  BuyShopItem(request: BuyShopItemRequest): Promise<BuyShopItemResponse>;
  /** Add item to shop (for testing) */
  AddItemToShop(request: AddItemToShopRequest): Promise<AddItemToShopResponse>;
  /** Wishlist item */
  AddToWishlist(request: AddToWishlistRequest): Promise<AddToWishlistResponse>;
  /** Remove item from wishlist */
  RemoveFromWishlist(request: RemoveFromWishlistRequest): Promise<RemoveFromWishlistResponse>;
  /** list market trade items */
  ListMarketTradeItems(request: ListMarketTradeItemsRequest): Promise<ListMarketTradeItemsResponse>;
  /** sell item to market */
  SellMarketTradeItem(request: SellMarketTradeItemRequest): Promise<SellMarketTradeItemResponse>;
  /** buy item from market */
  BuyMarketTradeItem(request: BuyMarketTradeItemRequest): Promise<BuyMarketTradeItemResponse>;
  /** cancel market trade item */
  CancelMarketTradeItem(request: CancelMarketTradeItemRequest): Promise<CancelMarketTradeItemResponse>;
}

export const ShopServiceServiceName = "cwgame_api.ShopService";
export class ShopServiceClientImpl implements ShopService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ShopServiceServiceName;
    this.rpc = rpc;
    this.ListShopItems = this.ListShopItems.bind(this);
    this.BuyShopItem = this.BuyShopItem.bind(this);
    this.AddItemToShop = this.AddItemToShop.bind(this);
    this.AddToWishlist = this.AddToWishlist.bind(this);
    this.RemoveFromWishlist = this.RemoveFromWishlist.bind(this);
    this.ListMarketTradeItems = this.ListMarketTradeItems.bind(this);
    this.SellMarketTradeItem = this.SellMarketTradeItem.bind(this);
    this.BuyMarketTradeItem = this.BuyMarketTradeItem.bind(this);
    this.CancelMarketTradeItem = this.CancelMarketTradeItem.bind(this);
  }
  ListShopItems(request: ListShopItemsRequest): Promise<ListShopItemsResponse> {
    const data = ListShopItemsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListShopItems", data);
    return promise.then((data) => ListShopItemsResponse.decode(new BinaryReader(data)));
  }

  BuyShopItem(request: BuyShopItemRequest): Promise<BuyShopItemResponse> {
    const data = BuyShopItemRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BuyShopItem", data);
    return promise.then((data) => BuyShopItemResponse.decode(new BinaryReader(data)));
  }

  AddItemToShop(request: AddItemToShopRequest): Promise<AddItemToShopResponse> {
    const data = AddItemToShopRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddItemToShop", data);
    return promise.then((data) => AddItemToShopResponse.decode(new BinaryReader(data)));
  }

  AddToWishlist(request: AddToWishlistRequest): Promise<AddToWishlistResponse> {
    const data = AddToWishlistRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddToWishlist", data);
    return promise.then((data) => AddToWishlistResponse.decode(new BinaryReader(data)));
  }

  RemoveFromWishlist(request: RemoveFromWishlistRequest): Promise<RemoveFromWishlistResponse> {
    const data = RemoveFromWishlistRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveFromWishlist", data);
    return promise.then((data) => RemoveFromWishlistResponse.decode(new BinaryReader(data)));
  }

  ListMarketTradeItems(request: ListMarketTradeItemsRequest): Promise<ListMarketTradeItemsResponse> {
    const data = ListMarketTradeItemsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListMarketTradeItems", data);
    return promise.then((data) => ListMarketTradeItemsResponse.decode(new BinaryReader(data)));
  }

  SellMarketTradeItem(request: SellMarketTradeItemRequest): Promise<SellMarketTradeItemResponse> {
    const data = SellMarketTradeItemRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SellMarketTradeItem", data);
    return promise.then((data) => SellMarketTradeItemResponse.decode(new BinaryReader(data)));
  }

  BuyMarketTradeItem(request: BuyMarketTradeItemRequest): Promise<BuyMarketTradeItemResponse> {
    const data = BuyMarketTradeItemRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BuyMarketTradeItem", data);
    return promise.then((data) => BuyMarketTradeItemResponse.decode(new BinaryReader(data)));
  }

  CancelMarketTradeItem(request: CancelMarketTradeItemRequest): Promise<CancelMarketTradeItemResponse> {
    const data = CancelMarketTradeItemRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelMarketTradeItem", data);
    return promise.then((data) => CancelMarketTradeItemResponse.decode(new BinaryReader(data)));
  }
}

/** Inventory service */
export interface InventoryService {
  /** Get user's inventory */
  GetUserInventory(request: GetUserInventoryRequest): Promise<GetUserInventoryResponse>;
  /** Add item to inventory */
  AddItemToInventory(request: AddItemToInventoryRequest): Promise<AddItemToInventoryResponse>;
  /** Get user inventory currency */
  GetUserInventoryCurrency(request: GetUserInventoryCurrencyRequest): Promise<GetUserInventoryCurrencyResponse>;
  /** Sell item */
  SellItem(request: SellItemRequest): Promise<SellItemResponse>;
}

export const InventoryServiceServiceName = "cwgame_api.InventoryService";
export class InventoryServiceClientImpl implements InventoryService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || InventoryServiceServiceName;
    this.rpc = rpc;
    this.GetUserInventory = this.GetUserInventory.bind(this);
    this.AddItemToInventory = this.AddItemToInventory.bind(this);
    this.GetUserInventoryCurrency = this.GetUserInventoryCurrency.bind(this);
    this.SellItem = this.SellItem.bind(this);
  }
  GetUserInventory(request: GetUserInventoryRequest): Promise<GetUserInventoryResponse> {
    const data = GetUserInventoryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUserInventory", data);
    return promise.then((data) => GetUserInventoryResponse.decode(new BinaryReader(data)));
  }

  AddItemToInventory(request: AddItemToInventoryRequest): Promise<AddItemToInventoryResponse> {
    const data = AddItemToInventoryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddItemToInventory", data);
    return promise.then((data) => AddItemToInventoryResponse.decode(new BinaryReader(data)));
  }

  GetUserInventoryCurrency(request: GetUserInventoryCurrencyRequest): Promise<GetUserInventoryCurrencyResponse> {
    const data = GetUserInventoryCurrencyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUserInventoryCurrency", data);
    return promise.then((data) => GetUserInventoryCurrencyResponse.decode(new BinaryReader(data)));
  }

  SellItem(request: SellItemRequest): Promise<SellItemResponse> {
    const data = SellItemRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SellItem", data);
    return promise.then((data) => SellItemResponse.decode(new BinaryReader(data)));
  }
}

export interface GameSystemService {
  GetGameSystemConfig(request: GetGameSystemConfigRequest): Promise<GetGameSystemConfigResponse>;
  /**
   * ------ EGG SYSTEM
   * Get complete egg system configuration (recommended)
   */
  GetEggSystemConfig(request: GetEggSystemConfigRequest): Promise<GetEggSystemConfigResponse>;
  /** Craft GEN1 egg from fragments */
  CraftEgg(request: CraftEggRequest): Promise<CraftEggResponse>;
  /** Open item to get item */
  OpenItem(request: OpenItemRequest): Promise<OpenItemResponse>;
  /** Claim chest */
  ClaimChest(request: ClaimChestRequest): Promise<ClaimChestResponse>;
}

export const GameSystemServiceServiceName = "cwgame_api.GameSystemService";
export class GameSystemServiceClientImpl implements GameSystemService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || GameSystemServiceServiceName;
    this.rpc = rpc;
    this.GetGameSystemConfig = this.GetGameSystemConfig.bind(this);
    this.GetEggSystemConfig = this.GetEggSystemConfig.bind(this);
    this.CraftEgg = this.CraftEgg.bind(this);
    this.OpenItem = this.OpenItem.bind(this);
    this.ClaimChest = this.ClaimChest.bind(this);
  }
  GetGameSystemConfig(request: GetGameSystemConfigRequest): Promise<GetGameSystemConfigResponse> {
    const data = GetGameSystemConfigRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetGameSystemConfig", data);
    return promise.then((data) => GetGameSystemConfigResponse.decode(new BinaryReader(data)));
  }

  GetEggSystemConfig(request: GetEggSystemConfigRequest): Promise<GetEggSystemConfigResponse> {
    const data = GetEggSystemConfigRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetEggSystemConfig", data);
    return promise.then((data) => GetEggSystemConfigResponse.decode(new BinaryReader(data)));
  }

  CraftEgg(request: CraftEggRequest): Promise<CraftEggResponse> {
    const data = CraftEggRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CraftEgg", data);
    return promise.then((data) => CraftEggResponse.decode(new BinaryReader(data)));
  }

  OpenItem(request: OpenItemRequest): Promise<OpenItemResponse> {
    const data = OpenItemRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "OpenItem", data);
    return promise.then((data) => OpenItemResponse.decode(new BinaryReader(data)));
  }

  ClaimChest(request: ClaimChestRequest): Promise<ClaimChestResponse> {
    const data = ClaimChestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ClaimChest", data);
    return promise.then((data) => ClaimChestResponse.decode(new BinaryReader(data)));
  }
}

/** Wallet service */
export interface WalletService {
  /** Get user's wallets */
  GetUserWallets(request: GetUserWalletsRequest): Promise<GetUserWalletsResponse>;
  /** Add currency to wallet */
  AddCurrency(request: AddCurrencyRequest): Promise<AddCurrencyResponse>;
  /** Spend currency from wallet */
  SpendCurrency(request: SpendCurrencyRequest): Promise<SpendCurrencyResponse>;
}

export const WalletServiceServiceName = "cwgame_api.WalletService";
export class WalletServiceClientImpl implements WalletService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || WalletServiceServiceName;
    this.rpc = rpc;
    this.GetUserWallets = this.GetUserWallets.bind(this);
    this.AddCurrency = this.AddCurrency.bind(this);
    this.SpendCurrency = this.SpendCurrency.bind(this);
  }
  GetUserWallets(request: GetUserWalletsRequest): Promise<GetUserWalletsResponse> {
    const data = GetUserWalletsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetUserWallets", data);
    return promise.then((data) => GetUserWalletsResponse.decode(new BinaryReader(data)));
  }

  AddCurrency(request: AddCurrencyRequest): Promise<AddCurrencyResponse> {
    const data = AddCurrencyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddCurrency", data);
    return promise.then((data) => AddCurrencyResponse.decode(new BinaryReader(data)));
  }

  SpendCurrency(request: SpendCurrencyRequest): Promise<SpendCurrencyResponse> {
    const data = SpendCurrencyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SpendCurrency", data);
    return promise.then((data) => SpendCurrencyResponse.decode(new BinaryReader(data)));
  }
}

/** Service definition */
export interface UtilityService {
  SayHelloNakama(request: RequestHelloNakama): Promise<ResponseHelloNakama>;
  GetServerTime(request: RequestServerTime): Promise<ResponseServerTime>;
}

export const UtilityServiceServiceName = "cwgame_api.UtilityService";
export class UtilityServiceClientImpl implements UtilityService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || UtilityServiceServiceName;
    this.rpc = rpc;
    this.SayHelloNakama = this.SayHelloNakama.bind(this);
    this.GetServerTime = this.GetServerTime.bind(this);
  }
  SayHelloNakama(request: RequestHelloNakama): Promise<ResponseHelloNakama> {
    const data = RequestHelloNakama.encode(request).finish();
    const promise = this.rpc.request(this.service, "SayHelloNakama", data);
    return promise.then((data) => ResponseHelloNakama.decode(new BinaryReader(data)));
  }

  GetServerTime(request: RequestServerTime): Promise<ResponseServerTime> {
    const data = RequestServerTime.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetServerTime", data);
    return promise.then((data) => ResponseServerTime.decode(new BinaryReader(data)));
  }
}

/** Service definition */
export interface CwGameService {
  SayHello(request: RequestHello): Promise<ResponseHello>;
  /** ------ ACCOUNT SYSTEM */
  SyncAccount(request: RequestSyncAccount): Promise<ResponseSyncAccount>;
  UpdateAccount(request: UpdateAccountRequest): Promise<UpdateAccountResponse>;
  GetAccountByUsername(request: GetAccountByUsernameRequest): Promise<GetAccountByUsernameResponse>;
  RegisterAccount(request: RegisterAccountRequest): Promise<CommonResponse>;
  AuthenticateAccount(request: AuthenticateAccountRequest): Promise<AuthenticateAccountResponse>;
  GetProfile(request: GetProfileRequest): Promise<GetProfileResponse>;
  /** ------ Ranking System */
  GetGlobalUserRanking(request: GetGlobalUserRankingRequest): Promise<GetGlobalUserRankingResponse>;
  GetGlobalLandRanking(request: GetGlobalLandRankingRequest): Promise<GetGlobalLandRankingResponse>;
  GetChestInfo(request: GetChestInfoRequest): Promise<GetChestInfoResponse>;
  GetCwUserIdByNkUserId(request: GetCwUserIdByNkUserIdRequest): Promise<GetCwUserIdByNkUserIdResponse>;
}

export const CwGameServiceServiceName = "cwgame_api.CwGameService";
export class CwGameServiceClientImpl implements CwGameService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || CwGameServiceServiceName;
    this.rpc = rpc;
    this.SayHello = this.SayHello.bind(this);
    this.SyncAccount = this.SyncAccount.bind(this);
    this.UpdateAccount = this.UpdateAccount.bind(this);
    this.GetAccountByUsername = this.GetAccountByUsername.bind(this);
    this.RegisterAccount = this.RegisterAccount.bind(this);
    this.AuthenticateAccount = this.AuthenticateAccount.bind(this);
    this.GetProfile = this.GetProfile.bind(this);
    this.GetGlobalUserRanking = this.GetGlobalUserRanking.bind(this);
    this.GetGlobalLandRanking = this.GetGlobalLandRanking.bind(this);
    this.GetChestInfo = this.GetChestInfo.bind(this);
    this.GetCwUserIdByNkUserId = this.GetCwUserIdByNkUserId.bind(this);
  }
  SayHello(request: RequestHello): Promise<ResponseHello> {
    const data = RequestHello.encode(request).finish();
    const promise = this.rpc.request(this.service, "SayHello", data);
    return promise.then((data) => ResponseHello.decode(new BinaryReader(data)));
  }

  SyncAccount(request: RequestSyncAccount): Promise<ResponseSyncAccount> {
    const data = RequestSyncAccount.encode(request).finish();
    const promise = this.rpc.request(this.service, "SyncAccount", data);
    return promise.then((data) => ResponseSyncAccount.decode(new BinaryReader(data)));
  }

  UpdateAccount(request: UpdateAccountRequest): Promise<UpdateAccountResponse> {
    const data = UpdateAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateAccount", data);
    return promise.then((data) => UpdateAccountResponse.decode(new BinaryReader(data)));
  }

  GetAccountByUsername(request: GetAccountByUsernameRequest): Promise<GetAccountByUsernameResponse> {
    const data = GetAccountByUsernameRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAccountByUsername", data);
    return promise.then((data) => GetAccountByUsernameResponse.decode(new BinaryReader(data)));
  }

  RegisterAccount(request: RegisterAccountRequest): Promise<CommonResponse> {
    const data = RegisterAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RegisterAccount", data);
    return promise.then((data) => CommonResponse.decode(new BinaryReader(data)));
  }

  AuthenticateAccount(request: AuthenticateAccountRequest): Promise<AuthenticateAccountResponse> {
    const data = AuthenticateAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AuthenticateAccount", data);
    return promise.then((data) => AuthenticateAccountResponse.decode(new BinaryReader(data)));
  }

  GetProfile(request: GetProfileRequest): Promise<GetProfileResponse> {
    const data = GetProfileRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetProfile", data);
    return promise.then((data) => GetProfileResponse.decode(new BinaryReader(data)));
  }

  GetGlobalUserRanking(request: GetGlobalUserRankingRequest): Promise<GetGlobalUserRankingResponse> {
    const data = GetGlobalUserRankingRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetGlobalUserRanking", data);
    return promise.then((data) => GetGlobalUserRankingResponse.decode(new BinaryReader(data)));
  }

  GetGlobalLandRanking(request: GetGlobalLandRankingRequest): Promise<GetGlobalLandRankingResponse> {
    const data = GetGlobalLandRankingRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetGlobalLandRanking", data);
    return promise.then((data) => GetGlobalLandRankingResponse.decode(new BinaryReader(data)));
  }

  GetChestInfo(request: GetChestInfoRequest): Promise<GetChestInfoResponse> {
    const data = GetChestInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetChestInfo", data);
    return promise.then((data) => GetChestInfoResponse.decode(new BinaryReader(data)));
  }

  GetCwUserIdByNkUserId(request: GetCwUserIdByNkUserIdRequest): Promise<GetCwUserIdByNkUserIdResponse> {
    const data = GetCwUserIdByNkUserIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetCwUserIdByNkUserId", data);
    return promise.then((data) => GetCwUserIdByNkUserIdResponse.decode(new BinaryReader(data)));
  }
}

/** Farming service */
export interface FarmingService {
  /** Get land information */
  GetLandInfo(request: RequestGetLandInfo): Promise<ResponseGetLandInfo>;
  /** Plant seeds on land cell */
  HarvestLand(request: RequestLandHarvest): Promise<ResponseLandHarvest>;
  /** Level up land */
  LevelUpLand(request: RequestLandLevelUp): Promise<ResponseLandLevelUp>;
  /** Land interaction */
  LandInteraction(request: RequestLandInteraction): Promise<ResponseLandInteraction>;
}

export const FarmingServiceServiceName = "cwgame_api.FarmingService";
export class FarmingServiceClientImpl implements FarmingService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || FarmingServiceServiceName;
    this.rpc = rpc;
    this.GetLandInfo = this.GetLandInfo.bind(this);
    this.HarvestLand = this.HarvestLand.bind(this);
    this.LevelUpLand = this.LevelUpLand.bind(this);
    this.LandInteraction = this.LandInteraction.bind(this);
  }
  GetLandInfo(request: RequestGetLandInfo): Promise<ResponseGetLandInfo> {
    const data = RequestGetLandInfo.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetLandInfo", data);
    return promise.then((data) => ResponseGetLandInfo.decode(new BinaryReader(data)));
  }

  HarvestLand(request: RequestLandHarvest): Promise<ResponseLandHarvest> {
    const data = RequestLandHarvest.encode(request).finish();
    const promise = this.rpc.request(this.service, "HarvestLand", data);
    return promise.then((data) => ResponseLandHarvest.decode(new BinaryReader(data)));
  }

  LevelUpLand(request: RequestLandLevelUp): Promise<ResponseLandLevelUp> {
    const data = RequestLandLevelUp.encode(request).finish();
    const promise = this.rpc.request(this.service, "LevelUpLand", data);
    return promise.then((data) => ResponseLandLevelUp.decode(new BinaryReader(data)));
  }

  LandInteraction(request: RequestLandInteraction): Promise<ResponseLandInteraction> {
    const data = RequestLandInteraction.encode(request).finish();
    const promise = this.rpc.request(this.service, "LandInteraction", data);
    return promise.then((data) => ResponseLandInteraction.decode(new BinaryReader(data)));
  }
}

export interface BattleService {
  /** Get battle pve map info */
  GetBattlePvEInfo(request: RequestGetBattlePvEInfo): Promise<ResponseGetBattlePvEInfo>;
  /** Get battle pvp map info */
  GetBattlePvpInfo(request: RequestGetBattlePvpInfo): Promise<ResponseGetBattlePvpInfo>;
  /** Battle pve */
  BattlePve(request: RequestBattlePvE): Promise<ResponseBattlePvE>;
  /** Battle pvp */
  BattlePvp(request: RequestBattlePvp): Promise<ResponseBattlePvp>;
  /** Battle History */
  GetBattleHistory(request: RequestGetBattleHistory): Promise<ResponseGetBattleHistory>;
}

export const BattleServiceServiceName = "cwgame_api.BattleService";
export class BattleServiceClientImpl implements BattleService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || BattleServiceServiceName;
    this.rpc = rpc;
    this.GetBattlePvEInfo = this.GetBattlePvEInfo.bind(this);
    this.GetBattlePvpInfo = this.GetBattlePvpInfo.bind(this);
    this.BattlePve = this.BattlePve.bind(this);
    this.BattlePvp = this.BattlePvp.bind(this);
    this.GetBattleHistory = this.GetBattleHistory.bind(this);
  }
  GetBattlePvEInfo(request: RequestGetBattlePvEInfo): Promise<ResponseGetBattlePvEInfo> {
    const data = RequestGetBattlePvEInfo.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBattlePvEInfo", data);
    return promise.then((data) => ResponseGetBattlePvEInfo.decode(new BinaryReader(data)));
  }

  GetBattlePvpInfo(request: RequestGetBattlePvpInfo): Promise<ResponseGetBattlePvpInfo> {
    const data = RequestGetBattlePvpInfo.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBattlePvpInfo", data);
    return promise.then((data) => ResponseGetBattlePvpInfo.decode(new BinaryReader(data)));
  }

  BattlePve(request: RequestBattlePvE): Promise<ResponseBattlePvE> {
    const data = RequestBattlePvE.encode(request).finish();
    const promise = this.rpc.request(this.service, "BattlePve", data);
    return promise.then((data) => ResponseBattlePvE.decode(new BinaryReader(data)));
  }

  BattlePvp(request: RequestBattlePvp): Promise<ResponseBattlePvp> {
    const data = RequestBattlePvp.encode(request).finish();
    const promise = this.rpc.request(this.service, "BattlePvp", data);
    return promise.then((data) => ResponseBattlePvp.decode(new BinaryReader(data)));
  }

  GetBattleHistory(request: RequestGetBattleHistory): Promise<ResponseGetBattleHistory> {
    const data = RequestGetBattleHistory.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBattleHistory", data);
    return promise.then((data) => ResponseGetBattleHistory.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
